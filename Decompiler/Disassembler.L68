00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/2/2014 9:51:43 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 00002276             30                  LEA     intro_stuff, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 000022B0             33                  LEA     intro_msg, A1       ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 00002276             36                  LEA     intro_stuff, A1     ; Load introduction
0000101E  103C 000D                 37                  MOVE.B  #13, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024                            39                  
00001024                            40  
00001024                            41  *-----------Prompt For Starting Address---------------------                  
00001024  43F9 00002321             42  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
0000102A  103C 000E                 43                  MOVE.B  #14,D0              ; Load task code for display
0000102E  4E4F                      44                  TRAP    #15                 ; Display prompt message
00001030                            45                  
00001030  43F9 000024BC             46                  LEA     start_input,A1      ; Load address to store user's input
00001036  103C 0002                 47                  MOVE.B  #2,D0               ; Load task code for user input
0000103A  4E4F                      48                  TRAP    #15                 ; Ask for user input
0000103C  4EB9 00001232             49                  JSR     verify_input        ; Verifies user input string
00001042  B83C 0001                 50                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001046  6700 0010                 51                  BEQ     valid_start         ; Go to valid start if equal 
0000104A                            52                  
0000104A  43F9 00002421             53                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
00001050  103C 000E                 54                  MOVE.B  #14,D0              ; Load task code for display
00001054  4E4F                      55                  TRAP    #15                 ; Display bad input message
00001056  60CC                      56                  BRA     prompt_start        ; Go back beginning, asking for start address
00001058                            57  
00001058  4EB9 00001336             58  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000105E  B67C FFFF                 59                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
00001062  67C0                      60                  BEQ     prompt_start        ; Go back and ask for correct input
00001064  7C00                      61                  MOVE.L  #begin,D6           ; Store minimum address in D6
00001066  B686                      62                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001068  6D00 02AA                 63                  BLT     start_error         ; Then, start address is too low
0000106C  2C3C 00FFFFFE             64                  MOVE.L  #end,D6             ; Store max end address for comparison
00001072  B686                      65                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001074  6E00 029E                 66                  BGT     start_error         ; Then, start address is too high
00001078  2643                      67                  MOVEA.L D3,A3               ; Load starting address                 
0000107A                            68  
0000107A                            69  *-----------Prompt for Ending Address-----------------------            
0000107A  43F9 0000235A             70  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
00001080  103C 000E                 71                  MOVE.B  #14,D0              ; Load task code for display
00001084  4E4F                      72                  TRAP    #15                 ; Display prompt message
00001086  43F9 000024BC             73                  LEA     start_input,A1      ; Load starting address
0000108C  4E4F                      74                  TRAP    #15                 ; Display starting address
0000108E  43F9 00002381             75                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
00001094  4E4F                      76                  TRAP    #15                 ; Display prompt message
00001096  43F9 000024C4             77                  LEA     end_input,A1        ; Ask for ending address
0000109C  103C 0002                 78                  MOVE.B  #2,D0               ; Load task code for input
000010A0  4E4F                      79                  TRAP    #15                 ; Prompt for input
000010A2  4EB9 00001232             80                  JSR     verify_input        ; Verifies user input string
000010A8  B83C 0001                 81                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010AC  6700 0010                 82                  BEQ     valid_end           ; Now validate the ending address
000010B0  43F9 00002421             83                  LEA     badAddr_input,A1        ; Else, bad input
000010B6  103C 000E                 84                  MOVE.B  #14,D0              ; Load task code for display
000010BA  4E4F                      85                  TRAP    #15                 ; Display bad input message
000010BC  60BC                      86                  BRA     prompt_end          ; Restart process
000010BE                            87  
000010BE  4EB9 00001336             88  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
000010C4  B67C FFFF                 89                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
000010C8  67B0                      90                  BEQ     prompt_end          ; Go back and ask for correct input
000010CA  2C3C 00FFFFFE             91                  MOVE.L  #end,D6             ; Move max address to compare with input
000010D0  B686                      92                  CMP.L   D6,D3               ; Is input higher than max
000010D2  6E00 024A                 93                  BGT     end_error           ; Input address is too high
000010D6  B68B                      94                  CMP.L   A3,D3               ; Is input at or above minimum address
000010D8  6D00 0244                 95                  BLT     end_error           ; Input address is too low
000010DC  2843                      96                  MOVEA.L D3,A4               ; Load ending address
000010DE                            97                                 
000010DE                            98  ;-------------- disassemble ---------------------------------------------------
000010DE                            99  ; -- Reads the data from the specified memory locations
000010DE                           100  ; -- Passes the data over to OP-code to verify the instruction
000010DE                           101  ; -- Decodes the word data from the specified memory location until the end
000010DE                           102  ; -- Checks for illegal data and valid data with the bad buffer bit
000010DE                           103  ;------------------------------------------------------------------------------
000010DE  4283                     104  disassemble     CLR.L   D3                  ; Clear for IO usage
000010E0  4284                     105                  CLR.L   D4                  ; Clear for OP Code usage              
000010E2  B7CC                     106                  CMP.L   A4,A3               ; At the end address?
000010E4  6E00 00D4                107                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
000010E8                           108                  
000010E8  4EB9 0000118A            109                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
000010EE  2C0B                     110                  MOVE.L  A3,D6               ; Store current address
000010F0                           111                  
000010F0  4DF9 000024E0            112                  LEA     illegal_data,A6     ; Load illegal data's address
000010F6  4EB9 00001290            113                  JSR     hex_to_ASCII_L      ; Store address to memory for display
000010FC  204E                     114                  MOVEA.L A6,A0               ; Store current location of illegal data
000010FE                           115                  
000010FE  4BF9 00002620            116                  LEA     valid_data,A5       ; Store current address to memory
00001104                           117                  
00001104  4DF9 00002620            118                  LEA     valid_data,A6       ; Store current address to memory
0000110A  4EB9 00001290            119                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
00001110  1CFC 0009                120                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001114                           121                  
00001114  381B                     122                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001116  4EB9 0000135C            123                  JSR     OP_CODE_TREE        ; Go to OP code jump table
0000111C                           124                  
0000111C  BE3C 0001                125                  CMP.B   #1,D7               ; Bad buffer set?
00001120  6700 0036                126                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001124                           127  main_loop
00001124                           128                  ; Store new line in memory
00001124  1CFC 000A                129                  MOVE.B  #LF,(A6)+
00001128  1CFC 000D                130                  MOVE.B  #CR,(A6)+
0000112C  BE3C 0001                131                  CMP.B   #1,D7               ; Bad buffer set?
00001130  6600 0012                132                  BNE     good_buff           ; Good Buffer, go prep for display
00001134                           133                  
00001134  4287                     134  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001136  1CFC 0000                135                  MOVE.B  #00,(A6)+           ; Add null terminator
0000113A  43F9 000024E0            136                  LEA     illegal_data,A1     ; Load the illegal data for display
00001140  6000 000C                137                  BRA     display_data        ; Go to display data
00001144                           138                  
00001144  1CFC 0000                139  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001148  43F9 00002620            140                  LEA     valid_data,A1       ; Load the valid data for display
0000114E                           141                  
0000114E  4280                     142  display_data    CLR.L   D0                  ; Clear for TASK TRAP
00001150  103C 000E                143                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001154  4E4F                     144                  TRAP    #15                 ; to in memory.
00001156  6086                     145                  BRA     disassemble         ; Done disassembling the word, next word                
00001158                           146                                                 
00001158                           147  ILLEGAL         ; word data from memory is not a required instruction
00001158  4BF9 000024E0            148                  LEA     illegal_data,A5     ; Store current address to memory
0000115E  2C48                     149                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
00001160  1CFC 0009                150                  MOVE.B  #HT,(A6)+           ; Store TAB 
00001164  1CFC 0044                151                  MOVE.B  #'D',(A6)+          ; Store DATA
00001168  1CFC 0041                152                  MOVE.B  #'A',(A6)+
0000116C  1CFC 0054                153                  MOVE.B  #'T',(A6)+
00001170  1CFC 0041                154                  MOVE.B  #'A',(A6)+
00001174  4EB9 00001AD0            155                  JSR     OP_TAB              ; Set up third collumn
0000117A  1CFC 0024                156                  MOVE.B  #'$',(A6)+
0000117E                           157                  
0000117E                           158                  ; Store 4 hex digits that represent the word into memory
0000117E  4286                     159                  CLR.L   D6
00001180  3C04                     160                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
00001182  4EB9 000012B0            161                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
00001188  609A                     162                  BRA     main_loop           ; Store info to memory as string              
0000118A                           163  
0000118A                           164  ;------------check_10_lines----------------------------------------------------
0000118A                           165  ; -- Prompt user to hit enter when there are 10 lines of data
0000118A                           166  ; -- Then reset the line count and go back to disassemble more data
0000118A                           167  ;------------------------------------------------------------------------------
0000118A                           168  check_10_lines
0000118A  45F9 000024DC            169                  LEA     line_count,A2       ; Assign A2 pointer for line count
00001190  5212                     170                  ADD.B   #1,(A2)             ; Increment counter
00001192  0C12 0014                171                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
00001196  6700 0004                172                  BEQ     prompt_for_data     ; At 31
0000119A  4E75                     173                  RTS                         ; Return to disassemble
0000119C                           174  
0000119C  43F9 000023F3            175  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011A2  103C 000E                176                  MOVE.B  #14,D0              ; Display message
000011A6  4E4F                     177                  TRAP    #15
000011A8  43F9 000024D4            178                  LEA     hit_enter,A1        ; Take user input
000011AE  103C 0002                179                  MOVE.B  #2,D0               
000011B2  4E4F                     180                  TRAP    #15
000011B4  14BC 0000                181                  MOVE.B  #0,(A2)             ; Reset counter
000011B8  4E75                     182                  RTS                         ; Return to disassemble
000011BA                           183  
000011BA                           184  ;------------prompt_to_rerun----------------------------------------------------
000011BA                           185  ; -- Prompt user to rerun or end program
000011BA                           186  ;------------------------------------------------------------------------------
000011BA  43F9 000023C3            187  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011C0  103C 000E                188                  MOVE.B  #14,D0
000011C4  4E4F                     189                  TRAP    #15
000011C6  43F9 000024CC            190                  LEA     ask_input,A1        ; Take user input
000011CC  103C 0002                191                  MOVE.B  #2,D0
000011D0  4E4F                     192                  TRAP    #15
000011D2  45F9 000024DC            193                  LEA     line_count,A2       ; Load line count to reset
000011D8  14BC 0000                194                  MOVE.B  #0,(A2)             ; Reset the line_count
000011DC  B23C 0001                195                  CMP.B   #1,D1               ; User input must be the length of 1
000011E0  6E00 0032                196                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
000011E4  6D00 002E                197                  BLT     rerun_err_msg       ; until the user inputs correctly.
000011E8  4240                     198                  CLR     D0                  ; Clear D0 for comparison
000011EA  1039 000024CC            199                  MOVE.B  ask_input,D0        ; Load user input for comparison
000011F0  B03C 004E                200                  CMP.B   #'N',D0             ; User input is N
000011F4  6700 002C                201                  BEQ     done                ; End of program if N
000011F8  B03C 006E                202                  CMP.B   #'n',D0             ; User input is n
000011FC  6700 0024                203                  BEQ     done                ; End of program if n
00001200  B03C 0059                204                  CMP.B   #'Y',D0             ; User input is Y
00001204  6700 FE1E                205                  BEQ     prompt_start        ; Run the program again
00001208  B03C 0079                206                  CMP.B   #'y',D0             ; User input is y
0000120C  6700 FE16                207                  BEQ     prompt_start        ; Run the program again
00001210  6000 0002                208                  BRA     rerun_err_msg       ; Bad input, prompt user
00001214                           209                  
00001214  43F9 00002483            210  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
0000121A  103C 000E                211                  MOVE.B  #14,D0
0000121E  4E4F                     212                  TRAP    #15
00001220  6098                     213                  BRA     prompt_to_rerun     ; Prompt user for rerun           
00001222                           214                  
00001222                           215      
00001222                           216  ;------------End-of-Program----------------------------------------------------                
00001222  43F9 00002391            217  done            LEA     ending,A1           ; Load ending message
00001228  103C 000D                218                  MOVE.B  #13,D0              ; Load task code for display
0000122C  4E4F                     219                  TRAP    #15                 ; Display ending message
0000122E  4E72 2700                220                  STOP    #$00002700          ; End of program
00001232                           221                  
00001232                           222  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
00001232  4283                     223  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001234  4285                     224                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001236  B205                     225                  CMP.B   D5,D1               ; Check input length, if lower than one
00001238  6700 004E                226                  BEQ     invalid             ; Its an invalid input
0000123C  0C41 0008                227                  CMPI    #$8,D1              ; Check input length, if higher than 8
00001240  6E00 0046                228                  BGT     invalid             ; Its an invalid input
00001244                           229                  
00001244  4282                     230  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001246  1419                     231                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001248  B405                     232                  CMP.B   D5,D2               ; Check to see if next char is null(0)
0000124A  6700 0040                233                  BEQ     return              ; Character is null, end of input
0000124E                           234                  
0000124E  B43C 0046                235                  CMP.B   #70,D2              ; Invalid character if decimal value
00001252  6E00 0034                236                  BGT     invalid             ; is higher than 70.
00001256  B43C 0040                237                  CMP.B   #64,D2              ; Is a letter if decimal value is 
0000125A  6E00 001E                238                  BGT     is_letter           ; between 65 - 70.
0000125E                           239                  
0000125E  B43C 0039                240                  CMP.B   #57,D2              ; Invalid character if decimal value is
00001262  6E00 0024                241                  BGT     invalid             ; between 58 - 64
00001266  B43C 002F                242                  CMP.B   #47,D2              ; Is a number if decimal value is 
0000126A  6E00 0006                243                  BGT     is_number           ; between 48 - 57.
0000126E  6000 0018                244                  BRA     invalid             ; Decimal values below 48 are invalid 
00001272                           245                               
00001272  0402 0030                246  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
00001276  6000 000A                247                  BRA     verified            ; Put character into a register
0000127A                           248                               
0000127A  0402 0037                249  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
0000127E  6000 0002                250                  BRA     verified            ; Put character into a register
00001282                           251                 
00001282  E983                     252  verified        ASL.L   #4,D3               ; Shift hex bit left one
00001284  D602                     253                  ADD.B   D2,D3               ; Add to verified register
00001286  60BC                     254                  BRA     check_input         ; Check the rest of the input                       
00001288                           255                  
00001288  7800                     256  invalid         MOVEQ   #0,D4               ; Invalid address
0000128A  4E75                     257                  RTS                         ; Return to start/end prompt
0000128C                           258                  
0000128C  7801                     259  return          MOVEQ   #1,D4               ; Valid address
0000128E  4E75                     260                  RTS                         ; Return to start/end prompt
00001290                           261                  
00001290                           262  ;----------------------------------------------------------
00001290                           263  ; Convert Hexidecimal to ASCII (Stores into Memory)
00001290                           264  ;
00001290                           265  ; -- At the moment, takes the Illegal data and stores 
00001290                           266  ;    it into memory so that it can be printed later
00001290                           267  ;----------------------------------------------------------
00001290  4281                     268  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
00001292  4282                     269                  CLR.L   D2                      ; Used for shifting left
00001294  4283                     270                  CLR.L   D3                      ; Counter
00001296  123C 001C                271                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
0000129A                           272  hex_ASCII_loopL
0000129A  B63C 0008                273                  CMP.B   #8,D3                   ; Done converting?
0000129E  6700 0072                274                  BEQ     done_converting         ; If equal to 8, done
000012A2  2006                     275                  MOVE.L  D6,D0                   ; Do calculations in D0
000012A4  E5A8                     276                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012A6  E2A8                     277                  LSR.L   D1,D0                   ; Isolate number
000012A8  4EB9 000012F0            278                  JSR     convert_hex
000012AE  60EA                     279                  BRA     hex_ASCII_loopL
000012B0                           280                  
000012B0  4281                     281  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012B2  4282                     282                  CLR.L   D2                      ; Used for shifting left
000012B4  4283                     283                  CLR.L   D3                      ; Counter
000012B6  123C 000C                284                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012BA                           285  hex_ASCII_loopW
000012BA  B63C 0004                286                  CMP.B   #4,D3                   ; Done converting?
000012BE  6700 0052                287                  BEQ     done_converting         ; If equal to 4, done
000012C2  2006                     288                  MOVE.L  D6,D0                   ; Do calculations in D0
000012C4  E568                     289                  LSL.W   D2,D0                   ; Eliminate stuff to the left
000012C6  E268                     290                  LSR.W   D1,D0                   ; Isolate number
000012C8  4EB9 000012F0            291                  JSR     convert_hex
000012CE  60EA                     292                  BRA     hex_ASCII_loopW
000012D0                           293  
000012D0  4281                     294  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
000012D2  4282                     295                  CLR.L   D2                      ; Used for shifting left
000012D4  4283                     296                  CLR.L   D3                      ; Counter
000012D6  123C 0004                297                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
000012DA                           298  hex_ASCII_loopB
000012DA  B63C 0002                299                  CMP.B   #2,D3                   ; Done converting?
000012DE  6700 0032                300                  BEQ     done_converting         ; If equal to 2, done
000012E2  2006                     301                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E4  E528                     302                  LSL.B   D2,D0                   ; Eliminate stuff to the left
000012E6  E228                     303                  LSR.B   D1,D0                   ; Isolate number
000012E8  4EB9 000012F0            304                  JSR     convert_hex
000012EE  60EA                     305                  BRA     hex_ASCII_loopB                  
000012F0                           306  
000012F0  B03C 000A                307  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
000012F4  6D00 0006                308                  BLT     make_number             ; Make it a number, if lower than 10
000012F8  6C00 000E                309                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
000012FC                           310                       
000012FC  0600 0030                311  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
00001300  1CC0                     312                  MOVE.B  D0,(A6)+                ; Store in memory
00001302  5203                     313                  ADD.B   #1,D3                   ; Add to counter
00001304  5802                     314                  ADD.B   #4,D2                   ; Shift left by one digit
00001306  4E75                     315                  RTS                             ; Check next number
00001308                           316                  
00001308  0600 0037                317  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
0000130C  1CC0                     318                  MOVE.B  D0,(A6)+                ; Store to memory
0000130E  5203                     319                  ADD.B   #1,D3                   ; Add to counter
00001310  5802                     320                  ADD.B   #4,D2                   ; Shift left by one digit                 
00001312  4E75                     321  done_converting RTS                             ; Check next number              
00001314                           322  
00001314                           323  ;-----------Error Messages ----------------------------------------------------
00001314  4EB9 00001328            324  start_error     JSR     load_bad_input      ; Print bad input error message
0000131A  4EF8 1024                325                  JMP     prompt_start        ; Return to prompt for start address
0000131E                           326                  
0000131E  4EB9 00001328            327  end_error       JSR     load_bad_input      ; Print bad input error message
00001324  4EF8 107A                328                  JMP     prompt_end          ; Return to prompt for end address
00001328                           329  
00001328  43F9 00002421            330  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000132E  103C 000D                331                  MOVE.B  #13,D0              ; Load task code for display
00001332  4E4F                     332                  TRAP    #15                 ; Display bad input message
00001334  4E75                     333                  RTS                         ; Return to (start/end)_error
00001336                           334  
00001336  4282                     335  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001338  3403                     336                  MOVE.W  D3,D2               ; Put address in D2 for calulation
0000133A  7202                     337                  MOVE.L  #2,D1               ; Load 2 into D1 for division
0000133C  84C1                     338                  DIVU    D1,D2               ; Divide address by 2
0000133E  4842                     339                  SWAP    D2                  ; Swap contents of D2 to get remainder
00001340  B43C 0001                340                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001344  6700 0004                341                  BEQ     odd_err             ; Go to print out odd bound error message
00001348  4E75                     342                  RTS                         ; Return to valid_(start/end)
0000134A                           343                  
0000134A  43F9 00002457            344  odd_err         LEA     odd_input,A1        ; Load odd input message
00001350  103C 000E                345                  MOVE.B  #14,D0              ; Load task code for display
00001354  4E4F                     346                  TRAP    #15                 ; Display odd input message
00001356  4685                     347                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001358  2605                     348                  MOVE.L  D5,D3               ; Load -1 to returned data register
0000135A  4E75                     349                  RTS                         ; Return to valid_(start/end)
0000135C                           350  
0000135C                           351  OP_CODE_TREE    ; Parses the Op-Code to find what it is
0000135C                           352          
0000135C  B8BC 00004E75            353          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
00001362  6700 04B8                354          Beq     OP_RTS
00001366                           355  
00001366  4EB9 0000213C            356          Jsr     GET12TO15
0000136C                           357          
0000136C  B03C 0000                358          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
00001370  6700 0066                359          Beq     IMMEDIATE_BTST
00001374                           360          
00001374  B03C 0001                361          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
00001378  6700 0238                362          Beq     OP_MOVE
0000137C                           363          
0000137C  B03C 0003                364          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
00001380  6700 0230                365          Beq     OP_MOVE
00001384                           366  
00001384  B03C 0002                367          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
00001388  6700 0228                368          Beq     OP_MOVE
0000138C                           369          
0000138C  B03C 0004                370          Cmp.B     #%0100, D0       ; not enough info, Single OPs
00001390  6700 008C                371          Beq     SINGLE_OPERATOR_CODES
00001394                           372      
00001394  B03C 0006                373          Cmp.B     #%0110, D0       ; Beqnch conditionals
00001398  6700 00DE                374          Beq     BRANCH_CONDITIONALS
0000139C                           375          
0000139C  B03C 000C                376          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013A0  6700 0158                377          Beq     AND_MULS
000013A4                           378          
000013A4  B03C 000E                379          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013A8  6700 0190                380          Beq     BIT_SHIFT
000013AC                           381          
000013AC  B03C 0005                382          Cmp.B     #%0101, D0       ; Add Quick
000013B0  6700 024C                383          Beq     OP_ADDQ
000013B4                           384          
000013B4  B03C 0008                385          Cmp.B     #%1000, D0       ; Signed Divide
000013B8  6700 0280                386          Beq     OP_DIVS
000013BC                           387          
000013BC  B03C 0009                388          Cmp.B     #%1001, D0       ; Sub & SubA
000013C0  6700 02A8                389          Beq     OP_SUB
000013C4                           390          
000013C4  B03C 000B                391          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
000013C8  6700 01C6                392          Beq     CMP_EOR
000013CC                           393          
000013CC  B03C 000D                394          Cmp.B     #%1101, D0       ; Add & AddA
000013D0  6700 02D6                395          Beq     OP_ADD
000013D4                           396          
000013D4  6000 06F4                397          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
000013D8                           398          
000013D8                           399  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
000013D8                           400          
000013D8  4EB9 0000217E            401          Jsr     GET6TO8         ; Change out test bits
000013DE                           402          
000013DE  B03C 0004                403          Cmp.B     #%100, D0          ; Bit test
000013E2  6700 0302                404          Beq     OP_BTST
000013E6                           405          
000013E6  4EB9 00002264            406          Jsr     GET6TO11
000013EC                           407          
000013EC  B03C 0020                408          Cmp.B   #%100000,D0     ;BTST
000013F0  6700 02F4                409          Beq     OP_BTST
000013F4                           410          
000013F4  4EB9 0000216C            411          Jsr     GET9TO11        ; Change out test bits
000013FA                           412          
000013FA  B03C 0000                413          Cmp.B     #%000, D0        ; Or I
000013FE  6700 0300                414          Beq     OP_ORI
00001402                           415          
00001402  B03C 0002                416          Cmp.B     #%010, D0        ; Subtract I
00001406  6700 0314                417          Beq     OP_SUBI
0000140A                           418          
0000140A  B03C 0005                419          Cmp.B     #%101, D0        ; Exclusive or, I
0000140E  6700 032C                420          Beq     OP_EORI
00001412                           421          
00001412  B03C 0006                422          Cmp.B     #%110, D0        ; Compare I
00001416  6700 0344                423          Beq     OP_CMPI
0000141A                           424          
0000141A  6000 06AE                425          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
0000141E                           426          
0000141E                           427  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
0000141E                           428  
0000141E  4EB9 000021B4            429          Jsr     GETBIT8        ; Change out test bits
00001424                           430          
00001424  B03C 0001                431          Cmp.B     #%1, D0      ; Load effetive address
00001428  6700 0352                432          Beq     OP_LEA
0000142C                           433                  
0000142C  4EB9 0000216C            434          Jsr     GET9TO11       ; Change out test bits        
00001432                           435  
00001432  B03C 0002                436          Cmp.B     #%010, D0    ; Negate
00001436  6700 035A                437          Beq     OP_NEG
0000143A                           438         
0000143A  B03C 0003                439          Cmp.B     #%011, D0    ; Not
0000143E  6700 036E                440          Beq     OP_NOT
00001442                           441          
00001442  B03C 0004                442          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001446  6700 0382                443          Beq     OP_MOVEM
0000144A                           444          
0000144A  B03C 0006                445          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
0000144E  6700 037A                446          Beq     OP_MOVEM
00001452                           447          
00001452  B03C 0007                448          Cmp.B     #%111, D0    ; JSR
00001456  6700 03D8                449          Beq     OP_JSR
0000145A                           450          
0000145A  6000 066E                451          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
0000145E                           452  
0000145E                           453  JSR_RTS     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
0000145E                           454  
0000145E  4EB9 0000217E            455          Jsr     GET6TO8        ; Change out test bits        
00001464                           456  
00001464  B03C 0001                457          Cmp.B     #%001, D0    ; Return from subroutine
00001468  6700 03B2                458          Beq     OP_RTS
0000146C                           459          
0000146C  B03C 0002                460          Cmp.B     #%010, D0    ; Jump to Subroutine
00001470  6700 03BE                461          Beq     OP_JSR
00001474                           462          
00001474  6000 0654                463          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
00001478                           464  
00001478                           465  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
00001478                           466  
00001478  4EB9 0000215A            467          Jsr     GET8TO11    ; Change out test bits        
0000147E                           468  
0000147E  B03C 0000                469          Cmp.B     #%0000, D0   ; Branch
00001482  6700 03C2                470          Beq     OP_BRANCH      
00001486                           471          
00001486  B03C 0002                472          Cmp.B     #%0010, D0   ; High
0000148A  6700 03D0                473          Beq     OP_BRA_HIGH
0000148E                           474          
0000148E  B03C 0003                475          Cmp.B     #%0011, D0   ; Low/same
00001492  6700 03DE                476          Beq     OP_BRA_LOW
00001496                           477          
00001496  B03C 0004                478          Cmp.B     #%0100, D0   ; Carry Clear
0000149A  6700 03EC                479          Beq     OP_BRA_CC
0000149E                           480          
0000149E  B03C 0005                481          Cmp.B     #%0101, D0   ; Carry Set
000014A2  6700 03FA                482          Beq     OP_BRA_CS
000014A6                           483          
000014A6  B03C 0006                484          Cmp.B     #%0110, D0   ; Not Equal
000014AA  6700 0408                485          Beq     OP_BRA_NE
000014AE                           486          
000014AE  B03C 0007                487          Cmp.B     #%0111, D0   ; Equal
000014B2  6700 0416                488          Beq     OP_BRA_EQ
000014B6                           489          
000014B6  B03C 0008                490          Cmp.B     #%1000, D0   ; Overflow Clear
000014BA  6700 0424                491          Beq     OP_BRA_VC
000014BE                           492          
000014BE  B03C 0009                493          Cmp.B     #%1001, D0   ; Overflow Set
000014C2  6700 0432                494          Beq     OP_BRA_VS
000014C6                           495          
000014C6  B03C 000A                496          Cmp.B     #%1010, D0   ; Plus
000014CA  6700 0440                497          Beq     OP_BRA_PL
000014CE                           498          
000014CE  B03C 000B                499          Cmp.B     #%1011, D0   ; Minus
000014D2  6700 044E                500          Beq     OP_BRA_MI
000014D6                           501          
000014D6  B03C 000C                502          Cmp.B     #%1100, D0   ; Greater than or Equal
000014DA  6700 045C                503          Beq     OP_BRA_GE
000014DE                           504          
000014DE  B03C 000D                505          Cmp.B     #%1101, D0   ; Less Than
000014E2  6700 046A                506          Beq     OP_BRA_LT
000014E6                           507          
000014E6  B03C 000E                508          Cmp.B     #%1110, D0   ; Greater Than
000014EA  6700 0478                509          Beq     OP_BRA_GT
000014EE                           510          
000014EE  B03C 000F                511          Cmp.B     #%1111, D0   ; Less than or Equal
000014F2  6700 0486                512          Beq     OP_BRA_LE
000014F6                           513          
000014F6  6000 05D2                514          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
000014FA                           515  
000014FA                           516  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
000014FA                           517  
000014FA  4EB9 00002252            518          Jsr     Get3TO8
00001500                           519          
00001500  B03C 0021                520          Cmp.B     #%100001, D0   ; ABCD
00001504  6700 05C4                521          Beq     OP_SET_BAD_BUFFER        
00001508  B03C 0020                522          Cmp.B     #%100000,D0    ; ABCD
0000150C  6700 05BC                523          Beq     OP_SET_BAD_BUFFER        
00001510  B03C 0028                524          Cmp.B     #%101000,D0    ; EXG
00001514  6700 05B4                525          Beq     OP_SET_BAD_BUFFER
00001518  B03C 0029                526          Cmp.B     #%101001,D0    ; EXG
0000151C  6700 05AC                527          Beq     OP_SET_BAD_BUFFER
00001520  B03C 0031                528          Cmp.B     #%110001,D0    ; EXG
00001524  6700 FC32                529          Beq     ILLEGAL        
00001528                           530  
00001528  4EB9 0000217E            531          Jsr     GET6TO8        ; Change out test bits        
0000152E                           532  
0000152E  B03C 0007                533          Cmp.B     #%111, D0    ; Multiply signed
00001532  6700 045C                534          Beq     OP_MULS
00001536                           535          
00001536  6000 047A                536          Bra     OP_AND      ; Probably AND, check more in OP_AND
0000153A                           537          
0000153A                           538  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
0000153A                           539          
0000153A                           540          ; Determine if the shift is Register or Memory shifting
0000153A                           541          
0000153A  4EB9 000021D8            542          Jsr     GET6AND7
00001540                           543          
00001540  B03C 0003                544          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
00001544  6700 0006                545          Beq     BIT_SHIFT_MEM
00001548                           546  
00001548  6000 0024                547          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
0000154C                           548  
0000154C                           549  BIT_SHIFT_MEM
0000154C                           550          
0000154C  4EB9 000021C6            551          Jsr     GET9AND10         ; Change out test bits
00001552                           552          
00001552  B03C 0000                553          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001556  6700 0494                554          Beq     OP_AS_MEM
0000155A                           555          
0000155A  B03C 0001                556          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
0000155E  6700 04C2                557          Beq     OP_LS_MEM
00001562                           558          
00001562  B03C 0003                559          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001566  6700 04F0                560          Beq     OP_RO_MEM
0000156A                           561          
0000156A  6000 055E                562          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
0000156E                           563  
0000156E                           564  BIT_SHIFT_REG
0000156E                           565          
0000156E  4EB9 000021FC            566          Jsr     GET3AND4        ; Change out test bits
00001574                           567          
00001574  B03C 0000                568          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001578  6700 0454                569          Beq     OP_AS_REG
0000157C                           570          
0000157C  B03C 0001                571          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001580  6700 0482                572          Beq     OP_LS_REG
00001584                           573          
00001584  B03C 0003                574          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001588  6700 04B0                575          Beq     OP_RO_REG
0000158C                           576          
0000158C  6000 053C                577          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001590                           578  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
00001590                           579          
00001590  4EB9 0000217E            580          Jsr     GET6TO8         ; Change out test bits
00001596                           581          
00001596  B03C 0004                582          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
0000159A  6700 0512                583          Beq     OP_EOR
0000159E                           584          
0000159E  B03C 0005                585          Cmp.B     #%101,D0
000015A2  6700 050A                586          Beq     OP_EOR
000015A6                           587          
000015A6  B03C 0006                588          Cmp.B     #%110,D0
000015AA  6700 0502                589          Beq     OP_EOR
000015AE                           590          
000015AE                           591          
000015AE  6000 04C0                592          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015B2                           593  
000015B2                           594  ;---------------------OP_CODE Functions---------------------;
000015B2                           595  ; These Functions have all determined what Op-code or group
000015B2                           596  ; of op-codes I have. The next goal is to Add to the string
000015B2                           597  ; and call the accompying EA function to get the rest of the
000015B2                           598  ; String
000015B2                           599  
000015B2                           600  ; REGISTERS USED: D0, D4 (const), A6
000015B2                           601  
000015B2                           602  ;-----------------------  MOVE  -----------------------------;
000015B2                           603  OP_MOVE
000015B2                           604      ; start string
000015B2                           605      
000015B2  1CFC 004D                606          Move.B  #'M', (A6)+
000015B6  1CFC 004F                607          Move.B  #'O', (A6)+
000015BA  1CFC 0056                608          Move.B  #'V', (A6)+
000015BE  1CFC 0045                609          Move.B  #'E', (A6)+
000015C2                           610      
000015C2                           611      ; is it an address move?
000015C2  4EB9 0000217E            612          Jsr     GET6TO8     ; Get the mode
000015C8  4EB9 00001AE4            613          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
000015CE                           614          
000015CE                           615      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
000015CE                           616      ; But move does not use the Op-mode bits, so i'll do it manually
000015CE                           617      
000015CE  4EB9 0000213C            618          Jsr     GET12TO15
000015D4                           619  
000015D4                           620          ; Jump to a sub routine to get the data, so it returns back correctly
000015D4  4EB9 000015E4            621          Jsr     OP_MOVE_DATA
000015DA                           622          
000015DA                           623          ; Put in tabs
000015DA  4EB9 00001AD0            624          Jsr     OP_TAB
000015E0                           625          
000015E0                           626          ; Hand the function off to John
000015E0  6000 0580                627          BRA     EA_MOVE        
000015E4                           628  
000015E4                           629  OP_MOVE_DATA
000015E4                           630          
000015E4  B07C 0001                631          Cmp     #%0001, D0
000015E8  6700 053C                632          Beq     OP_SET_DATA_BYTE
000015EC                           633          
000015EC  B07C 0002                634          Cmp     #%0010, D0
000015F0  6700 0548                635          Beq     OP_SET_DATA_LONG
000015F4                           636          
000015F4  B07C 0003                637          Cmp     #%0011, D0
000015F8  6700 0536                638          Beq     OP_SET_DATA_WORD
000015FC                           639          
000015FC  4E75                     640          Rts
000015FE                           641  
000015FE                           642  ;-----------------------  ADDQ  -----------------------------;
000015FE                           643          
000015FE                           644  OP_ADDQ
000015FE                           645      ; Check fringe cases
000015FE  4EB9 000021B4            646          Jsr     GETBIT8
00001604  B03C 0001                647          Cmp.B   #%1,D0
00001608  6700 04C0                648          Beq     OP_SET_BAD_BUFFER        
0000160C  4EB9 000021D8            649          Jsr     GET6AND7
00001612  B03C 0003                650          Cmp.B   #%11,D0
00001616  6700 04B2                651          Beq     OP_SET_BAD_BUFFER       
0000161A                           652  
0000161A                           653      ; start string
0000161A                           654      
0000161A  1CFC 0041                655          Move.B  #'A', (A6)+
0000161E  1CFC 0044                656          Move.B  #'D', (A6)+
00001622  1CFC 0044                657          Move.B  #'D', (A6)+
00001626  1CFC 0051                658          Move.B  #'Q', (A6)+
0000162A                           659          
0000162A                           660      ; Check data type        
0000162A  4EB9 00001AF4            661          Jsr     OP_CHECK_DATA_SIZE
00001630                           662          
00001630                           663      ; Put in tabs
00001630  4EB9 00001AD0            664          Jsr     OP_TAB
00001636                           665          
00001636                           666      ; Hand the function off to John
00001636  6000 082A                667          BRA     EA_ADDQ
0000163A                           668  
0000163A                           669      
0000163A                           670  ;------------------  DIVIDE SINGED  -------------------------;
0000163A                           671      
0000163A                           672  OP_DIVS
0000163A                           673      ; One last check to make sure I have the right stuff
0000163A                           674      
0000163A  4EB9 0000217E            675          Jsr     GET6TO8
00001640  B07C 0007                676          Cmp     #%111,D0
00001644  6600 0484                677          Bne     OP_SET_BAD_BUFFER
00001648                           678          
00001648                           679      ; start string
00001648                           680      
00001648  1CFC 0044                681          Move.B  #'D', (A6)+
0000164C  1CFC 0049                682          Move.B  #'I', (A6)+
00001650  1CFC 0056                683          Move.B  #'V', (A6)+
00001654  1CFC 0053                684          Move.B  #'S', (A6)+
00001658  1CFC 002E                685          Move.B  #'.', (A6)+
0000165C  1CFC 0057                686          Move.B  #'W', (A6)+
00001660                           687          
00001660                           688      ; Put in tabs
00001660  4EB9 00001AD0            689          Jsr     OP_TAB    
00001666                           690      
00001666                           691      ; Handoff to John
00001666                           692          
00001666  6000 093A                693          BRA     EA_DIVS
0000166A                           694  
0000166A                           695      
0000166A                           696  ;-----------------------  SUB  ------------------------------;    
0000166A                           697      
0000166A                           698  OP_SUB
0000166A                           699      ; start string
0000166A                           700      
0000166A  1CFC 0053                701          Move.B  #'S', (A6)+
0000166E  1CFC 0055                702          Move.B  #'U', (A6)+
00001672  1CFC 0042                703          Move.B  #'B', (A6)+
00001676                           704  
00001676                           705  
00001676                           706       ; Check for address version
00001676                           707          
00001676  4EB9 000021D8            708          Jsr     GET6AND7
0000167C  B03C 0003                709          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001680                           710          
00001680  6700 0012                711          Beq     OP_SUB_ADDR
00001684                           712  
00001684                           713          ; Don't need to worry about ADDA in V1
00001684                           714          ; Check data size
00001684  4EB9 00001AF4            715          Jsr     OP_CHECK_DATA_SIZE
0000168A                           716          
0000168A                           717          ; Put in tabs
0000168A  4EB9 00001AD0            718          Jsr     OP_TAB
00001690                           719          
00001690  6000 080E                720          BRA     EA_SUB 
00001694                           721          
00001694                           722  OP_SUB_ADDR
00001694                           723          
00001694  1CFC 0041                724          Move.B  #'A',(A6)+ ; add to the string
00001698                           725          
00001698                           726          ; Find data size
00001698                           727          
00001698  4EB9 00001B14            728          Jsr     OP_CHECK_DATA_SIZE_ADDR
0000169E                           729          
0000169E                           730          ; Put in tabs
0000169E  4EB9 00001AD0            731          Jsr     OP_TAB
000016A4                           732          
000016A4                           733          ; Handoff
000016A4  6000 07FA                734          BRA     EA_SUB
000016A8                           735          
000016A8                           736  ;-----------------------  ADD  ------------------------------;
000016A8                           737  
000016A8                           738  OP_ADD
000016A8                           739      ; start string
000016A8                           740      
000016A8  1CFC 0041                741          Move.B  #'A', (A6)+
000016AC  1CFC 0044                742          Move.B  #'D', (A6)+
000016B0  1CFC 0044                743          Move.B  #'D', (A6)+
000016B4                           744  
000016B4                           745      ; Check for address version
000016B4                           746          
000016B4  4EB9 000021D8            747          Jsr     GET6AND7
000016BA  B03C 0003                748          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016BE                           749          
000016BE  6700 0012                750          Beq     OP_ADD_ADDR
000016C2                           751          
000016C2                           752          ; Don't need to worry about ADDA in V1
000016C2                           753          ; Check data size
000016C2  4EB9 00001AF4            754          Jsr     OP_CHECK_DATA_SIZE
000016C8                           755          
000016C8                           756          ; Put in tabs
000016C8  4EB9 00001AD0            757          Jsr     OP_TAB
000016CE                           758          
000016CE  6000 06D6                759          BRA     EA_ADD
000016D2                           760          
000016D2                           761  OP_ADD_ADDR
000016D2                           762          
000016D2  1CFC 0041                763          Move.B  #'A',(A6)+ ; add to the string
000016D6                           764          
000016D6                           765          ; Find data size
000016D6                           766          
000016D6  4EB9 00001B14            767          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016DC                           768          
000016DC                           769          ; Put in tabs
000016DC  4EB9 00001AD0            770          Jsr     OP_TAB
000016E2                           771          
000016E2                           772          ; Handoff
000016E2  6000 06F6                773          BRA     EA_ADDA
000016E6                           774  
000016E6                           775  ;------------------------  BTST -----------------------------;
000016E6                           776  
000016E6                           777  OP_BTST
000016E6                           778      ; start string
000016E6                           779      
000016E6  1CFC 0042                780          Move.B  #'B', (A6)+
000016EA  1CFC 0054                781          Move.B  #'T', (A6)+
000016EE  1CFC 0053                782          Move.B  #'S', (A6)+
000016F2  1CFC 0054                783          Move.B  #'T', (A6)+
000016F6                           784          
000016F6                           785      ; Btst has data sizes, but they are implicit based on mode
000016F6                           786          
000016F6                           787      ; Put in tabs
000016F6  4EB9 00001AD0            788          Jsr     OP_TAB
000016FC                           789          
000016FC                           790      ; Hand the function off to John
000016FC  6000 08A8                791          BRA     EA_BTST
00001700                           792  
00001700                           793  
00001700                           794  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
00001700                           795  
00001700                           796  ;------------------------  ORI  -----------------------------;
00001700                           797      
00001700                           798  OP_ORI
00001700                           799      ; start string
00001700                           800      
00001700  1CFC 004F                801          Move.B  #'O', (A6)+
00001704  1CFC 0052                802          Move.B  #'R', (A6)+
00001708  1CFC 0049                803          Move.B  #'I', (A6)+
0000170C                           804          
0000170C                           805      ; Check data type        
0000170C  4EB9 00001AF4            806          Jsr     OP_CHECK_DATA_SIZE
00001712                           807          
00001712                           808      ; Put in tabs
00001712  4EB9 00001AD0            809          Jsr     OP_TAB
00001718                           810          
00001718                           811      ; Hand the function off to John
00001718  6000 0828                812          BRA     EA_IMMEDIATE
0000171C                           813  
0000171C                           814  ;-----------------------  SUBI  -----------------------------;
0000171C                           815  
0000171C                           816  OP_SUBI
0000171C                           817      ; start string
0000171C                           818      
0000171C  1CFC 0053                819          Move.B  #'S', (A6)+
00001720  1CFC 0055                820          Move.B  #'U', (A6)+
00001724  1CFC 0042                821          Move.B  #'B', (A6)+
00001728  1CFC 0049                822          Move.B  #'I', (A6)+
0000172C                           823          
0000172C                           824      ; Check data type        
0000172C  4EB9 00001AF4            825          Jsr     OP_CHECK_DATA_SIZE
00001732                           826          
00001732                           827      ; Put in tabs
00001732  4EB9 00001AD0            828          Jsr     OP_TAB
00001738                           829          
00001738                           830      ; Hand the function off to John
00001738  6000 0808                831          BRA     EA_IMMEDIATE  
0000173C                           832          
0000173C                           833  ;-----------------------  EORI  -----------------------------;        
0000173C                           834          
0000173C                           835  OP_EORI
0000173C                           836      ; start string
0000173C                           837      
0000173C  1CFC 0045                838          Move.B  #'E', (A6)+
00001740  1CFC 004F                839          Move.B  #'O', (A6)+
00001744  1CFC 0052                840          Move.B  #'R', (A6)+
00001748  1CFC 0049                841          Move.B  #'I', (A6)+
0000174C                           842          
0000174C                           843      ; Check data type        
0000174C  4EB9 00001AF4            844          Jsr     OP_CHECK_DATA_SIZE
00001752                           845          
00001752                           846      ; Put in tabs
00001752  4EB9 00001AD0            847          Jsr     OP_TAB
00001758                           848          
00001758                           849      ; Hand the function off to John
00001758  6000 07E8                850          BRA     EA_IMMEDIATE  
0000175C                           851          
0000175C                           852  ;-----------------------  CMPI  -----------------------------;        
0000175C                           853          
0000175C                           854  OP_CMPI
0000175C                           855      ; start string
0000175C                           856      
0000175C  1CFC 0043                857          Move.B  #'C', (A6)+
00001760  1CFC 004D                858          Move.B  #'M', (A6)+
00001764  1CFC 0050                859          Move.B  #'P', (A6)+
00001768  1CFC 0049                860          Move.B  #'I', (A6)+
0000176C                           861          
0000176C                           862      ; Check data type        
0000176C  4EB9 00001AF4            863          Jsr     OP_CHECK_DATA_SIZE
00001772                           864          
00001772                           865      ; Put in tabs
00001772  4EB9 00001AD0            866          Jsr     OP_TAB
00001778                           867          
00001778                           868      ; Hand the function off to John
00001778  6000 07C8                869          BRA     EA_IMMEDIATE  
0000177C                           870          
0000177C                           871  ;-----------------------  LEA  ------------------------------;
0000177C                           872  
0000177C                           873  OP_LEA
0000177C                           874      ; start string
0000177C                           875      
0000177C  1CFC 004C                876          Move.B  #'L', (A6)+
00001780  1CFC 0045                877          Move.B  #'E', (A6)+
00001784  1CFC 0041                878          Move.B  #'A', (A6)+
00001788                           879          
00001788                           880      ; No data size for LEA
00001788                           881          
00001788                           882      ; Put in tabs
00001788  4EB9 00001AD0            883          Jsr     OP_TAB
0000178E                           884          
0000178E                           885      ; Hand the function off to John
0000178E  6000 0718                886          BRA     EA_LEA  
00001792                           887  
00001792                           888  ;-----------------------  NEG  ------------------------------;
00001792                           889  
00001792                           890  OP_NEG
00001792                           891      ; start string
00001792                           892      
00001792  1CFC 004E                893          Move.B  #'N', (A6)+
00001796  1CFC 0045                894          Move.B  #'E', (A6)+
0000179A  1CFC 0047                895          Move.B  #'G', (A6)+
0000179E                           896          
0000179E                           897      ; Data size
0000179E  4EB9 00001AF4            898          Jsr     OP_CHECK_DATA_SIZE
000017A4                           899          
000017A4                           900      ; Put in tabs
000017A4  4EB9 00001AD0            901          Jsr     OP_TAB
000017AA                           902          
000017AA                           903      ; Hand the function off to John
000017AA  6000 0708                904          BRA     EA_NEG  
000017AE                           905  
000017AE                           906      
000017AE                           907  ;-----------------------  NOT  ------------------------------;    
000017AE                           908      
000017AE                           909  OP_NOT
000017AE                           910      ; start string
000017AE                           911      
000017AE  1CFC 004E                912          Move.B  #'N', (A6)+
000017B2  1CFC 004F                913          Move.B  #'O', (A6)+
000017B6  1CFC 0054                914          Move.B  #'T', (A6)+
000017BA                           915          
000017BA                           916      ; Data size
000017BA  4EB9 00001AF4            917          Jsr     OP_CHECK_DATA_SIZE
000017C0                           918          
000017C0                           919      ; Put in tabs
000017C0  4EB9 00001AD0            920          Jsr     OP_TAB
000017C6                           921          
000017C6                           922      ; Hand the function off to John
000017C6  6000 06F4                923          BRA     EA_NOT
000017CA                           924  
000017CA                           925  ;-------------------  MOVE MULITPLE  ------------------------;
000017CA                           926          
000017CA                           927  OP_MOVEM
000017CA                           928      ; Exception checks
000017CA  4EB9 000021EA            929          Jsr     GET7AND8
000017D0  B03C 0001                930          Cmp.B   #%01,D0
000017D4  6600 02F4                931          Bne     OP_SET_BAD_BUFFER
000017D8                           932          
000017D8  4EB9 00002190            933          Jsr     GET3TO5
000017DE  B03C 0000                934          Cmp.B   #%000,D0
000017E2  6700 02E6                935          Beq     OP_SET_BAD_BUFFER
000017E6                           936  
000017E6                           937      ; start string
000017E6                           938      
000017E6  1CFC 004D                939          Move.B  #'M', (A6)+
000017EA  1CFC 004F                940          Move.B  #'O', (A6)+
000017EE  1CFC 0056                941          Move.B  #'V', (A6)+
000017F2  1CFC 0045                942          Move.B  #'E', (A6)+
000017F6  1CFC 004D                943          Move.B  #'M', (A6)+        
000017FA                           944  
000017FA                           945      ; Data size has to be checked manually
000017FA  4EB9 0000180A            946          Jsr     OP_MOVEM_DATA
00001800                           947          
00001800                           948      ; Put in tabs
00001800  4EB9 00001AD0            949          Jsr     OP_TAB
00001806                           950          
00001806                           951      ; Hand the function off to John
00001806  6000 03E4                952          BRA     EA_MOVEM
0000180A                           953          
0000180A                           954  OP_MOVEM_DATA
0000180A                           955      ; get the size bit
0000180A  4EB9 000021D8            956          Jsr     GET6AND7
00001810                           957          
00001810  B03C 0002                958          Cmp.B   #%10,D0
00001814  6700 031A                959          Beq     OP_SET_DATA_WORD
00001818                           960          
00001818  6000 0320                961          Bra     OP_SET_DATA_LONG   
0000181C                           962  
0000181C                           963  OP_RTS
0000181C                           964      ; start string
0000181C                           965      
0000181C  1CFC 0052                966          Move.B  #'R', (A6)+
00001820  1CFC 0054                967          Move.B  #'T', (A6)+
00001824  1CFC 0053                968          Move.B  #'S', (A6)+
00001828                           969  
00001828                           970      ; Put in tabs
00001828  4EB9 00001AD0            971          Jsr     OP_TAB
0000182E                           972  
0000182E                           973      ; Handoff to Blong
0000182E                           974      
0000182E  4E75                     975          Rts
00001830                           976          
00001830                           977  ;-----------------------  JSR  ------------------------------;        
00001830                           978          
00001830                           979  OP_JSR
00001830                           980      ; start string
00001830                           981      
00001830  1CFC 004A                982          Move.B  #'J', (A6)+
00001834  1CFC 0053                983          Move.B  #'S', (A6)+
00001838  1CFC 0052                984          Move.B  #'R', (A6)+
0000183C                           985          
0000183C                           986      ; No data size
0000183C                           987          
0000183C                           988      ; Put in tabs
0000183C  4EB9 00001AD0            989          Jsr     OP_TAB
00001842                           990          
00001842                           991      ; Hand the function off to John
00001842  6000 067C                992          BRA     EA_JSR
00001846                           993  
00001846                           994  ;------------------  BRANCH CONDITIONALS  ------------------------;
00001846                           995  
00001846                           996  OP_BRANCH
00001846                           997      ; start string
00001846                           998      
00001846  1CFC 0042                999          Move.B  #'B', (A6)+
0000184A  1CFC 0052               1000          Move.B  #'R', (A6)+
0000184E  1CFC 0041               1001          Move.B  #'A', (A6)+
00001852                          1002  
00001852                          1003      ; Put in tabs
00001852  4EB9 00001AD0           1004          Jsr     OP_TAB
00001858                          1005  
00001858                          1006      ; Handoff to John
00001858                          1007      
00001858  6000 0796               1008          BRA     EA_BRANCH
0000185C                          1009      
0000185C                          1010  OP_BRA_HIGH
0000185C                          1011      ; start string
0000185C                          1012      
0000185C  1CFC 0042               1013          Move.B  #'B', (A6)+
00001860  1CFC 0048               1014          Move.B  #'H', (A6)+
00001864  1CFC 0049               1015          Move.B  #'I', (A6)+
00001868                          1016  
00001868                          1017      ; Put in tabs
00001868  4EB9 00001AD0           1018          Jsr     OP_TAB
0000186E                          1019  
0000186E                          1020      ; Handoff to John
0000186E                          1021      
0000186E  6000 0780               1022          BRA     EA_BRANCH
00001872                          1023      
00001872                          1024  OP_BRA_LOW
00001872                          1025      ; start string
00001872                          1026      
00001872  1CFC 0042               1027          Move.B  #'B', (A6)+
00001876  1CFC 004C               1028          Move.B  #'L', (A6)+
0000187A  1CFC 0053               1029          Move.B  #'S', (A6)+
0000187E                          1030  
0000187E                          1031      ; Put in tabs
0000187E  4EB9 00001AD0           1032          Jsr     OP_TAB
00001884                          1033  
00001884                          1034      ; Handoff to John
00001884                          1035      
00001884  6000 076A               1036          BRA     EA_BRANCH
00001888                          1037      
00001888                          1038  OP_BRA_CC
00001888                          1039      ; start string
00001888                          1040      
00001888  1CFC 0042               1041          Move.B  #'B', (A6)+
0000188C  1CFC 0043               1042          Move.B  #'C', (A6)+
00001890  1CFC 0043               1043          Move.B  #'C', (A6)+
00001894                          1044  
00001894                          1045      ; Put in tabs
00001894  4EB9 00001AD0           1046          Jsr     OP_TAB
0000189A                          1047  
0000189A                          1048      ; Handoff to John
0000189A                          1049      
0000189A  6000 0754               1050          BRA     EA_BRANCH
0000189E                          1051  
0000189E                          1052  OP_BRA_CS
0000189E                          1053      ; start string
0000189E                          1054      
0000189E  1CFC 0042               1055          Move.B  #'B', (A6)+
000018A2  1CFC 0043               1056          Move.B  #'C', (A6)+
000018A6  1CFC 0053               1057          Move.B  #'S', (A6)+
000018AA                          1058  
000018AA                          1059      ; Put in tabs
000018AA  4EB9 00001AD0           1060          Jsr     OP_TAB
000018B0                          1061  
000018B0                          1062      ; Handoff to John
000018B0                          1063      
000018B0  6000 073E               1064          BRA     EA_BRANCH
000018B4                          1065  
000018B4                          1066  OP_BRA_NE
000018B4                          1067      ; start string
000018B4                          1068      
000018B4  1CFC 0042               1069          Move.B  #'B', (A6)+
000018B8  1CFC 004E               1070          Move.B  #'N', (A6)+
000018BC  1CFC 0045               1071          Move.B  #'E', (A6)+
000018C0                          1072  
000018C0                          1073      ; Put in tabs
000018C0  4EB9 00001AD0           1074          Jsr     OP_TAB
000018C6                          1075  
000018C6                          1076      ; Handoff to John
000018C6                          1077      
000018C6  6000 0728               1078          BRA     EA_BRANCH
000018CA                          1079  
000018CA                          1080  OP_BRA_EQ
000018CA                          1081      ; start string
000018CA                          1082      
000018CA  1CFC 0042               1083          Move.B  #'B', (A6)+
000018CE  1CFC 0045               1084          Move.B  #'E', (A6)+
000018D2  1CFC 0051               1085          Move.B  #'Q', (A6)+
000018D6                          1086  
000018D6                          1087      ; Put in tabs
000018D6  4EB9 00001AD0           1088          Jsr     OP_TAB
000018DC                          1089  
000018DC                          1090      ; Handoff to John
000018DC                          1091      
000018DC  6000 0712               1092          BRA     EA_BRANCH
000018E0                          1093  
000018E0                          1094  OP_BRA_VC
000018E0                          1095      ; start string
000018E0                          1096      
000018E0  1CFC 0042               1097          Move.B  #'B', (A6)+
000018E4  1CFC 0056               1098          Move.B  #'V', (A6)+
000018E8  1CFC 0043               1099          Move.B  #'C', (A6)+
000018EC                          1100  
000018EC                          1101      ; Put in tabs
000018EC  4EB9 00001AD0           1102          Jsr     OP_TAB
000018F2                          1103  
000018F2                          1104      ; Handoff to John
000018F2                          1105      
000018F2  6000 06FC               1106          BRA     EA_BRANCH
000018F6                          1107  
000018F6                          1108  OP_BRA_VS
000018F6                          1109      ; start string
000018F6                          1110      
000018F6  1CFC 0042               1111          Move.B  #'B', (A6)+
000018FA  1CFC 0056               1112          Move.B  #'V', (A6)+
000018FE  1CFC 0053               1113          Move.B  #'S', (A6)+
00001902                          1114  
00001902                          1115      ; Put in tabs
00001902  4EB9 00001AD0           1116          Jsr     OP_TAB
00001908                          1117  
00001908                          1118      ; Handoff to John
00001908                          1119      
00001908  6000 06E6               1120          BRA     EA_BRANCH
0000190C                          1121  
0000190C                          1122  OP_BRA_PL
0000190C                          1123      ; start string
0000190C                          1124      
0000190C  1CFC 0042               1125          Move.B  #'B', (A6)+
00001910  1CFC 0050               1126          Move.B  #'P', (A6)+
00001914  1CFC 004C               1127          Move.B  #'L', (A6)+
00001918                          1128  
00001918                          1129      ; Put in tabs
00001918  4EB9 00001AD0           1130          Jsr     OP_TAB
0000191E                          1131  
0000191E                          1132      ; Handoff to John
0000191E                          1133      
0000191E  6000 06D0               1134          BRA     EA_BRANCH
00001922                          1135  
00001922                          1136  OP_BRA_MI
00001922                          1137      ; start string
00001922                          1138      
00001922  1CFC 0042               1139          Move.B  #'B', (A6)+
00001926  1CFC 004D               1140          Move.B  #'M', (A6)+
0000192A  1CFC 0049               1141          Move.B  #'I', (A6)+
0000192E                          1142  
0000192E                          1143      ; Put in tabs
0000192E  4EB9 00001AD0           1144          Jsr     OP_TAB
00001934                          1145  
00001934                          1146      ; Handoff to John
00001934                          1147      
00001934  6000 06BA               1148          BRA     EA_BRANCH
00001938                          1149  
00001938                          1150  OP_BRA_GE
00001938                          1151      ; start string
00001938                          1152      
00001938  1CFC 0042               1153          Move.B  #'B', (A6)+
0000193C  1CFC 0047               1154          Move.B  #'G', (A6)+
00001940  1CFC 0045               1155          Move.B  #'E', (A6)+
00001944                          1156  
00001944                          1157      ; Put in tabs
00001944  4EB9 00001AD0           1158          Jsr     OP_TAB
0000194A                          1159  
0000194A                          1160      ; Handoff to John
0000194A                          1161      
0000194A  6000 06A4               1162          BRA     EA_BRANCH
0000194E                          1163  
0000194E                          1164  OP_BRA_LT
0000194E                          1165      ; start string
0000194E                          1166      
0000194E  1CFC 0042               1167          Move.B  #'B', (A6)+
00001952  1CFC 004C               1168          Move.B  #'L', (A6)+
00001956  1CFC 0054               1169          Move.B  #'T', (A6)+
0000195A                          1170  
0000195A                          1171      ; Put in tabs
0000195A  4EB9 00001AD0           1172          Jsr     OP_TAB
00001960                          1173  
00001960                          1174      ; Handoff to John
00001960                          1175      
00001960  6000 068E               1176          BRA     EA_BRANCH
00001964                          1177  
00001964                          1178  OP_BRA_GT
00001964                          1179      ; start string
00001964                          1180      
00001964  1CFC 0042               1181          Move.B  #'B', (A6)+
00001968  1CFC 0047               1182          Move.B  #'G', (A6)+
0000196C  1CFC 0054               1183          Move.B  #'T', (A6)+
00001970                          1184  
00001970                          1185      ; Put in tabs
00001970  4EB9 00001AD0           1186          Jsr     OP_TAB
00001976                          1187  
00001976                          1188      ; Handoff to John
00001976                          1189      
00001976  6000 0678               1190          BRA     EA_BRANCH
0000197A                          1191  
0000197A                          1192  OP_BRA_LE
0000197A                          1193      ; start string
0000197A                          1194      
0000197A  1CFC 0042               1195          Move.B  #'B', (A6)+
0000197E  1CFC 004C               1196          Move.B  #'L', (A6)+
00001982  1CFC 0045               1197          Move.B  #'E', (A6)+
00001986                          1198  
00001986                          1199      ; Put in tabs
00001986  4EB9 00001AD0           1200          Jsr     OP_TAB
0000198C                          1201  
0000198C                          1202      ; Handoff to John
0000198C                          1203      
0000198C  6000 0662               1204          BRA     EA_BRANCH
00001990                          1205  
00001990                          1206  ;------------------  Multiply Singed ----------------------;    
00001990                          1207  
00001990                          1208  OP_MULS
00001990                          1209      ; MULS only has one format, and that data size of word, so I don't need
00001990                          1210      ; a very intelligent system
00001990                          1211      
00001990  1CFC 004D               1212          Move.B  #'M', (A6)+
00001994  1CFC 0055               1213          Move.B  #'U', (A6)+
00001998  1CFC 004C               1214          Move.B  #'L', (A6)+
0000199C  1CFC 0053               1215          Move.B  #'S', (A6)+
000019A0  1CFC 002E               1216          Move.B  #'.', (A6)+
000019A4  1CFC 0057               1217          Move.B  #'W', (A6)+
000019A8                          1218  
000019A8                          1219      ; Put in tabs
000019A8  4EB9 00001AD0           1220          Jsr     OP_TAB       
000019AE                          1221      
000019AE                          1222      ; Give to john
000019AE                          1223      
000019AE  6000 05CA               1224          BRA     EA_MULS
000019B2                          1225  
000019B2                          1226      
000019B2                          1227  ;-----------------------  AND  ------------------------------;    
000019B2                          1228      
000019B2                          1229  OP_AND
000019B2                          1230      ; start string
000019B2                          1231      
000019B2  1CFC 0041               1232          Move.B  #'A', (A6)+
000019B6  1CFC 004E               1233          Move.B  #'N', (A6)+
000019BA  1CFC 0044               1234          Move.B  #'D', (A6)+
000019BE                          1235  
000019BE                          1236      ; No Address Version
000019BE                          1237          
000019BE                          1238      ; Check data size
000019BE  4EB9 00001AF4           1239          Jsr     OP_CHECK_DATA_SIZE
000019C4                          1240          
000019C4                          1241      ; Put in tabs
000019C4  4EB9 00001AD0           1242          Jsr     OP_TAB
000019CA                          1243          
000019CA  6000 04E0               1244      BRA     EA_AND
000019CE                          1245  
000019CE                          1246      
000019CE                          1247  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
000019CE                          1248          
000019CE                          1249  OP_AS_REG
000019CE                          1250      ; start string
000019CE                          1251      
000019CE  1CFC 0041               1252          Move.B  #'A', (A6)+
000019D2  1CFC 0053               1253          Move.B  #'S', (A6)+
000019D6                          1254          
000019D6                          1255      ; Determine Left or right shift
000019D6                          1256      
000019D6  4EB9 00001B44           1257          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019DC                          1258          
000019DC                          1259      ; Determine data size
000019DC                          1260      
000019DC  4EB9 00001AF4           1261          Jsr     OP_CHECK_DATA_SIZE
000019E2                          1262         
000019E2                          1263      ; Tab out function
000019E2                          1264      
000019E2  4EB9 00001AD0           1265          Jsr     OP_TAB
000019E8                          1266         
000019E8                          1267      ; Handoff function
000019E8  6000 04DA               1268          BRA     EA_BIT_SHIFT
000019EC                          1269          
000019EC                          1270  OP_AS_MEM
000019EC                          1271      
000019EC                          1272      ; start string
000019EC                          1273      
000019EC  1CFC 0041               1274          Move.B  #'A', (A6)+
000019F0  1CFC 0053               1275          Move.B  #'S', (A6)+
000019F4                          1276          
000019F4                          1277      ; Determine Left or right shift
000019F4                          1278      
000019F4  4EB9 00001B44           1279          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019FA                          1280         
000019FA                          1281      ; Tab out function
000019FA                          1282      
000019FA  4EB9 00001AD0           1283          Jsr     OP_TAB
00001A00                          1284         
00001A00                          1285      ; Handoff function
00001A00  6000 04C2               1286          BRA     EA_BIT_SHIFT
00001A04                          1287  
00001A04                          1288  
00001A04                          1289  ;-------------------  LOGICAL SHIFT  ------------------------;
00001A04                          1290  
00001A04                          1291  OP_LS_REG
00001A04                          1292      ; start string
00001A04                          1293      
00001A04  1CFC 004C               1294          Move.B  #'L', (A6)+
00001A08  1CFC 0053               1295          Move.B  #'S', (A6)+
00001A0C                          1296          
00001A0C                          1297      ; Determine Left or right shift
00001A0C                          1298      
00001A0C  4EB9 00001B44           1299          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A12                          1300          
00001A12                          1301      ; Determine data size
00001A12                          1302      
00001A12  4EB9 00001AF4           1303          Jsr     OP_CHECK_DATA_SIZE
00001A18                          1304         
00001A18                          1305      ; Tab out function
00001A18                          1306      
00001A18  4EB9 00001AD0           1307          Jsr     OP_TAB
00001A1E                          1308         
00001A1E                          1309      ; Handoff function
00001A1E  6000 04A4               1310          BRA     EA_BIT_SHIFT
00001A22                          1311  
00001A22                          1312      
00001A22                          1313  OP_LS_MEM    
00001A22                          1314  
00001A22                          1315      ; start string
00001A22                          1316      
00001A22  1CFC 004C               1317          Move.B  #'L', (A6)+
00001A26  1CFC 0053               1318          Move.B  #'S', (A6)+
00001A2A                          1319          
00001A2A                          1320      ; Determine Left or right shift
00001A2A                          1321      
00001A2A  4EB9 00001B44           1322          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A30                          1323         
00001A30                          1324      ; Tab out function
00001A30                          1325      
00001A30  4EB9 00001AD0           1326          Jsr     OP_TAB
00001A36                          1327         
00001A36                          1328      ; Handoff function
00001A36  6000 048C               1329          BRA     EA_BIT_SHIFT
00001A3A                          1330  
00001A3A                          1331  
00001A3A                          1332  ;----------------------  ROTATE  ----------------------------;
00001A3A                          1333  
00001A3A                          1334  OP_RO_REG
00001A3A                          1335      ; start string
00001A3A                          1336      
00001A3A  1CFC 0052               1337          Move.B  #'R', (A6)+
00001A3E  1CFC 004F               1338          Move.B  #'O', (A6)+
00001A42                          1339          
00001A42                          1340      ; Determine Left or right shift
00001A42                          1341      
00001A42  4EB9 00001B44           1342          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A48                          1343          
00001A48                          1344      ; Determine data size
00001A48                          1345      
00001A48  4EB9 00001AF4           1346          Jsr     OP_CHECK_DATA_SIZE
00001A4E                          1347         
00001A4E                          1348      ; Tab out function
00001A4E                          1349      
00001A4E  4EB9 00001AD0           1350          Jsr     OP_TAB
00001A54                          1351         
00001A54                          1352      ; Handoff function
00001A54  6000 046E               1353          BRA     EA_BIT_SHIFT
00001A58                          1354  
00001A58                          1355      
00001A58                          1356  OP_RO_MEM
00001A58                          1357  
00001A58                          1358      ; start string
00001A58                          1359      
00001A58  1CFC 0052               1360          Move.B  #'R', (A6)+
00001A5C  1CFC 004F               1361          Move.B  #'O', (A6)+
00001A60                          1362          
00001A60                          1363      ; Determine Left or right shift
00001A60                          1364      
00001A60  4EB9 00001B44           1365          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A66                          1366         
00001A66                          1367      ; Tab out function
00001A66                          1368      
00001A66  4EB9 00001AD0           1369          Jsr     OP_TAB
00001A6C                          1370         
00001A6C                          1371      ; Handoff function
00001A6C  6000 0456               1372          BRA     EA_BIT_SHIFT
00001A70                          1373  
00001A70                          1374  
00001A70                          1375  ;-----------------------  CMP  ------------------------------;
00001A70                          1376  
00001A70                          1377  OP_Cmp
00001A70                          1378      ; start string
00001A70                          1379      
00001A70  1CFC 0043               1380          Move.B  #'C', (A6)+
00001A74  1CFC 004D               1381          Move.B  #'M', (A6)+
00001A78  1CFC 0050               1382          Move.B  #'P', (A6)+
00001A7C                          1383  
00001A7C                          1384      ; Check for address version
00001A7C                          1385          
00001A7C  4EB9 000021D8           1386          Jsr     GET6AND7
00001A82  B03C 0003               1387          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001A86                          1388          
00001A86  6700 0012               1389          Beq     OP_CMP_ADDR
00001A8A                          1390          
00001A8A                          1391      ; Check which of the two versions is it?
00001A8A                          1392  
00001A8A  4EB9 00001AF4           1393          Jsr     OP_CHECK_DATA_SIZE
00001A90                          1394          
00001A90                          1395      ; Put in tabs
00001A90  4EB9 00001AD0           1396          Jsr     OP_TAB
00001A96                          1397  
00001A96                          1398      ; Handoff
00001A96  6000 040C               1399          BRA     EA_CMP
00001A9A                          1400          
00001A9A                          1401  OP_CMP_ADDR
00001A9A                          1402          
00001A9A  1CFC 0041               1403          Move.B  #'A',(A6)+ ; add to the string
00001A9E                          1404      
00001A9E                          1405      ; Find data size
00001A9E                          1406          
00001A9E  4EB9 00001B14           1407          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001AA4                          1408          
00001AA4                          1409      ; Put in tabs
00001AA4  4EB9 00001AD0           1410          Jsr     OP_TAB
00001AAA                          1411  
00001AAA                          1412      ; Handoff
00001AAA  6000 03F8               1413          BRA     EA_CMP
00001AAE                          1414      
00001AAE                          1415  ;-----------------------  EOR  ------------------------------;
00001AAE                          1416  
00001AAE                          1417  OP_EOR
00001AAE                          1418      ; start string
00001AAE                          1419      
00001AAE  1CFC 0045               1420          Move.B  #'E', (A6)+
00001AB2  1CFC 004F               1421          Move.B  #'O', (A6)+
00001AB6  1CFC 0052               1422          Move.B  #'R', (A6)+
00001ABA                          1423  
00001ABA                          1424      ; No Address Version
00001ABA                          1425          
00001ABA                          1426      ; Check data size
00001ABA  4EB9 00001AF4           1427          Jsr     OP_CHECK_DATA_SIZE
00001AC0                          1428          
00001AC0                          1429      ; Put in tabs
00001AC0  4EB9 00001AD0           1430          Jsr     OP_TAB
00001AC6                          1431          
00001AC6  6000 03E8               1432      BRA     EA_EOR
00001ACA                          1433  
00001ACA                          1434  ;---------------- Misc Op-Code Sub Routines ----------------;
00001ACA                          1435  ; Set Bad Buffer
00001ACA                          1436  ; Sub Routine that sets the Bad buffer bit and returns
00001ACA                          1437  ;
00001ACA                          1438  ; REGISTERS USED: D7
00001ACA                          1439  
00001ACA                          1440  OP_SET_BAD_BUFFER
00001ACA  1E3C 0001               1441      Move.B  #%1, D7
00001ACE  4E75                    1442      Rts
00001AD0                          1443  
00001AD0                          1444  ;-------------------------- Tab ----------------------------;
00001AD0                          1445  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001AD0                          1446  ; taking into account the current size of the string
00001AD0                          1447  
00001AD0                          1448  ; REGISTERS USED: A6, A5(const), D0
00001AD0                          1449  
00001AD0                          1450  OP_TAB
00001AD0  220D                    1451      Move.L      A5,D1   ; Move the start of string to a Dn
00001AD2  928E                    1452      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001AD4  0681 00000014           1453      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001ADA                          1454      
00001ADA                          1455      ; Loop till you have enough spaces
00001ADA                          1456  LOOP_TAB
00001ADA  1CFC 0020               1457      Move.B      #' ',(A6)+  ; Add a space to the string
00001ADE  5301                    1458      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001AE0  66F8                    1459      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001AE2                          1460      
00001AE2  4E75                    1461      Rts
00001AE4                          1462  
00001AE4                          1463  ;--------------------- Address Version ---------------------;
00001AE4                          1464  ; This Sub Routine Checks if the Src address is an An and
00001AE4                          1465  ; Adds an A to the sring if it is, to represent that it is
00001AE4                          1466  ; Is the Address version of the Op-code. This function assumes
00001AE4                          1467  ; That D0 will have the mode for the Destination in it.
00001AE4                          1468  
00001AE4                          1469  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001AE4                          1470  ;                 A6 (Add string input)
00001AE4                          1471  
00001AE4                          1472  OP_CHECK_ADDRESS_VERSION
00001AE4                          1473  
00001AE4  B03C 0001               1474      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001AE8  6700 0004               1475      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001AEC                          1476      
00001AEC  4E75                    1477      Rts     ; Otherwise go back without changing anything
00001AEE                          1478  
00001AEE                          1479  OP_ADD_ADDRESS_VERSION
00001AEE  1CFC 0041               1480      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001AF2                          1481      
00001AF2  4E75                    1482      Rts     ; Finish up and go back
00001AF4                          1483      
00001AF4                          1484  ;--------------------- Data Size Check ---------------------;
00001AF4                          1485  ; A set of sub routines to check the size of the data and add it
00001AF4                          1486  ; To the string.
00001AF4                          1487  
00001AF4                          1488  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001AF4                          1489  ;                 A6(adds letters)    
00001AF4                          1490  OP_CHECK_DATA_SIZE
00001AF4  4EB9 000021D8           1491      Jsr     GET6AND7
00001AFA                          1492      
00001AFA  B03C 0000               1493      Cmp.B    #%00, D0    ; Byte Size
00001AFE  6700 0026               1494      Beq     OP_SET_DATA_BYTE
00001B02                          1495      
00001B02  B03C 0001               1496      Cmp.B    #%01, D0    ; Word Size
00001B06  6700 0028               1497      Beq     OP_SET_DATA_WORD
00001B0A                          1498      
00001B0A  B03C 0002               1499      Cmp.B    #%10, D0    ; Long Size
00001B0E  6700 002A               1500      Beq     OP_SET_DATA_LONG
00001B12                          1501      
00001B12                          1502      ; If it was not one of those three types, it is not a legal operation
00001B12  60B6                    1503      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001B14                          1504  
00001B14                          1505  OP_CHECK_DATA_SIZE_ADDR
00001B14  4EB9 000021B4           1506      Jsr     GETBIT8
00001B1A                          1507      
00001B1A  B03C 0000               1508      Cmp.B   #%0, D0     ; Word Size
00001B1E  6700 0010               1509      Beq     OP_SET_DATA_WORD
00001B22                          1510                          ; Otherwise its Long Size
00001B22  6000 0016               1511      Bra     OP_SET_DATA_LONG
00001B26                          1512  
00001B26                          1513  OP_SET_DATA_BYTE
00001B26                          1514  
00001B26  1CFC 002E               1515      Move.B  #'.',(A6)+  ; Add Letters
00001B2A  1CFC 0042               1516      Move.B  #'B',(A6)+
00001B2E                          1517      
00001B2E  4E75                    1518      Rts
00001B30                          1519  
00001B30                          1520  OP_SET_DATA_WORD
00001B30                          1521  
00001B30  1CFC 002E               1522      Move.B  #'.',(A6)+  ; Add Letters
00001B34  1CFC 0057               1523      Move.B  #'W',(A6)+
00001B38                          1524  
00001B38  4E75                    1525      Rts
00001B3A                          1526  
00001B3A                          1527  OP_SET_DATA_LONG
00001B3A                          1528  
00001B3A  1CFC 002E               1529      Move.B  #'.',(A6)+  ; Add Letters
00001B3E  1CFC 004C               1530      Move.B  #'L',(A6)+
00001B42                          1531  
00001B42  4E75                    1532      Rts
00001B44                          1533  
00001B44                          1534  ;------------------- Bit Shift Direction -------------------;
00001B44                          1535  ; This checks bit 8 to see what direction the shift is going
00001B44                          1536  
00001B44                          1537  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B44                          1538  
00001B44                          1539  OP_SHIFT_DIRECTION
00001B44  4EB9 000021B4           1540      Jsr     GETBIT8 ; Get the shift direction bit
00001B4A                          1541      
00001B4A  B03C 0000               1542      Cmp.B   #%0,D0  ; 0 is Right
00001B4E  6700 0006               1543      Beq     OP_SHIFT_RIGHT
00001B52                          1544  
00001B52  6000 0008               1545      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001B56                          1546  
00001B56                          1547  OP_SHIFT_RIGHT
00001B56                          1548      ; Add the character and return
00001B56  1CFC 0052               1549      Move.B  #'R',(A6)+
00001B5A                          1550  
00001B5A  4E75                    1551      Rts    
00001B5C                          1552  
00001B5C                          1553  OP_SHIFT_LEFT
00001B5C                          1554      ; Add the character and return
00001B5C  1CFC 004C               1555      Move.B  #'L',(A6)+
00001B60                          1556  
00001B60  4E75                    1557      Rts
00001B62                          1558      
00001B62                          1559  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001B62                          1560  ;-------------------- Effective Address Sub Routines --------------------;
00001B62                          1561  ; These subroutines look for the correct effective address
00001B62                          1562  ; in each OP code.
00001B62                          1563  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001B62                          1564  
00001B62                          1565  ;=============================================;
00001B62                          1566  ;--------------- EA Move/MoveA ---------------;
00001B62                          1567  ;=============================================;
00001B62                          1568  EA_MOVE
00001B62  4EB9 00001B74           1569          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001B68  1CFC 002C               1570          Move.B  #',', (A6)+             ; Add a comma
00001B6C  4EB9 00001B84           1571          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001B72                          1572          
00001B72  4E75                    1573          RTS
00001B74                          1574                  
00001B74                          1575  EA_MOVE_SOURCE  ; Find out Move's source
00001B74  4EB9 000020F6           1576          Jsr     EA_0TO5                 ; Get the EA
00001B7A                          1577          
00001B7A  B03C 0004               1578          Cmp.B   #Imm_Reg, D0            ; #<data>
00001B7E  6700 004C               1579          Beq     EA_MOVE_SIZE
00001B82                          1580          
00001B82  4E75                    1581          Rts
00001B84                          1582          
00001B84                          1583  EA_MOVE_DEST    ; Find out Move's destination
00001B84  4EB9 0000217E           1584          Jsr     GET6TO8                 ; Get destination mode
00001B8A  1A00                    1585          Move.B  D0, D5                  ; Move destination mode to D5
00001B8C  4EB9 0000216C           1586          Jsr     GET9TO11                ; Get destination register
00001B92                          1587          
00001B92                          1588          ; List of valid effective addresses
00001B92  BA3C 0000               1589          Cmp.B   #Dn_Mode, D5            ; Dn
00001B96  6700 0482               1590          Beq     EA_DN
00001B9A                          1591          
00001B9A  BA3C 0001               1592          Cmp.B   #An_Mode, D5            ; An
00001B9E  6700 0486               1593          Beq     EA_AN
00001BA2                          1594          
00001BA2  BA3C 0002               1595          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001BA6  6700 048A               1596          Beq     EA_AN_PNTR
00001BAA                          1597          
00001BAA  BA3C 0003               1598          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001BAE  6700 0496               1599          Beq     EA_AN_INC
00001BB2                          1600          
00001BB2  BA3C 0004               1601          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001BB6  6700 04A6               1602          Beq     EA_AN_DEC
00001BBA                          1603          
00001BBA                          1604          ; Comparing registers at this point because modes are the same
00001BBA  B03C 0000               1605          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001BBE  6700 04B6               1606          Beq     EA_WORD_ADDR
00001BC2                          1607          
00001BC2  B03C 0001               1608          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001BC6  6700 04F2               1609          Beq     EA_LONG_ADDR
00001BCA                          1610          
00001BCA  4E75                    1611          Rts
00001BCC                          1612          
00001BCC                          1613  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001BCC  4EB9 00002148           1614          Jsr     GET12TO13               ; Get Move size
00001BD2                          1615  
00001BD2  B03C 0001               1616          Cmp.B   #%01, D0                ; Byte
00001BD6  6700 04EE               1617          Beq     EA_IMM_BYTE
00001BDA                          1618  
00001BDA  B03C 0003               1619          Cmp.B   #%11, D0                ; Word
00001BDE  6700 04F6               1620          Beq     EA_IMM_WORD
00001BE2                          1621          
00001BE2  B03C 0002               1622          Cmp.B   #%10, D0                ; Long
00001BE6  6700 04FE               1623          Beq     EA_IMM_LONG
00001BEA                          1624          
00001BEA  4E75                    1625          Rts
00001BEC                          1626          
00001BEC                          1627  ;=================================================================;
00001BEC                          1628  ;---------------------------- EA MoveM ---------------------------;
00001BEC                          1629  ; D2 stores the counter for the number of consecutive ones in the
00001BEC                          1630  ; register list mask
00001BEC                          1631  ;
00001BEC                          1632  ; D3 stores a 1 if the register being added is the first register, 
00001BEC                          1633  ; or 0 if the register is not the first register being added
00001BEC                          1634  ;
00001BEC                          1635  ; D5 stores the register list mask
00001BEC                          1636  ;
00001BEC                          1637  ; D6 stores any expansion words
00001BEC                          1638  ;
00001BEC                          1639  ; D7 stores the loop counter
00001BEC                          1640  ;=================================================================;
00001BEC                          1641  EA_MOVEM    ; Determines the EA for MoveM
00001BEC  48E7 3F00               1642          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001BF0                          1643          
00001BF0  4282                    1644          Clr.L   D2                      ; Clear out the data registers
00001BF2  4283                    1645          Clr.L   D3
00001BF4  4285                    1646          Clr.L   D5
00001BF6  4286                    1647          Clr.L   D6
00001BF8  4287                    1648          Clr.L   D7
00001BFA                          1649          
00001BFA  5203                    1650          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001BFC  3A1B                    1651          Move.W  (A3)+, D5               ; Store the register list mask
00001BFE                          1652          
00001BFE  4EB9 0000222E           1653          Jsr     GETBIT10                ; Get the direction bit
00001C04                          1654          
00001C04  B03C 0000               1655          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001C08  6700 0008               1656          Beq     EA_MOVEM_REG_TO_MEM
00001C0C                          1657          
00001C0C  4EF9 00001C28           1658          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001C12                          1659          
00001C12                          1660  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001C12  4EB9 00001C44           1661          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C18  1CFC 002C               1662          Move.B  #',', (A6)+             ; Add a comma
00001C1C  4EB9 000020F6           1663          Jsr     EA_0TO5                 ; Get the EA
00001C22                          1664          
00001C22  4CDF 00FC               1665          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C26                          1666                  
00001C26  4E75                    1667          RTS
00001C28                          1668          
00001C28                          1669  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C28  3E05                    1670          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C2A  4EB9 000020F6           1671          Jsr     EA_0TO5                 ; Get the EA
00001C30  1CFC 002C               1672          Move.B  #',', (A6)+             ; Add a comma
00001C34  3A07                    1673          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C36  4287                    1674          Clr.L   D7                      ; Clear D7
00001C38  4EB9 00001C44           1675          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C3E                          1676          
00001C3E  4CDF 00FC               1677          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C42                          1678                  
00001C42  4E75                    1679          RTS
00001C44                          1680                  
00001C44                          1681  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C44  BE3C 0010               1682          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C48  6C00 0016               1683          Bge     EA_MOVEM_LIST_END
00001C4C                          1684  
00001C4C  4EB9 00002190           1685          Jsr     GET3TO5                 ; Get the EA mode
00001C52                          1686          
00001C52  B03C 0004               1687          Cmp.B   #%100, D0               ; Predecrement mode
00001C56  6700 000A               1688          Beq     EA_MOVEM_PRE_DEC
00001C5A                          1689          
00001C5A  4EF9 00001C6C           1690          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001C60                          1691          
00001C60                          1692  EA_MOVEM_LIST_END   ; Ends the list loop
00001C60  4E75                    1693          Rts
00001C62                          1694          
00001C62                          1695  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001C62  E35D                    1696          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001C64                          1697          
00001C64  6500 0010               1698          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C68                          1699          
00001C68  6400 002C               1700          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C6C                          1701          
00001C6C                          1702  EA_MOVEM_POST_INC   ; Post increment mode
00001C6C  E25D                    1703          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001C6E                          1704          
00001C6E  6500 0006               1705          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C72                          1706          
00001C72  6400 0022               1707          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C76                          1708          
00001C76                          1709  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001C76  B63C 0001               1710          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001C7A  6700 002A               1711          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001C7E                          1712          
00001C7E  B43C 0000               1713          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001C82  6700 0032               1714          Beq     EA_MOVEM_ADD_SINGLE_REG
00001C86                          1715          
00001C86  5207                    1716          Add.B   #1, D7                  ; Increment the loop counter
00001C88  5202                    1717          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C8A                          1718          
00001C8A  BE3C 0010               1719          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001C8E  6700 0038               1720          Beq     EA_MOVEM_LAST_REG
00001C92                          1721          
00001C92  4EF8 1C44               1722          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C96                          1723          
00001C96                          1724  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001C96  B43C 0001               1725          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001C9A  6E00 003A               1726          Bgt     EA_MOVEM_ADD_LAST_REG
00001C9E                          1727          
00001C9E  5207                    1728          Add.B   #1, D7                  ; Increment the loop counter
00001CA0                          1729          
00001CA0  4282                    1730          Clr.L   D2                      ; Clear the counter for consecutive ones
00001CA2                          1731          
00001CA2  4EF8 1C44               1732          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CA6                          1733  
00001CA6                          1734  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001CA6  4EB9 00001CEA           1735          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001CAC                          1736          
00001CAC  4283                    1737          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001CAE                          1738          
00001CAE  5207                    1739          Add.B   #1, D7                  ; Increment the loop counter
00001CB0  5202                    1740          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CB2                          1741          
00001CB2  4EF8 1C44               1742          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CB6                          1743          
00001CB6                          1744  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001CB6  1CFC 002F               1745          Move.B  #'/', (A6)+
00001CBA                          1746          
00001CBA  4EB9 00001CEA           1747          Jsr     EA_MOVEM_REG            ; Add a register
00001CC0                          1748          
00001CC0  5207                    1749          Add.B   #1, D7                  ; Increment the loop counter 
00001CC2  5202                    1750          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CC4                          1751          
00001CC4  4EF8 1C44               1752          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CC8                          1753          
00001CC8                          1754  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001CC8  B43C 0001               1755          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001CCC  6E00 0008               1756          Bgt     EA_MOVEM_ADD_LAST_REG
00001CD0                          1757          
00001CD0  5207                    1758          Add.B   #1, D7                  ; Increment the loop counter
00001CD2                          1759          
00001CD2  4EF8 1C44               1760          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CD6                          1761          
00001CD6                          1762  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001CD6  1CFC 002D               1763          Move.B  #'-', (A6)+
00001CDA                          1764          
00001CDA  5307                    1765          Sub.B   #1, D7                  ; Move back to the previous register
00001CDC                          1766          
00001CDC  4EB9 00001CEA           1767          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001CE2                          1768          
00001CE2  5407                    1769          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001CE4                          1770          
00001CE4  4282                    1771          Clr.L   D2                      ; Clear the consecutive ones counter
00001CE6                          1772          
00001CE6  4EF8 1C44               1773          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CEA                          1774          
00001CEA                          1775  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001CEA  4280                    1776          Clr.L   D0                      ; Clear D0
00001CEC  BE3C 0000               1777          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001CF0  6700 0328               1778          Beq     EA_DN
00001CF4                          1779          
00001CF4  103C 0001               1780          Move.B  #1, D0                  ; Move a 1 into D0
00001CF8  BE3C 0001               1781          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001CFC  6700 031C               1782          Beq     EA_DN
00001D00                          1783          
00001D00  103C 0002               1784          Move.B  #2, D0
00001D04  BE3C 0002               1785          Cmp.B   #2, D7
00001D08  6700 0310               1786          Beq     EA_DN
00001D0C                          1787  
00001D0C  103C 0003               1788          Move.B  #3, D0
00001D10  BE3C 0003               1789          Cmp.B   #3, D7
00001D14  6700 0304               1790          Beq     EA_DN
00001D18                          1791  
00001D18  103C 0004               1792          Move.B  #4, D0
00001D1C  BE3C 0004               1793          Cmp.B   #4, D7
00001D20  6700 02F8               1794          Beq     EA_DN
00001D24                          1795  
00001D24  103C 0005               1796          Move.B  #5, D0
00001D28  BE3C 0005               1797          Cmp.B   #5, D7
00001D2C  6700 02EC               1798          Beq     EA_DN
00001D30                          1799  
00001D30  103C 0006               1800          Move.B  #6, D0
00001D34  BE3C 0006               1801          Cmp.B   #6, D7
00001D38  6700 02E0               1802          Beq     EA_DN
00001D3C                          1803          
00001D3C  103C 0007               1804          Move.B  #7, D0
00001D40  BE3C 0007               1805          Cmp.B   #7, D7
00001D44  6700 02D4               1806          Beq     EA_DN
00001D48                          1807          
00001D48  4280                    1808          Clr.L   D0
00001D4A  BE3C 0008               1809          Cmp.B   #8, D7
00001D4E  6700 02D6               1810          Beq     EA_AN
00001D52                          1811  
00001D52  103C 0001               1812          Move.B  #1, D0
00001D56  BE3C 0009               1813          Cmp.B   #9, D7
00001D5A  6700 02CA               1814          Beq     EA_AN
00001D5E                          1815  
00001D5E  103C 0002               1816          Move.B  #2, D0
00001D62  BE3C 000A               1817          Cmp.B   #10, D7
00001D66  6700 02BE               1818          Beq     EA_AN
00001D6A                          1819          
00001D6A  103C 0003               1820          Move.B  #3, D0
00001D6E  BE3C 000B               1821          Cmp.B   #11, D7
00001D72  6700 02B2               1822          Beq     EA_AN
00001D76                          1823          
00001D76  103C 0004               1824          Move.B  #4, D0
00001D7A  BE3C 000C               1825          Cmp.B   #12, D7
00001D7E  6700 02A6               1826          Beq     EA_AN
00001D82                          1827          
00001D82  103C 0005               1828          Move.B  #5, D0
00001D86  BE3C 000D               1829          Cmp.B   #13, D7
00001D8A  6700 029A               1830          Beq     EA_AN
00001D8E                          1831          
00001D8E  103C 0006               1832          Move.B  #6, D0
00001D92  BE3C 000E               1833          Cmp.B   #14, D7
00001D96  6700 028E               1834          Beq     EA_AN
00001D9A                          1835          
00001D9A  103C 0007               1836          Move.B  #7, D0
00001D9E  BE3C 000F               1837          Cmp.B   #15, D7
00001DA2  6700 0282               1838          Beq     EA_AN
00001DA6                          1839  
00001DA6                          1840  ;===========================================;        
00001DA6                          1841  ;--------------- EA Add/AddA ---------------;
00001DA6                          1842  ;===========================================;       
00001DA6                          1843  EA_ADD  ; Figures out the EA for Add        
00001DA6  4EB9 0000217E           1844          Jsr     GET6TO8                 ; Isolate the Op mode
00001DAC                          1845          
00001DAC  B03C 0003               1846          Cmp.B   #%011, D0               ; Compare to AddA word
00001DB0  6700 0028               1847          Beq     EA_ADDA
00001DB4                          1848          
00001DB4  B03C 0007               1849          Cmp.B   #%111, D0               ; Compare to AddA long
00001DB8  6700 0020               1850          Beq     EA_ADDA
00001DBC                          1851  
00001DBC  B03C 0000               1852          Cmp.B   #%000, D0               ; Compare to Add source byte
00001DC0  6700 0030               1853          Beq     EA_ADD_OPMODE_SOURCE
00001DC4                          1854          
00001DC4  B03C 0001               1855          Cmp.B   #%001, D0               ; Compare to Add source word
00001DC8  6700 0028               1856          Beq     EA_ADD_OPMODE_SOURCE
00001DCC                          1857          
00001DCC  B03C 0002               1858          Cmp.B   #%010, D0               ; Compare to Add source Long
00001DD0  6700 0020               1859          Beq     EA_ADD_OPMODE_SOURCE
00001DD4                          1860          
00001DD4  4EF9 00001E0A           1861          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001DDA                          1862          
00001DDA                          1863  EA_ADDA ; Figures out the EA for AddA
00001DDA  4EB9 00001E22           1864          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DE0  1CFC 002C               1865          Move.B  #',', (A6)+             ; Add a comma
00001DE4  4EB9 0000216C           1866          Jsr     GET9TO11                ; Get the register
00001DEA  4EB9 00002026           1867          Jsr     EA_AN                   ; Add An
00001DF0                          1868          
00001DF0  4E75                    1869          RTS
00001DF2                          1870          
00001DF2                          1871  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001DF2  4EB9 00001E22           1872          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DF8  1CFC 002C               1873          Move.B  #',', (A6)+             ; Add a comma
00001DFC  4EB9 0000216C           1874          Jsr     GET9TO11                ; Get the register
00001E02  4EB9 0000201A           1875          Jsr     EA_DN                   ; Add Dn
00001E08                          1876          
00001E08  4E75                    1877          RTS
00001E0A                          1878          
00001E0A                          1879  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001E0A  4EB9 0000216C           1880          Jsr     GET9TO11                ; Get the register
00001E10  4EB9 0000201A           1881          Jsr     EA_DN                   ; Add Dn
00001E16  1CFC 002C               1882          Move.B  #',', (A6)+             ; Add a comma
00001E1A  4EB9 00001E22           1883          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001E20                          1884          
00001E20  4E75                    1885          RTS
00001E22                          1886          
00001E22                          1887  EA_ADD_ADDRESS
00001E22  4EB9 000020F6           1888          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E28                          1889          
00001E28  B03C 0004               1890          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E2C  6700 0004               1891          Beq     EA_ADD_SIZE
00001E30                          1892  
00001E30  4E75                    1893          Rts
00001E32                          1894          
00001E32                          1895  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E32  4EB9 0000217E           1896          Jsr     GET6TO8                 ; Get Move size
00001E38                          1897  
00001E38  B03C 0000               1898          Cmp.B   #%000, D0               ; Byte
00001E3C  6700 0288               1899          Beq     EA_IMM_BYTE
00001E40                          1900  
00001E40  B03C 0001               1901          Cmp.B   #%001, D0               ; Word
00001E44  6700 0290               1902          Beq     EA_IMM_WORD
00001E48                          1903          
00001E48  B03C 0002               1904          Cmp.B   #%010, D0               ; Long
00001E4C  6700 0298               1905          Beq     EA_IMM_LONG
00001E50                          1906          
00001E50  B03C 0003               1907          Cmp.B   #%011, D0               ; AddA Word
00001E54  6700 0280               1908          Beq     EA_IMM_WORD
00001E58                          1909     
00001E58  B03C 0007               1910          Cmp.B   #%111, D0               ; AddA Long
00001E5C  6700 0288               1911          Beq     EA_IMM_LONG
00001E60                          1912          
00001E60  4E75                    1913          Rts
00001E62                          1914          
00001E62                          1915  ;=================================================;        
00001E62                          1916  ;-------------------- EA AddQ --------------------;
00001E62                          1917  ;=================================================;
00001E62                          1918  EA_ADDQ ; Figures out the EA for AddQ
00001E62  4EB9 00001E74           1919          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001E68  1CFC 002C               1920          Move.B  #',', (A6)+             ; Add a comma
00001E6C  4EB9 00001E98           1921          Jsr     EA_ADDQ_DEST            ; Add the destination
00001E72                          1922          
00001E72  4E75                    1923          Rts
00001E74                          1924  
00001E74                          1925  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001E74  4EB9 0000216C           1926          Jsr     GET9TO11                ; Isolate the count/register bits
00001E7A                          1927          
00001E7A  B03C 0000               1928          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001E7E  6E00 000C               1929          Bgt     EA_ADDQ_IMMEDIATE
00001E82                          1930          
00001E82  103C 0008               1931          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001E86                          1932          
00001E86  4EF9 00001E8C           1933          Jmp     EA_ADDQ_IMMEDIATE
00001E8C                          1934          
00001E8C                          1935  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001E8C  1CFC 0023               1936          Move.B  #'#', (A6)+
00001E90  0600 0030               1937          Add.B   #$30, D0
00001E94  1CC0                    1938          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001E96                          1939          
00001E96  4E75                    1940          Rts
00001E98                          1941          
00001E98                          1942  EA_ADDQ_DEST    ; Determines the destination       
00001E98  4EB9 000020F6           1943          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E9E                          1944          
00001E9E  4E75                    1945          Rts     
00001EA0                          1946          
00001EA0                          1947  ;=========================================================;        
00001EA0                          1948  ;---------------------- EA Sub/SubA ----------------------;
00001EA0                          1949  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001EA0                          1950  ; Sub/SubA are exactly the same.
00001EA0                          1951  ;=========================================================;
00001EA0                          1952  EA_SUB
00001EA0  4EF8 1DA6               1953          Jmp     EA_ADD
00001EA4                          1954  
00001EA4                          1955  ;=========================================================;        
00001EA4                          1956  ;---------------------- EA Cmp/CmpA ----------------------;
00001EA4                          1957  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001EA4                          1958  ; Cmp/CmpA are exactly the same.
00001EA4                          1959  ;=========================================================;
00001EA4                          1960  EA_CMP       
00001EA4  4EF8 1DA6               1961          Jmp     EA_ADD
00001EA8                          1962          
00001EA8                          1963  ;=========================================================;        
00001EA8                          1964  ;------------------------ EA Lea -------------------------;
00001EA8                          1965  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001EA8                          1966  ; are exactly the same.
00001EA8                          1967  ;=========================================================;
00001EA8                          1968  EA_LEA
00001EA8  4EF8 1DA6               1969          Jmp     EA_ADD
00001EAC                          1970          
00001EAC                          1971  ;=========================================================;        
00001EAC                          1972  ;------------------------ EA And -------------------------;
00001EAC                          1973  ; Jumps straight to EA_ADD because the EA for Add and And
00001EAC                          1974  ; are exactly the same.
00001EAC                          1975  ;=========================================================;
00001EAC                          1976  EA_AND
00001EAC  4EF8 1DA6               1977          Jmp     EA_ADD
00001EB0                          1978          
00001EB0                          1979  ;=========================================================;        
00001EB0                          1980  ;------------------------ EA Eor -------------------------;
00001EB0                          1981  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001EB0                          1982  ; are exactly the same.
00001EB0                          1983  ;=========================================================;
00001EB0                          1984  EA_EOR
00001EB0  4EF8 1DA6               1985          Jmp     EA_ADD
00001EB4                          1986          
00001EB4                          1987  ;=========================================================;        
00001EB4                          1988  ;------------------------ EA Neg -------------------------;
00001EB4                          1989  ;=========================================================;
00001EB4                          1990  EA_NEG
00001EB4  4EB9 000020F6           1991          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EBA                          1992          
00001EBA  4E75                    1993          RTS
00001EBC                          1994          
00001EBC                          1995  ;=========================================================;        
00001EBC                          1996  ;------------------------ EA Not -------------------------;
00001EBC                          1997  ; Jumps straight to EA_NEG because Neg and Not have the
00001EBC                          1998  ; exact same EAs. 
00001EBC                          1999  ;=========================================================;
00001EBC                          2000  EA_NOT
00001EBC  4EF8 1EB4               2001          Jmp     EA_NEG 
00001EC0                          2002          
00001EC0                          2003  ;=========================================================;        
00001EC0                          2004  ;------------------------ EA Jsr -------------------------;
00001EC0                          2005  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001EC0                          2006  ; exact same EAs. 
00001EC0                          2007  ;=========================================================;
00001EC0                          2008  EA_Jsr
00001EC0  4EF8 1EB4               2009          Jmp     EA_NEG 
00001EC4                          2010  
00001EC4                          2011  ;=========================================================;
00001EC4                          2012  ;--------------------- EA Bit Shift ----------------------;
00001EC4                          2013  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001EC4                          2014  ; are combined because the EA for each code is exactly the
00001EC4                          2015  ; same.
00001EC4                          2016  ;=========================================================;
00001EC4                          2017  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001EC4  4EB9 00002240           2018          Jsr     GET6TO7
00001ECA                          2019          
00001ECA  B03C 0003               2020          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001ECE  6600 0012               2021          Bne     EA_SHIFT_REGISTER
00001ED2                          2022          
00001ED2  4EB9 00001EDA           2023          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001ED8                          2024          
00001ED8  4E75                    2025          RTS
00001EDA                          2026                  
00001EDA                          2027  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001EDA  4EB9 000020F6           2028          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EE0                          2029          
00001EE0  4E75                    2030          Rts
00001EE2                          2031          
00001EE2                          2032  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001EE2  4EB9 0000220E           2033          Jsr     GETBIT5
00001EE8                          2034          
00001EE8  B03C 0000               2035          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001EEC  6700 0008               2036          Beq     EA_SHIFT_CHECK_8
00001EF0                          2037          
00001EF0  4EF9 00001F1E           2038          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001EF6                          2039          
00001EF6                          2040  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001EF6  4EB9 0000216C           2041          Jsr     GET9TO11                ; Isolate the count/register bits
00001EFC                          2042          
00001EFC  B03C 0000               2043          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001F00  6E00 000C               2044          Bgt     EA_SHIFT_IMMEDIATE
00001F04                          2045          
00001F04  103C 0008               2046          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001F08                          2047                  
00001F08  4EF9 00001F0E           2048          Jmp     EA_SHIFT_IMMEDIATE
00001F0E                          2049          
00001F0E                          2050  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001F0E  1CFC 0023               2051          Move.B  #'#', (A6)+
00001F12  0600 0030               2052          Add.B   #$30, D0
00001F16  1CC0                    2053          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001F18                          2054  
00001F18  4EF9 00001F30           2055          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001F1E                          2056          
00001F1E                          2057  EA_SHIFT_DN ; Adds a data register before the comma
00001F1E  4EB9 0000216C           2058          Jsr     GET9TO11                ; Isolate the data register bits
00001F24                          2059          
00001F24  4EB9 0000201A           2060          Jsr     EA_DN                   ; Add the data register to the string
00001F2A                          2061          
00001F2A  4EF9 00001F30           2062          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F30                          2063          
00001F30                          2064  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F30  1CFC 002C               2065          Move.B  #',', (A6)+
00001F34                          2066          
00001F34  4EB9 000021A2           2067          Jsr     GET0TO2                 ; Get the register number
00001F3A                          2068          
00001F3A  4EB9 0000201A           2069          Jsr     EA_DN                   ; Add the register
00001F40                          2070          
00001F40  4E75                    2071          RTS
00001F42                          2072  
00001F42                          2073  ;============================================;        
00001F42                          2074  ;--------------- EA Immediate ---------------;
00001F42                          2075  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F42                          2076  ;============================================;
00001F42                          2077  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F42  4EB9 00001F54           2078          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F48  1CFC 002C               2079          Move.B  #',', (A6)+             ; Add a comma
00001F4C  4EB9 00001F72           2080          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001F52                          2081          
00001F52  4E75                    2082          RTS
00001F54                          2083          
00001F54                          2084  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001F54  4EB9 00002240           2085          Jsr     GET6TO7                 ; Isolate the size bits
00001F5A                          2086                  
00001F5A  B03C 0001               2087          Cmp.B   #%01, D0                ; Immediate word
00001F5E  6700 0176               2088          Beq     EA_IMM_WORD
00001F62                          2089          
00001F62  B03C 0002               2090          Cmp.B   #%10, D0                ; Immediate long
00001F66  6700 017E               2091          Beq     EA_IMM_LONG
00001F6A                          2092        
00001F6A  4EF9 000020C6           2093          Jmp     EA_IMM_BYTE
00001F70                          2094  
00001F70  4E75                    2095          Rts
00001F72                          2096          
00001F72                          2097  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001F72  4EB9 000020F6           2098          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F78                          2099          
00001F78  4E75                    2100          Rts
00001F7A                          2101        
00001F7A                          2102  ;=================================================;  
00001F7A                          2103  ;-------------------- EA Muls --------------------;
00001F7A                          2104  ;=================================================;
00001F7A                          2105  EA_MULS ; Determines the EA for Muls
00001F7A  4EB9 00001F92           2106          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001F80  1CFC 002C               2107          Move.B  #',', (A6)+             ; Add a comma
00001F84  4EB9 0000216C           2108          Jsr     GET9TO11                ; Get the register
00001F8A  4EB9 0000201A           2109          Jsr     EA_DN                   ; Add Dn
00001F90                          2110          
00001F90  4E75                    2111          RTS
00001F92                          2112          
00001F92                          2113  EA_MULS_ADDRESS ; Determines the EA
00001F92  4EB9 000020F6           2114          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F98                          2115          
00001F98  B03C 0004               2116          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001F9C  6700 0138               2117          Beq     EA_IMM_WORD
00001FA0                          2118          
00001FA0  4E75                    2119          Rts
00001FA2                          2120          
00001FA2                          2121  ;=================================================;  
00001FA2                          2122  ;-------------------- EA DIVS --------------------;
00001FA2                          2123  ; Jumps straight to EA_DIVS because the EA for
00001FA2                          2124  ; both OP codes is exactly the same.
00001FA2                          2125  ;=================================================;
00001FA2                          2126  EA_DIVS
00001FA2  4EF8 1F7A               2127          Jmp     EA_MULS
00001FA6                          2128          
00001FA6                          2129  ;=================================================;        
00001FA6                          2130  ;-------------------- EA BTST --------------------;
00001FA6                          2131  ;=================================================;
00001FA6                          2132  EA_BTST ; Determines the EA for Btst
00001FA6  4EB9 000021B4           2133          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001FAC                          2134          
00001FAC  B03C 0001               2135          Cmp.B   #%1, D0                 ; 1 is a data register
00001FB0  6700 0008               2136          Beq     EA_BTST_DN
00001FB4                          2137          
00001FB4  4EF9 00001FCE           2138          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
00001FBA                          2139          
00001FBA                          2140  EA_BTST_DN  ; Gets the register for the bit number
00001FBA  4EB9 0000216C           2141          Jsr     GET9TO11                ; Get the register
00001FC0  4EB9 0000201A           2142          Jsr     EA_DN                   ; Add the register to the string
00001FC6                          2143          
00001FC6  4EB9 00001FDC           2144          Jsr     EA_BTST_ADDRESS         ; Add the EA
00001FCC                          2145          
00001FCC  4E75                    2146          RTS
00001FCE                          2147  
00001FCE                          2148  EA_BTST_IMM ; Gets the immediate data for the bit number
00001FCE  4EB9 000020C6           2149          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00001FD4                          2150          
00001FD4  4EB9 00001FDC           2151          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
00001FDA                          2152          
00001FDA  4E75                    2153          RTS
00001FDC                          2154  
00001FDC                          2155  EA_BTST_ADDRESS ; Get the EA
00001FDC  1CFC 002C               2156          Move.B  #',', (A6)+
00001FE0                          2157  
00001FE0  4EB9 000020F6           2158          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
00001FE6                          2159          
00001FE6  B03C 0004               2160          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
00001FEA  6700 00DA               2161          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
00001FEE                          2162          
00001FEE  4E75                    2163          Rts
00001FF0                          2164          
00001FF0                          2165  ;==================================================;        
00001FF0                          2166  ;------------------- EA Branch --------------------;
00001FF0                          2167  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00001FF0                          2168  ;==================================================;
00001FF0                          2169  EA_BRANCH  ; Determines the EA for Branch codes
00001FF0  4EB9 00002220           2170          Jsr     GET0TO7                 ; Get the 8 displacement bits
00001FF6                          2171          
00001FF6  2C0B                    2172          Move.L  A3, D6                  ; Move address after the Bra word to D6
00001FF8                          2173          
00001FF8  B03C 0000               2174          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
00001FFC  6700 0008               2175          Beq     EA_BRANCH_16_BIT
00002000                          2176          
00002000  4EF9 0000200E           2177          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
00002006                          2178  
00002006                          2179  EA_BRANCH_16_BIT   ; Gets the next word
00002006  301B                    2180          Move.W  (A3)+, D0               ; Stores the word in D0
00002008                          2181  
00002008  4EF9 0000200E           2182          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
0000200E                          2183          
0000200E                          2184  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
0000200E  DC40                    2185          Add.W   D0, D6                  ; Add the displacement to D6
00002010                          2186      
00002010  1CFC 0024               2187          Move.B  #'$', (A6)+             ; Add '$' to the string
00002014                          2188          
00002014  4EB8 1290               2189          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
00002018                          2190  
00002018  4E75                    2191          RTS
0000201A                          2192                         
0000201A                          2193  ;==========================================;        
0000201A                          2194  ;---------- General EA functions ----------;
0000201A                          2195  ;==========================================;
0000201A                          2196  EA_DN   ; Adds Dn EA to string
0000201A  1CFC 0044               2197          Move.B  #'D', (A6)+             
0000201E  0600 0030               2198          Add.B   #$30, D0        
00002022  1CC0                    2199          Move.B  D0, (A6)+               
00002024                          2200                  
00002024  4E75                    2201          Rts
00002026                          2202  
00002026                          2203  EA_AN   ; Adds An EA to string
00002026  1CFC 0041               2204          Move.B  #'A', (A6)+
0000202A  0600 0030               2205          Add.B   #$30, D0    
0000202E  1CC0                    2206          Move.B  D0, (A6)+               
00002030                          2207                  
00002030  4E75                    2208          Rts
00002032                          2209  
00002032                          2210  EA_AN_PNTR  ; Adds (An) EA to string
00002032  1CFC 0028               2211          Move.B  #'(', (A6)+
00002036  1CFC 0041               2212          Move.B  #'A', (A6)+
0000203A  0600 0030               2213          Add.B   #$30, D0
0000203E  1CC0                    2214          Move.B  D0, (A6)+
00002040  1CFC 0029               2215          Move.B  #')', (A6)+
00002044                          2216                  
00002044  4E75                    2217          Rts
00002046                          2218          
00002046                          2219  EA_AN_INC   ; Adds (An)+ EA to string
00002046  1CFC 0028               2220          Move.B  #'(', (A6)+
0000204A  1CFC 0041               2221          Move.B  #'A', (A6)+
0000204E  0600 0030               2222          Add.B   #$30, D0
00002052  1CC0                    2223          Move.B  D0, (A6)+
00002054  1CFC 0029               2224          Move.B  #')', (A6)+
00002058  1CFC 002B               2225          Move.B  #'+', (A6)+
0000205C                          2226                  
0000205C  4E75                    2227          Rts 
0000205E                          2228          
0000205E                          2229  EA_AN_DEC   ; Adds -(An) EA to string
0000205E  1CFC 002D               2230          Move.B  #'-', (A6)+
00002062  1CFC 0028               2231          Move.B  #'(', (A6)+
00002066  1CFC 0041               2232          Move.B  #'A', (A6)+
0000206A  0600 0030               2233          Add.B   #$30, D0
0000206E  1CC0                    2234          Move.B  D0, (A6)+
00002070  1CFC 0029               2235          Move.B  #')', (A6)+
00002074                          2236                  
00002074  4E75                    2237          Rts 
00002076                          2238  
00002076                          2239  EA_WORD_ADDR    ; Adds $Word to string
00002076  3C1B                    2240          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
00002078                          2241          
00002078  1CFC 0024               2242          Move.B  #'$', (A6)+
0000207C                          2243          
0000207C  BC7C 8000               2244          Cmp.W   #$8000, D6          ; Word address is less than 8000
00002080  6500 000C               2245          Bcs     EA_SIGN_EXT_16
00002084                          2246          
00002084  BC7C 8000               2247          Cmp.W   #$8000, D6          ; Word address is greater than 8000
00002088  6400 001A               2248          Bcc     EA_SIGN_EXT_32
0000208C                          2249          
0000208C  4E75                    2250          Rts
0000208E                          2251                  
0000208E                          2252  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
0000208E  1CFC 0030               2253          Move.B  #'0', (A6)+
00002092  1CFC 0030               2254          Move.B  #'0', (A6)+
00002096  1CFC 0030               2255          Move.B  #'0', (A6)+
0000209A  1CFC 0030               2256          Move.B  #'0', (A6)+
0000209E                          2257          
0000209E  4EB8 12B0               2258          Jsr     hex_to_ASCII_W       
000020A2                          2259          
000020A2  4E75                    2260          Rts
000020A4                          2261  
000020A4                          2262  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
000020A4  1CFC 0046               2263          Move.B  #'F', (A6)+
000020A8  1CFC 0046               2264          Move.B  #'F', (A6)+
000020AC  1CFC 0046               2265          Move.B  #'F', (A6)+
000020B0  1CFC 0046               2266          Move.B  #'F', (A6)+
000020B4                          2267          
000020B4  4EB8 12B0               2268          Jsr     hex_to_ASCII_W   
000020B8                          2269          
000020B8  4E75                    2270          Rts
000020BA                          2271                  
000020BA                          2272  EA_LONG_ADDR    ; Adds $Long to string
000020BA  2C1B                    2273          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
000020BC                          2274          
000020BC  1CFC 0024               2275          Move.B  #'$', (A6)+
000020C0                          2276          
000020C0  4EB8 1290               2277          Jsr     hex_to_ASCII_L
000020C4                          2278  
000020C4  4E75                    2279          Rts
000020C6                          2280                  
000020C6                          2281  
000020C6                          2282  EA_IMM_BYTE ; Finds the immediate byte data
000020C6  3C1B                    2283          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
000020C8                          2284          
000020C8  1CFC 0023               2285          Move.B  #'#', (A6)+         
000020CC  1CFC 0024               2286          Move.B  #'$', (A6)+         
000020D0                          2287          
000020D0  4EB8 12D0               2288          Jsr     hex_to_ASCII_B    ; Add the byte to the string
000020D4                          2289          
000020D4  4E75                    2290          Rts
000020D6                          2291                  
000020D6                          2292  EA_IMM_WORD ; Finds the immediate word data
000020D6  3C1B                    2293          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
000020D8                          2294          
000020D8  1CFC 0023               2295          Move.B  #'#', (A6)+         
000020DC  1CFC 0024               2296          Move.B  #'$', (A6)+         
000020E0                          2297          
000020E0  4EB8 12B0               2298          Jsr     hex_to_ASCII_W    ; Add the word to the string
000020E4                          2299          
000020E4  4E75                    2300          Rts
000020E6                          2301          
000020E6                          2302  EA_IMM_LONG ; Finds the immediate long data
000020E6  2C1B                    2303          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
000020E8                          2304          
000020E8  1CFC 0023               2305          Move.B  #'#', (A6)+
000020EC  1CFC 0024               2306          Move.B  #'$', (A6)+
000020F0                          2307          
000020F0  4EB8 1290               2308          Jsr     hex_to_ASCII_L    ; Add the long to the string
000020F4                          2309          
000020F4  4E75                    2310          Rts
000020F6                          2311          
000020F6                          2312  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
000020F6  4EB9 00002190           2313          Jsr     GET3TO5                 ; Get source mode
000020FC  1A00                    2314          Move.B  D0, D5                  ; Move source mode to D5
000020FE  4EB9 000021A2           2315          Jsr     Get0TO2                 ; Get source register
00002104                          2316          
00002104                          2317          ; List of valid effective addresses
00002104  BA3C 0000               2318          Cmp.B   #Dn_Mode, D5            ; Dn
00002108  6700 FF10               2319          Beq     EA_DN
0000210C                          2320          
0000210C  BA3C 0001               2321          Cmp.B   #An_Mode, D5            ; An
00002110  6700 FF14               2322          Beq     EA_AN
00002114                          2323          
00002114  BA3C 0002               2324          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00002118  6700 FF18               2325          Beq     EA_AN_PNTR
0000211C                          2326          
0000211C  BA3C 0003               2327          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00002120  6700 FF24               2328          Beq     EA_AN_INC
00002124                          2329          
00002124  BA3C 0004               2330          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00002128  6700 FF34               2331          Beq     EA_AN_DEC
0000212C                          2332          
0000212C                          2333          ; Comparing registers at this point because modes are the same
0000212C  B03C 0000               2334          Cmp.B   #Word_Reg, D0           ; (xxx).W
00002130  6700 FF44               2335          Beq     EA_WORD_ADDR
00002134                          2336          
00002134  B03C 0001               2337          Cmp.B   #Long_Reg, D0           ; (xxx).L
00002138  6780                    2338          Beq     EA_LONG_ADDR
0000213A                          2339          
0000213A  4E75                    2340          Rts
0000213C                          2341      
0000213C                          2342  
0000213C                          2343  ;---------------- Bit Chopping Sub Routines ----------------;
0000213C                          2344  ; These Sub Routines Chop a WORD size piece of data from
0000213C                          2345  ; Data register 4 into a smaller piece, leaving just the
0000213C                          2346  ; Piece in register 0 while leaving the original piece
0000213C                          2347  ; of data intact.
0000213C                          2348  
0000213C                          2349  ; REGISTERS USED: D0, D1, D4 (const input)
0000213C                          2350  
0000213C                          2351  GET12TO15   ;1001 0000 0000 0000 -> 1001
0000213C  4280                    2352                  CLR.L   D0      
0000213E  3004                    2353                  Move.W  D4, D0      
00002140                          2354                  
00002140  123C 000C               2355                  Move.B  #12, D1     
00002144  E268                    2356                  LSR.W       D1, D0      
00002146                          2357                  
00002146  4E75                    2358                  RTS
00002148                          2359                  
00002148                          2360  GET12TO13
00002148  4280                    2361          CLR.L   D0
0000214A  3004                    2362          Move.W  D4, D0
0000214C                          2363          
0000214C  123C 0002               2364          Move.B  #2, D1
00002150  E368                    2365          LSL     D1, D0
00002152                          2366          
00002152  123C 000E               2367          Move.B  #14, D1
00002156  E268                    2368          LSR     D1, D0
00002158                          2369          
00002158  4E75                    2370          RTS             
0000215A                          2371  
0000215A                          2372  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
0000215A  4280                    2373                  CLR.L   D0      ; Clear out D0
0000215C  3004                    2374                  Move.W  D4, D0      ; Move a copy of the bit string to D0
0000215E                          2375                  
0000215E  123C 0004               2376                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002162  E368                    2377                  LSL.W   D1, D0      ; Move the string all the way to the left
00002164                          2378                  
00002164  123C 000C               2379                  Move.B  #12, D1     ; Change the amount of bits shifted
00002168  E268                    2380                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
0000216A                          2381                  
0000216A  4E75                    2382                  RTS         ; Return from the subroutine
0000216C                          2383                      
0000216C                          2384  GET9TO11    ; 0000 1010 0000 0000 -> 101    
0000216C  4280                    2385                  CLR.L   D0      ; Clear out D0
0000216E  3004                    2386                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002170                          2387                  
00002170  123C 0004               2388                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002174  E368                    2389                  LSL.W   D1, D0      ; Move the string all the way to the left
00002176                          2390                  
00002176  123C 000D               2391                  Move.B  #13, D1     ; Change the amount of bits shifted
0000217A  E268                    2392                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
0000217C                          2393                  
0000217C  4E75                    2394                  RTS         ; Return from the subroutine
0000217E                          2395                  
0000217E                          2396  GET6TO8     ; 0000 0001 1000 0000 -> 110
0000217E  4280                    2397                  CLR.L   D0
00002180  3004                    2398                  Move.W  D4, D0
00002182                          2399                  
00002182  123C 0007               2400                  Move.B  #7, D1
00002186  E368                    2401                  LSL.W   D1, D0
00002188                          2402                  
00002188  123C 000D               2403                  Move.B  #13, D1
0000218C  E268                    2404                  LSR.W       D1, D0
0000218E                          2405                  
0000218E  4E75                    2406                  RTS
00002190                          2407                  
00002190                          2408  GET3TO5     ; 0000 0000 0011 1000 -> 111
00002190  4280                    2409                  CLR.L   D0
00002192  3004                    2410                  Move.W  D4, D0
00002194                          2411                  
00002194  123C 000A               2412                  Move.B  #10, D1
00002198  E368                    2413                  LSL.W   D1, D0
0000219A                          2414                  
0000219A  123C 000D               2415                  Move.B  #13, D1
0000219E  E268                    2416                  LSR.W       D1, D0
000021A0                          2417                  
000021A0  4E75                    2418                  RTS
000021A2                          2419  GET0TO2     ; 0000 0000 0000 0011 -> 011
000021A2  4280                    2420                  CLR.L   D0
000021A4  3004                    2421                  Move.W  D4, D0
000021A6                          2422                  
000021A6  123C 000D               2423                  Move.B  #13, D1
000021AA  E368                    2424                  LSL.W   D1, D0
000021AC                          2425                  
000021AC  123C 000D               2426                  Move.B  #13, D1
000021B0  E268                    2427                  LSR.W       D1, D0
000021B2                          2428                  
000021B2  4E75                    2429                  RTS
000021B4                          2430  GETBIT8     ; 0000 0001 0000 0000 -> 1
000021B4  4280                    2431                  CLR.L   D0
000021B6  3004                    2432                  Move.W  D4, D0
000021B8                          2433                  
000021B8  123C 0007               2434                  Move.B  #7, D1
000021BC  E368                    2435                  LSL.W   D1, D0
000021BE                          2436                  
000021BE  123C 000F               2437                  Move.B  #15, D1
000021C2  E268                    2438                  LSR.W       D1, D0
000021C4                          2439                  
000021C4  4E75                    2440                  RTS
000021C6                          2441                  
000021C6                          2442  GET9AND10    ; 0000 0110 0000 0000 -> 11
000021C6  4280                    2443                  CLR.L   D0
000021C8  3004                    2444                  Move.W  D4, D0
000021CA                          2445                  
000021CA  123C 0005               2446                  Move.B  #5, D1
000021CE  E368                    2447                  LSL.W   D1, D0
000021D0                          2448                  
000021D0  123C 000E               2449                  Move.B  #14, D1
000021D4  E268                    2450                  LSR.W   D1, D0
000021D6                          2451                  
000021D6  4E75                    2452                  RTS             
000021D8                          2453                  
000021D8                          2454  GET6AND7    
000021D8  4280                    2455                  CLR.L   D0
000021DA  3004                    2456                  Move.W  D4, D0
000021DC                          2457                  
000021DC  123C 0008               2458                  Move.B  #8, D1
000021E0  E368                    2459                  LSL.W   D1, D0
000021E2                          2460                  
000021E2  123C 000E               2461                  Move.B  #14, D1
000021E6  E268                    2462                  LSR.W   D1, D0
000021E8                          2463                  
000021E8  4E75                    2464                  RTS
000021EA                          2465                  
000021EA                          2466  GET7AND8    
000021EA  4280                    2467                  CLR.L   D0
000021EC  3004                    2468                  Move.W  D4, D0
000021EE                          2469                  
000021EE  123C 0007               2470                  Move.B  #7, D1
000021F2  E368                    2471                  LSL.W   D1, D0
000021F4                          2472                  
000021F4  123C 000E               2473                  Move.B  #14, D1
000021F8  E268                    2474                  LSR.W   D1, D0
000021FA                          2475                  
000021FA  4E75                    2476                  RTS             
000021FC                          2477                  
000021FC                          2478  GET3AND4    
000021FC  4280                    2479                  CLR.L   D0
000021FE  3004                    2480                  Move.W  D4, D0
00002200                          2481                  
00002200  123C 000B               2482                  Move.B  #11, D1
00002204  E368                    2483                  LSL.W   D1, D0
00002206                          2484                  
00002206  123C 000E               2485                  Move.B  #14, D1
0000220A  E268                    2486                  LSR.W   D1, D0
0000220C                          2487                  
0000220C  4E75                    2488                  RTS
0000220E                          2489                  
0000220E                          2490  GETBIT5
0000220E  4280                    2491          Clr.L   D0
00002210  3004                    2492          Move.W  D4, D0
00002212                          2493          
00002212  123C 000A               2494          Move.B  #10, D1
00002216  E368                    2495          Lsl     D1, D0
00002218                          2496          
00002218  123C 000F               2497          Move.B  #15, D1
0000221C  E268                    2498          Lsr     D1, D0
0000221E                          2499          
0000221E  4E75                    2500          Rts
00002220                          2501  
00002220                          2502  GET0TO7
00002220  4280                    2503          Clr.L   D0
00002222  3004                    2504          Move.W  D4, D0
00002224                          2505          
00002224  123C 0008               2506          Move.B  #8, D1
00002228  E368                    2507          Lsl     D1, D0
0000222A                          2508          
0000222A  E268                    2509          Lsr     D1, D0
0000222C                          2510          
0000222C  4E75                    2511          Rts
0000222E                          2512          
0000222E                          2513  GETBIT10
0000222E  4280                    2514          Clr.L   D0
00002230  3004                    2515          Move.W  D4, D0
00002232                          2516          
00002232  123C 0005               2517          Move.B  #5, D1
00002236  E368                    2518          Lsl     D1, D0
00002238                          2519          
00002238  123C 000F               2520          Move.B  #15, D1
0000223C  E268                    2521          Lsr     D1, D0
0000223E                          2522          
0000223E  4E75                    2523          Rts
00002240                          2524          
00002240                          2525  GET6TO7
00002240  4280                    2526          Clr.L   D0
00002242  3004                    2527          Move.W  D4, D0
00002244                          2528          
00002244  123C 0008               2529          Move.B  #8, D1
00002248  E368                    2530          Lsl     D1, D0
0000224A                          2531          
0000224A  123C 000E               2532          Move.B  #14, D1
0000224E  E268                    2533          Lsr     D1, D0
00002250                          2534          
00002250  4E75                    2535          Rts
00002252                          2536  
00002252                          2537  GET3TO8    ; 0000 0000 1100 0000 -> 11
00002252  4280                    2538                  CLR.L   D0
00002254  3004                    2539                  Move.W  D4, D0
00002256                          2540                  
00002256  123C 0007               2541                  Move.B  #7, D1
0000225A  E368                    2542                  LSL.W   D1, D0
0000225C                          2543                  
0000225C  123C 000A               2544                  Move.B  #10, D1
00002260  E268                    2545                  LSR.W   D1, D0
00002262                          2546                  
00002262  4E75                    2547                  RTS
00002264                          2548  
00002264                          2549  GET6TO11    ; 0000 0000 1100 0000 -> 11
00002264  4280                    2550                  CLR.L   D0
00002266  3004                    2551                  Move.W  D4, D0
00002268                          2552                  
00002268  123C 0004               2553                  Move.B  #4, D1
0000226C  E368                    2554                  LSL.W   D1, D0
0000226E                          2555                  
0000226E  123C 000A               2556                  Move.B  #10, D1
00002272  E268                    2557                  LSR.W   D1, D0
00002274                          2558                  
00002274  4E75                    2559                  RTS        
00002276                          2560                  
00002276                          2561             
00002276                          2562  ;-----------Constants/Messages-------------------------------------------------
00002276= 09 2D 2D 2D 2D 2D ...   2563  intro_stuff     DC.B    HT,'------------------------------------------------------',CR,LF,0
000022B0                          2564  
000022B0= 09 20 57 65 6C 63 ...   2565  intro_msg       DC.B    HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000022E8= 09 20 43 72 65 61 ...   2566                  DC.B    HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
00002321                          2567         
00002321= 50 6C 65 61 73 65 ...   2568  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
0000235A= 50 6C 65 61 73 65 ...   2569  end_address1    DC.B    'Please enter the ending address from $',0
00002381= 20 74 6F 20 24 30 ...   2570  end_address2    DC.B    ' to $00FFFFFE: ',0
00002391= 54 68 61 6E 6B 20 ...   2571  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
000023C3= 57 6F 75 6C 64 20 ...   2572  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000023F3= 48 69 74 20 65 6E ...   2573  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
00002421                          2574  
00002421= 09 41 64 64 72 65 ...   2575  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
00002457= 09 59 6F 75 20 6E ...   2576  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
00002483= 09 50 6C 65 61 73 ...   2577  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
000024BB                          2578  
000024BC                          2579  start_input     DS.L    2               ; Allocates space for start address
000024C4                          2580  end_input       DS.L    2               ; Allocates space for end address
000024CC                          2581  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
000024D4                          2582  hit_enter       DS.L    2               ; User input to hit enter
000024DC                          2583  line_count      DS.L    1               ; Holds the display line count  
000024E0                          2584  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
00002620                          2585  valid_data      DS.L    80              ; Instructions that we converted
00002760                          2586                  
00002760                          2587                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            14FA
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           2483
ASK_INPUT           24CC
ASK_USER            23C3
BADADDR_INPUT       2421
BAD_BUFF            1134
BEGIN               0
BIT_SHIFT           153A
BIT_SHIFT_MEM       154C
BIT_SHIFT_REG       156E
BRANCH_CONDITIONALS  1478
CHECK_10_LINES      118A
CHECK_INPUT         1244
CHK_BOUND           1336
CMP_EOR             1590
CONVERT_HEX         12F0
CR                  D
DISASSEMBLE         10DE
DISPLAY_DATA        114E
DN_MODE             0
DONE                1222
DONE_CONVERTING     1312
EA_0TO5             20F6
EA_ADD              1DA6
EA_ADDA             1DDA
EA_ADDQ             1E62
EA_ADDQ_CHECK_8     1E74
EA_ADDQ_DEST        1E98
EA_ADDQ_IMMEDIATE   1E8C
EA_ADD_ADDRESS      1E22
EA_ADD_OPMODE_DEST  1E0A
EA_ADD_OPMODE_SOURCE  1DF2
EA_ADD_SIZE         1E32
EA_AN               2026
EA_AND              1EAC
EA_AN_DEC           205E
EA_AN_INC           2046
EA_AN_PNTR          2032
EA_BIT_SHIFT        1EC4
EA_BRANCH           1FF0
EA_BRANCH_16_BIT    2006
EA_BRANCH_ADD_DIS   200E
EA_BTST             1FA6
EA_BTST_ADDRESS     1FDC
EA_BTST_DN          1FBA
EA_BTST_IMM         1FCE
EA_CMP              1EA4
EA_DIVS             1FA2
EA_DN               201A
EA_EOR              1EB0
EA_IMMEDIATE        1F42
EA_IMMEDIATE_DEST   1F72
EA_IMMEDIATE_SIZE   1F54
EA_IMM_BYTE         20C6
EA_IMM_LONG         20E6
EA_IMM_WORD         20D6
EA_JSR              1EC0
EA_LEA              1EA8
EA_LONG_ADDR        20BA
EA_MOVE             1B62
EA_MOVEM            1BEC
EA_MOVEM_ADD_LAST_REG  1CD6
EA_MOVEM_ADD_SINGLE_REG  1CB6
EA_MOVEM_CARRY_CLEAR  1C96
EA_MOVEM_CARRY_SET  1C76
EA_MOVEM_FIRST_REG  1CA6
EA_MOVEM_LAST_REG   1CC8
EA_MOVEM_LIST_END   1C60
EA_MOVEM_LIST_LOOP  1C44
EA_MOVEM_MEM_TO_REG  1C28
EA_MOVEM_POST_INC   1C6C
EA_MOVEM_PRE_DEC    1C62
EA_MOVEM_REG        1CEA
EA_MOVEM_REG_TO_MEM  1C12
EA_MOVE_DEST        1B84
EA_MOVE_SIZE        1BCC
EA_MOVE_SOURCE      1B74
EA_MULS             1F7A
EA_MULS_ADDRESS     1F92
EA_NEG              1EB4
EA_NOT              1EBC
EA_SHIFT_CHECK_8    1EF6
EA_SHIFT_COMMA      1F30
EA_SHIFT_DN         1F1E
EA_SHIFT_IMMEDIATE  1F0E
EA_SHIFT_MEMORY     1EDA
EA_SHIFT_REGISTER   1EE2
EA_SIGN_EXT_16      208E
EA_SIGN_EXT_32      20A4
EA_SUB              1EA0
EA_WORD_ADDR        2076
END                 FFFFFE
ENDING              2391
END_ADDRESS1        235A
END_ADDRESS2        2381
END_ERROR           131E
END_INPUT           24C4
GET0TO2             21A2
GET0TO7             2220
GET12TO13           2148
GET12TO15           213C
GET3AND4            21FC
GET3TO5             2190
GET3TO8             2252
GET6AND7            21D8
GET6TO11            2264
GET6TO7             2240
GET6TO8             217E
GET7AND8            21EA
GET8TO11            215A
GET9AND10           21C6
GET9TO11            216C
GETBIT10            222E
GETBIT5             220E
GETBIT8             21B4
GOOD_BUFF           1144
HEX_ASCII_LOOPB     12DA
HEX_ASCII_LOOPL     129A
HEX_ASCII_LOOPW     12BA
HEX_TO_ASCII_B      12D0
HEX_TO_ASCII_L      1290
HEX_TO_ASCII_W      12B0
HIT_ENTER           24D4
HIT_ENTER_MSG       23F3
HT                  9
ILLEGAL             1158
ILLEGAL_DATA        24E0
IMMEDIATE_BTST      13D8
IMM_MODE            7
IMM_REG             4
INTRO_MSG           22B0
INTRO_STUFF         2276
INVALID             1288
IS_LETTER           127A
IS_NUMBER           1272
JSR_RTS             145E
LF                  A
LINE_COUNT          24DC
LOAD_BAD_INPUT      1328
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1ADA
MAIN_LOOP           1124
MAKE_LETTER         1308
MAKE_NUMBER         12FC
ODD_ERR             134A
ODD_INPUT           2457
OP_ADD              16A8
OP_ADDQ             15FE
OP_ADD_ADDR         16D2
OP_ADD_ADDRESS_VERSION  1AEE
OP_AND              19B2
OP_AS_MEM           19EC
OP_AS_REG           19CE
OP_BRANCH           1846
OP_BRA_CC           1888
OP_BRA_CS           189E
OP_BRA_EQ           18CA
OP_BRA_GE           1938
OP_BRA_GT           1964
OP_BRA_HIGH         185C
OP_BRA_LE           197A
OP_BRA_LOW          1872
OP_BRA_LT           194E
OP_BRA_MI           1922
OP_BRA_NE           18B4
OP_BRA_PL           190C
OP_BRA_VC           18E0
OP_BRA_VS           18F6
OP_BTST             16E6
OP_CHECK_ADDRESS_VERSION  1AE4
OP_CHECK_DATA_SIZE  1AF4
OP_CHECK_DATA_SIZE_ADDR  1B14
OP_CMP              1A70
OP_CMPI             175C
OP_CMP_ADDR         1A9A
OP_CODE_TREE        135C
OP_DIVS             163A
OP_EOR              1AAE
OP_EORI             173C
OP_JSR              1830
OP_LEA              177C
OP_LS_MEM           1A22
OP_LS_REG           1A04
OP_MOVE             15B2
OP_MOVEM            17CA
OP_MOVEM_DATA       180A
OP_MOVE_DATA        15E4
OP_MULS             1990
OP_NEG              1792
OP_NOT              17AE
OP_ORI              1700
OP_RO_MEM           1A58
OP_RO_REG           1A3A
OP_RTS              181C
OP_SET_BAD_BUFFER   1ACA
OP_SET_DATA_BYTE    1B26
OP_SET_DATA_LONG    1B3A
OP_SET_DATA_WORD    1B30
OP_SHIFT_DIRECTION  1B44
OP_SHIFT_LEFT       1B5C
OP_SHIFT_RIGHT      1B56
OP_SUB              166A
OP_SUBI             171C
OP_SUB_ADDR         1694
OP_TAB              1AD0
PROMPT_END          107A
PROMPT_FOR_DATA     119C
PROMPT_START        1024
PROMPT_TO_RERUN     11BA
RERUN_ERR_MSG       1214
RETURN              128C
SINGLE_OPERATOR_CODES  141E
START               1000
START_ADDRESS       2321
START_ERROR         1314
START_INPUT         24BC
VALID_DATA          2620
VALID_END           10BE
VALID_START         1058
VERIFIED            1282
VERIFY_INPUT        1232
WORD_MODE           7
WORD_REG            0
