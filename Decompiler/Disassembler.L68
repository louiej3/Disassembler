00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/2/2014 9:56:42 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 0000226E             30                  LEA     intro_stuff, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 000022A8             33                  LEA     intro_msg, A1       ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 0000226E             36                  LEA     intro_stuff, A1     ; Load introduction
0000101E  103C 000D                 37                  MOVE.B  #13, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024                            39                  
00001024                            40  
00001024                            41  *-----------Prompt For Starting Address---------------------                  
00001024  43F9 00002319             42  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
0000102A  103C 000E                 43                  MOVE.B  #14,D0              ; Load task code for display
0000102E  4E4F                      44                  TRAP    #15                 ; Display prompt message
00001030                            45                  
00001030  43F9 000024B4             46                  LEA     start_input,A1      ; Load address to store user's input
00001036  103C 0002                 47                  MOVE.B  #2,D0               ; Load task code for user input
0000103A  4E4F                      48                  TRAP    #15                 ; Ask for user input
0000103C  4EB9 00001232             49                  JSR     verify_input        ; Verifies user input string
00001042  B83C 0001                 50                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001046  6700 0010                 51                  BEQ     valid_start         ; Go to valid start if equal 
0000104A                            52                  
0000104A  43F9 00002419             53                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
00001050  103C 000E                 54                  MOVE.B  #14,D0              ; Load task code for display
00001054  4E4F                      55                  TRAP    #15                 ; Display bad input message
00001056  60CC                      56                  BRA     prompt_start        ; Go back beginning, asking for start address
00001058                            57  
00001058  4EB9 00001336             58  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000105E  B67C FFFF                 59                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
00001062  67C0                      60                  BEQ     prompt_start        ; Go back and ask for correct input
00001064  7C00                      61                  MOVE.L  #begin,D6           ; Store minimum address in D6
00001066  B686                      62                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001068  6D00 02AA                 63                  BLT     start_error         ; Then, start address is too low
0000106C  2C3C 00FFFFFE             64                  MOVE.L  #end,D6             ; Store max end address for comparison
00001072  B686                      65                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001074  6E00 029E                 66                  BGT     start_error         ; Then, start address is too high
00001078  2643                      67                  MOVEA.L D3,A3               ; Load starting address                 
0000107A                            68  
0000107A                            69  *-----------Prompt for Ending Address-----------------------            
0000107A  43F9 00002352             70  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
00001080  103C 000E                 71                  MOVE.B  #14,D0              ; Load task code for display
00001084  4E4F                      72                  TRAP    #15                 ; Display prompt message
00001086  43F9 000024B4             73                  LEA     start_input,A1      ; Load starting address
0000108C  4E4F                      74                  TRAP    #15                 ; Display starting address
0000108E  43F9 00002379             75                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
00001094  4E4F                      76                  TRAP    #15                 ; Display prompt message
00001096  43F9 000024BC             77                  LEA     end_input,A1        ; Ask for ending address
0000109C  103C 0002                 78                  MOVE.B  #2,D0               ; Load task code for input
000010A0  4E4F                      79                  TRAP    #15                 ; Prompt for input
000010A2  4EB9 00001232             80                  JSR     verify_input        ; Verifies user input string
000010A8  B83C 0001                 81                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010AC  6700 0010                 82                  BEQ     valid_end           ; Now validate the ending address
000010B0  43F9 00002419             83                  LEA     badAddr_input,A1        ; Else, bad input
000010B6  103C 000E                 84                  MOVE.B  #14,D0              ; Load task code for display
000010BA  4E4F                      85                  TRAP    #15                 ; Display bad input message
000010BC  60BC                      86                  BRA     prompt_end          ; Restart process
000010BE                            87  
000010BE  4EB9 00001336             88  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
000010C4  B67C FFFF                 89                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
000010C8  67B0                      90                  BEQ     prompt_end          ; Go back and ask for correct input
000010CA  2C3C 00FFFFFE             91                  MOVE.L  #end,D6             ; Move max address to compare with input
000010D0  B686                      92                  CMP.L   D6,D3               ; Is input higher than max
000010D2  6E00 024A                 93                  BGT     end_error           ; Input address is too high
000010D6  B68B                      94                  CMP.L   A3,D3               ; Is input at or above minimum address
000010D8  6D00 0244                 95                  BLT     end_error           ; Input address is too low
000010DC  2843                      96                  MOVEA.L D3,A4               ; Load ending address
000010DE                            97                                 
000010DE                            98  ;-------------- disassemble ---------------------------------------------------
000010DE                            99  ; -- Reads the data from the specified memory locations
000010DE                           100  ; -- Passes the data over to OP-code to verify the instruction
000010DE                           101  ; -- Decodes the word data from the specified memory location until the end
000010DE                           102  ; -- Checks for illegal data and valid data with the bad buffer bit
000010DE                           103  ;------------------------------------------------------------------------------
000010DE  4283                     104  disassemble     CLR.L   D3                  ; Clear for IO usage
000010E0  4284                     105                  CLR.L   D4                  ; Clear for OP Code usage              
000010E2  B7CC                     106                  CMP.L   A4,A3               ; At the end address?
000010E4  6E00 00D4                107                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
000010E8                           108                  
000010E8  4EB9 0000118A            109                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
000010EE  2C0B                     110                  MOVE.L  A3,D6               ; Store current address
000010F0                           111                  
000010F0  4DF9 000024D8            112                  LEA     illegal_data,A6     ; Load illegal data's address
000010F6  4EB9 00001290            113                  JSR     hex_to_ASCII_L      ; Store address to memory for display
000010FC  204E                     114                  MOVEA.L A6,A0               ; Store current location of illegal data
000010FE                           115                  
000010FE  4BF9 00002618            116                  LEA     valid_data,A5       ; Store current address to memory
00001104                           117                  
00001104  4DF9 00002618            118                  LEA     valid_data,A6       ; Store current address to memory
0000110A  4EB9 00001290            119                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
00001110  1CFC 0009                120                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001114                           121                  
00001114  381B                     122                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001116  4EB9 0000135C            123                  JSR     OP_CODE_TREE        ; Go to OP code jump table
0000111C                           124                  
0000111C  BE3C 0001                125                  CMP.B   #1,D7               ; Bad buffer set?
00001120  6700 0036                126                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001124                           127  main_loop
00001124                           128                  ; Store new line in memory
00001124  1CFC 000A                129                  MOVE.B  #LF,(A6)+
00001128  1CFC 000D                130                  MOVE.B  #CR,(A6)+
0000112C  BE3C 0001                131                  CMP.B   #1,D7               ; Bad buffer set?
00001130  6600 0012                132                  BNE     good_buff           ; Good Buffer, go prep for display
00001134                           133                  
00001134  4287                     134  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001136  1CFC 0000                135                  MOVE.B  #00,(A6)+           ; Add null terminator
0000113A  43F9 000024D8            136                  LEA     illegal_data,A1     ; Load the illegal data for display
00001140  6000 000C                137                  BRA     display_data        ; Go to display data
00001144                           138                  
00001144  1CFC 0000                139  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001148  43F9 00002618            140                  LEA     valid_data,A1       ; Load the valid data for display
0000114E                           141                  
0000114E  4280                     142  display_data    CLR.L   D0                  ; Clear for TASK TRAP
00001150  103C 000E                143                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001154  4E4F                     144                  TRAP    #15                 ; to in memory.
00001156  6086                     145                  BRA     disassemble         ; Done disassembling the word, next word                
00001158                           146                                                 
00001158                           147  ILLEGAL         ; word data from memory is not a required instruction
00001158  4BF9 000024D8            148                  LEA     illegal_data,A5     ; Store current address to memory
0000115E  2C48                     149                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
00001160  1CFC 0009                150                  MOVE.B  #HT,(A6)+           ; Store TAB 
00001164  1CFC 0044                151                  MOVE.B  #'D',(A6)+          ; Store DATA
00001168  1CFC 0041                152                  MOVE.B  #'A',(A6)+
0000116C  1CFC 0054                153                  MOVE.B  #'T',(A6)+
00001170  1CFC 0041                154                  MOVE.B  #'A',(A6)+
00001174  4EB9 00001AC8            155                  JSR     OP_TAB              ; Set up third collumn
0000117A  1CFC 0024                156                  MOVE.B  #'$',(A6)+
0000117E                           157                  
0000117E                           158                  ; Store 4 hex digits that represent the word into memory
0000117E  4286                     159                  CLR.L   D6
00001180  3C04                     160                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
00001182  4EB9 000012B0            161                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
00001188  609A                     162                  BRA     main_loop           ; Store info to memory as string              
0000118A                           163  
0000118A                           164  ;------------check_10_lines----------------------------------------------------
0000118A                           165  ; -- Prompt user to hit enter when there are 10 lines of data
0000118A                           166  ; -- Then reset the line count and go back to disassemble more data
0000118A                           167  ;------------------------------------------------------------------------------
0000118A                           168  check_10_lines
0000118A  45F9 000024D4            169                  LEA     line_count,A2       ; Assign A2 pointer for line count
00001190  5212                     170                  ADD.B   #1,(A2)             ; Increment counter
00001192  0C12 0014                171                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
00001196  6700 0004                172                  BEQ     prompt_for_data     ; At 31
0000119A  4E75                     173                  RTS                         ; Return to disassemble
0000119C                           174  
0000119C  43F9 000023EB            175  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011A2  103C 000E                176                  MOVE.B  #14,D0              ; Display message
000011A6  4E4F                     177                  TRAP    #15
000011A8  43F9 000024CC            178                  LEA     hit_enter,A1        ; Take user input
000011AE  103C 0002                179                  MOVE.B  #2,D0               
000011B2  4E4F                     180                  TRAP    #15
000011B4  14BC 0000                181                  MOVE.B  #0,(A2)             ; Reset counter
000011B8  4E75                     182                  RTS                         ; Return to disassemble
000011BA                           183  
000011BA                           184  ;------------prompt_to_rerun----------------------------------------------------
000011BA                           185  ; -- Prompt user to rerun or end program
000011BA                           186  ;------------------------------------------------------------------------------
000011BA  43F9 000023BB            187  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011C0  103C 000E                188                  MOVE.B  #14,D0
000011C4  4E4F                     189                  TRAP    #15
000011C6  43F9 000024C4            190                  LEA     ask_input,A1        ; Take user input
000011CC  103C 0002                191                  MOVE.B  #2,D0
000011D0  4E4F                     192                  TRAP    #15
000011D2  45F9 000024D4            193                  LEA     line_count,A2       ; Load line count to reset
000011D8  14BC 0000                194                  MOVE.B  #0,(A2)             ; Reset the line_count
000011DC  B23C 0001                195                  CMP.B   #1,D1               ; User input must be the length of 1
000011E0  6E00 0032                196                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
000011E4  6D00 002E                197                  BLT     rerun_err_msg       ; until the user inputs correctly.
000011E8  4240                     198                  CLR     D0                  ; Clear D0 for comparison
000011EA  1039 000024C4            199                  MOVE.B  ask_input,D0        ; Load user input for comparison
000011F0  B03C 004E                200                  CMP.B   #'N',D0             ; User input is N
000011F4  6700 002C                201                  BEQ     done                ; End of program if N
000011F8  B03C 006E                202                  CMP.B   #'n',D0             ; User input is n
000011FC  6700 0024                203                  BEQ     done                ; End of program if n
00001200  B03C 0059                204                  CMP.B   #'Y',D0             ; User input is Y
00001204  6700 FE1E                205                  BEQ     prompt_start        ; Run the program again
00001208  B03C 0079                206                  CMP.B   #'y',D0             ; User input is y
0000120C  6700 FE16                207                  BEQ     prompt_start        ; Run the program again
00001210  6000 0002                208                  BRA     rerun_err_msg       ; Bad input, prompt user
00001214                           209                  
00001214  43F9 0000247B            210  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
0000121A  103C 000E                211                  MOVE.B  #14,D0
0000121E  4E4F                     212                  TRAP    #15
00001220  6098                     213                  BRA     prompt_to_rerun     ; Prompt user for rerun           
00001222                           214                  
00001222                           215      
00001222                           216  ;------------End-of-Program----------------------------------------------------                
00001222  43F9 00002389            217  done            LEA     ending,A1           ; Load ending message
00001228  103C 000D                218                  MOVE.B  #13,D0              ; Load task code for display
0000122C  4E4F                     219                  TRAP    #15                 ; Display ending message
0000122E  4E72 2700                220                  STOP    #$00002700          ; End of program
00001232                           221                  
00001232                           222  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
00001232  4283                     223  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001234  4285                     224                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001236  B205                     225                  CMP.B   D5,D1               ; Check input length, if lower than one
00001238  6700 004E                226                  BEQ     invalid             ; Its an invalid input
0000123C  0C41 0008                227                  CMPI    #$8,D1              ; Check input length, if higher than 8
00001240  6E00 0046                228                  BGT     invalid             ; Its an invalid input
00001244                           229                  
00001244  4282                     230  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001246  1419                     231                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001248  B405                     232                  CMP.B   D5,D2               ; Check to see if next char is null(0)
0000124A  6700 0040                233                  BEQ     return              ; Character is null, end of input
0000124E                           234                  
0000124E  B43C 0046                235                  CMP.B   #70,D2              ; Invalid character if decimal value
00001252  6E00 0034                236                  BGT     invalid             ; is higher than 70.
00001256  B43C 0040                237                  CMP.B   #64,D2              ; Is a letter if decimal value is 
0000125A  6E00 001E                238                  BGT     is_letter           ; between 65 - 70.
0000125E                           239                  
0000125E  B43C 0039                240                  CMP.B   #57,D2              ; Invalid character if decimal value is
00001262  6E00 0024                241                  BGT     invalid             ; between 58 - 64
00001266  B43C 002F                242                  CMP.B   #47,D2              ; Is a number if decimal value is 
0000126A  6E00 0006                243                  BGT     is_number           ; between 48 - 57.
0000126E  6000 0018                244                  BRA     invalid             ; Decimal values below 48 are invalid 
00001272                           245                               
00001272  0402 0030                246  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
00001276  6000 000A                247                  BRA     verified            ; Put character into a register
0000127A                           248                               
0000127A  0402 0037                249  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
0000127E  6000 0002                250                  BRA     verified            ; Put character into a register
00001282                           251                 
00001282  E983                     252  verified        ASL.L   #4,D3               ; Shift hex bit left one
00001284  D602                     253                  ADD.B   D2,D3               ; Add to verified register
00001286  60BC                     254                  BRA     check_input         ; Check the rest of the input                       
00001288                           255                  
00001288  7800                     256  invalid         MOVEQ   #0,D4               ; Invalid address
0000128A  4E75                     257                  RTS                         ; Return to start/end prompt
0000128C                           258                  
0000128C  7801                     259  return          MOVEQ   #1,D4               ; Valid address
0000128E  4E75                     260                  RTS                         ; Return to start/end prompt
00001290                           261                  
00001290                           262  ;----------------------------------------------------------
00001290                           263  ; Convert Hexidecimal to ASCII (Stores into Memory)
00001290                           264  ;
00001290                           265  ; -- At the moment, takes the Illegal data and stores 
00001290                           266  ;    it into memory so that it can be printed later
00001290                           267  ;----------------------------------------------------------
00001290  4281                     268  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
00001292  4282                     269                  CLR.L   D2                      ; Used for shifting left
00001294  4283                     270                  CLR.L   D3                      ; Counter
00001296  123C 001C                271                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
0000129A                           272  hex_ASCII_loopL
0000129A  B63C 0008                273                  CMP.B   #8,D3                   ; Done converting?
0000129E  6700 0072                274                  BEQ     done_converting         ; If equal to 8, done
000012A2  2006                     275                  MOVE.L  D6,D0                   ; Do calculations in D0
000012A4  E5A8                     276                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012A6  E2A8                     277                  LSR.L   D1,D0                   ; Isolate number
000012A8  4EB9 000012F0            278                  JSR     convert_hex
000012AE  60EA                     279                  BRA     hex_ASCII_loopL
000012B0                           280                  
000012B0  4281                     281  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012B2  4282                     282                  CLR.L   D2                      ; Used for shifting left
000012B4  4283                     283                  CLR.L   D3                      ; Counter
000012B6  123C 000C                284                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012BA                           285  hex_ASCII_loopW
000012BA  B63C 0004                286                  CMP.B   #4,D3                   ; Done converting?
000012BE  6700 0052                287                  BEQ     done_converting         ; If equal to 4, done
000012C2  2006                     288                  MOVE.L  D6,D0                   ; Do calculations in D0
000012C4  E568                     289                  LSL.W   D2,D0                   ; Eliminate stuff to the left
000012C6  E268                     290                  LSR.W   D1,D0                   ; Isolate number
000012C8  4EB9 000012F0            291                  JSR     convert_hex
000012CE  60EA                     292                  BRA     hex_ASCII_loopW
000012D0                           293  
000012D0  4281                     294  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
000012D2  4282                     295                  CLR.L   D2                      ; Used for shifting left
000012D4  4283                     296                  CLR.L   D3                      ; Counter
000012D6  123C 0004                297                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
000012DA                           298  hex_ASCII_loopB
000012DA  B63C 0002                299                  CMP.B   #2,D3                   ; Done converting?
000012DE  6700 0032                300                  BEQ     done_converting         ; If equal to 2, done
000012E2  2006                     301                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E4  E528                     302                  LSL.B   D2,D0                   ; Eliminate stuff to the left
000012E6  E228                     303                  LSR.B   D1,D0                   ; Isolate number
000012E8  4EB9 000012F0            304                  JSR     convert_hex
000012EE  60EA                     305                  BRA     hex_ASCII_loopB                  
000012F0                           306  
000012F0  B03C 000A                307  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
000012F4  6D00 0006                308                  BLT     make_number             ; Make it a number, if lower than 10
000012F8  6C00 000E                309                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
000012FC                           310                       
000012FC  0600 0030                311  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
00001300  1CC0                     312                  MOVE.B  D0,(A6)+                ; Store in memory
00001302  5203                     313                  ADD.B   #1,D3                   ; Add to counter
00001304  5802                     314                  ADD.B   #4,D2                   ; Shift left by one digit
00001306  4E75                     315                  RTS                             ; Check next number
00001308                           316                  
00001308  0600 0037                317  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
0000130C  1CC0                     318                  MOVE.B  D0,(A6)+                ; Store to memory
0000130E  5203                     319                  ADD.B   #1,D3                   ; Add to counter
00001310  5802                     320                  ADD.B   #4,D2                   ; Shift left by one digit                 
00001312  4E75                     321  done_converting RTS                             ; Check next number              
00001314                           322  
00001314                           323  ;-----------Error Messages ----------------------------------------------------
00001314  4EB9 00001328            324  start_error     JSR     load_bad_input      ; Print bad input error message
0000131A  4EF8 1024                325                  JMP     prompt_start        ; Return to prompt for start address
0000131E                           326                  
0000131E  4EB9 00001328            327  end_error       JSR     load_bad_input      ; Print bad input error message
00001324  4EF8 107A                328                  JMP     prompt_end          ; Return to prompt for end address
00001328                           329  
00001328  43F9 00002419            330  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000132E  103C 000D                331                  MOVE.B  #13,D0              ; Load task code for display
00001332  4E4F                     332                  TRAP    #15                 ; Display bad input message
00001334  4E75                     333                  RTS                         ; Return to (start/end)_error
00001336                           334  
00001336  4282                     335  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001338  3403                     336                  MOVE.W  D3,D2               ; Put address in D2 for calulation
0000133A  7202                     337                  MOVE.L  #2,D1               ; Load 2 into D1 for division
0000133C  84C1                     338                  DIVU    D1,D2               ; Divide address by 2
0000133E  4842                     339                  SWAP    D2                  ; Swap contents of D2 to get remainder
00001340  B43C 0001                340                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001344  6700 0004                341                  BEQ     odd_err             ; Go to print out odd bound error message
00001348  4E75                     342                  RTS                         ; Return to valid_(start/end)
0000134A                           343                  
0000134A  43F9 0000244F            344  odd_err         LEA     odd_input,A1        ; Load odd input message
00001350  103C 000E                345                  MOVE.B  #14,D0              ; Load task code for display
00001354  4E4F                     346                  TRAP    #15                 ; Display odd input message
00001356  4685                     347                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001358  2605                     348                  MOVE.L  D5,D3               ; Load -1 to returned data register
0000135A  4E75                     349                  RTS                         ; Return to valid_(start/end)
0000135C                           350  
0000135C                           351  OP_CODE_TREE    ; Parses the Op-Code to find what it is
0000135C                           352          
0000135C  B8BC 00004E75            353          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
00001362  6700 04B0                354          Beq     OP_RTS
00001366                           355  
00001366  4EB9 00002134            356          Jsr     GET12TO15
0000136C                           357          
0000136C  B03C 0000                358          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
00001370  6700 0066                359          Beq     IMMEDIATE_BTST
00001374                           360          
00001374  B03C 0001                361          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
00001378  6700 0230                362          Beq     OP_MOVE
0000137C                           363          
0000137C  B03C 0003                364          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
00001380  6700 0228                365          Beq     OP_MOVE
00001384                           366  
00001384  B03C 0002                367          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
00001388  6700 0220                368          Beq     OP_MOVE
0000138C                           369          
0000138C  B03C 0004                370          Cmp.B     #%0100, D0       ; not enough info, Single OPs
00001390  6700 008C                371          Beq     SINGLE_OPERATOR_CODES
00001394                           372      
00001394  B03C 0006                373          Cmp.B     #%0110, D0       ; Beqnch conditionals
00001398  6700 00D6                374          Beq     BRANCH_CONDITIONALS
0000139C                           375          
0000139C  B03C 000C                376          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013A0  6700 0150                377          Beq     AND_MULS
000013A4                           378          
000013A4  B03C 000E                379          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013A8  6700 0188                380          Beq     BIT_SHIFT
000013AC                           381          
000013AC  B03C 0005                382          Cmp.B     #%0101, D0       ; Add Quick
000013B0  6700 0244                383          Beq     OP_ADDQ
000013B4                           384          
000013B4  B03C 0008                385          Cmp.B     #%1000, D0       ; Signed Divide
000013B8  6700 0278                386          Beq     OP_DIVS
000013BC                           387          
000013BC  B03C 0009                388          Cmp.B     #%1001, D0       ; Sub & SubA
000013C0  6700 02A0                389          Beq     OP_SUB
000013C4                           390          
000013C4  B03C 000B                391          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
000013C8  6700 01BE                392          Beq     CMP_EOR
000013CC                           393          
000013CC  B03C 000D                394          Cmp.B     #%1101, D0       ; Add & AddA
000013D0  6700 02CE                395          Beq     OP_ADD
000013D4                           396          
000013D4  6000 06EC                397          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
000013D8                           398          
000013D8                           399  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
000013D8                           400          
000013D8  4EB9 00002176            401          Jsr     GET6TO8         ; Change out test bits
000013DE                           402          
000013DE  B03C 0004                403          Cmp.B     #%100, D0          ; Bit test
000013E2  6700 02FA                404          Beq     OP_BTST
000013E6                           405          
000013E6  4EB9 0000225C            406          Jsr     GET6TO11
000013EC                           407          
000013EC  B03C 0020                408          Cmp.B   #%100000,D0     ;BTST
000013F0  6700 02EC                409          Beq     OP_BTST
000013F4                           410          
000013F4  4EB9 00002164            411          Jsr     GET9TO11        ; Change out test bits
000013FA                           412          
000013FA  B03C 0000                413          Cmp.B     #%000, D0        ; Or I
000013FE  6700 02F8                414          Beq     OP_ORI
00001402                           415          
00001402  B03C 0002                416          Cmp.B     #%010, D0        ; Subtract I
00001406  6700 030C                417          Beq     OP_SUBI
0000140A                           418          
0000140A  B03C 0005                419          Cmp.B     #%101, D0        ; Exclusive or, I
0000140E  6700 0324                420          Beq     OP_EORI
00001412                           421          
00001412  B03C 0006                422          Cmp.B     #%110, D0        ; Compare I
00001416  6700 033C                423          Beq     OP_CMPI
0000141A                           424          
0000141A  6000 06A6                425          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
0000141E                           426          
0000141E                           427  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
0000141E                           428  
0000141E  4EB9 000021AC            429          Jsr     GETBIT8        ; Change out test bits
00001424                           430          
00001424  B03C 0001                431          Cmp.B     #%1, D0      ; Load effetive address
00001428  6700 034A                432          Beq     OP_LEA
0000142C                           433                  
0000142C  4EB9 00002164            434          Jsr     GET9TO11       ; Change out test bits        
00001432                           435  
00001432  B03C 0002                436          Cmp.B     #%010, D0    ; Negate
00001436  6700 0352                437          Beq     OP_NEG
0000143A                           438         
0000143A  B03C 0003                439          Cmp.B     #%011, D0    ; Not
0000143E  6700 0366                440          Beq     OP_NOT
00001442                           441          
00001442  B03C 0004                442          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001446  6700 037A                443          Beq     OP_MOVEM
0000144A                           444          
0000144A  B03C 0006                445          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
0000144E  6700 0372                446          Beq     OP_MOVEM
00001452                           447          
00001452  B03C 0007                448          Cmp.B     #%111, D0    ; JSR
00001456  6700 0006                449          Beq     JSR_CHECK   ; A second check for JSR   
0000145A                           450          
0000145A  6000 0666                451          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
0000145E                           452  
0000145E                           453  JSR_CHECK     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
0000145E                           454  
0000145E  4EB9 00002176            455          Jsr     GET6TO8        ; Change out test bits
00001464                           456          
00001464  B03C 0002                457          Cmp.B     #%010, D0    ; Jump to Subroutine
00001468  6700 03BE                458          Beq     OP_JSR
0000146C                           459          
0000146C  6000 0654                460          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
00001470                           461  
00001470                           462  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
00001470                           463  
00001470  4EB9 00002152            464          Jsr     GET8TO11    ; Change out test bits        
00001476                           465  
00001476  B03C 0000                466          Cmp.B     #%0000, D0   ; Branch
0000147A  6700 03C2                467          Beq     OP_BRANCH      
0000147E                           468          
0000147E  B03C 0002                469          Cmp.B     #%0010, D0   ; High
00001482  6700 03D0                470          Beq     OP_BRA_HIGH
00001486                           471          
00001486  B03C 0003                472          Cmp.B     #%0011, D0   ; Low/same
0000148A  6700 03DE                473          Beq     OP_BRA_LOW
0000148E                           474          
0000148E  B03C 0004                475          Cmp.B     #%0100, D0   ; Carry Clear
00001492  6700 03EC                476          Beq     OP_BRA_CC
00001496                           477          
00001496  B03C 0005                478          Cmp.B     #%0101, D0   ; Carry Set
0000149A  6700 03FA                479          Beq     OP_BRA_CS
0000149E                           480          
0000149E  B03C 0006                481          Cmp.B     #%0110, D0   ; Not Equal
000014A2  6700 0408                482          Beq     OP_BRA_NE
000014A6                           483          
000014A6  B03C 0007                484          Cmp.B     #%0111, D0   ; Equal
000014AA  6700 0416                485          Beq     OP_BRA_EQ
000014AE                           486          
000014AE  B03C 0008                487          Cmp.B     #%1000, D0   ; Overflow Clear
000014B2  6700 0424                488          Beq     OP_BRA_VC
000014B6                           489          
000014B6  B03C 0009                490          Cmp.B     #%1001, D0   ; Overflow Set
000014BA  6700 0432                491          Beq     OP_BRA_VS
000014BE                           492          
000014BE  B03C 000A                493          Cmp.B     #%1010, D0   ; Plus
000014C2  6700 0440                494          Beq     OP_BRA_PL
000014C6                           495          
000014C6  B03C 000B                496          Cmp.B     #%1011, D0   ; Minus
000014CA  6700 044E                497          Beq     OP_BRA_MI
000014CE                           498          
000014CE  B03C 000C                499          Cmp.B     #%1100, D0   ; Greater than or Equal
000014D2  6700 045C                500          Beq     OP_BRA_GE
000014D6                           501          
000014D6  B03C 000D                502          Cmp.B     #%1101, D0   ; Less Than
000014DA  6700 046A                503          Beq     OP_BRA_LT
000014DE                           504          
000014DE  B03C 000E                505          Cmp.B     #%1110, D0   ; Greater Than
000014E2  6700 0478                506          Beq     OP_BRA_GT
000014E6                           507          
000014E6  B03C 000F                508          Cmp.B     #%1111, D0   ; Less than or Equal
000014EA  6700 0486                509          Beq     OP_BRA_LE
000014EE                           510          
000014EE  6000 05D2                511          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
000014F2                           512  
000014F2                           513  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
000014F2                           514  
000014F2  4EB9 0000224A            515          Jsr     Get3TO8
000014F8                           516          
000014F8  B03C 0021                517          Cmp.B     #%100001, D0   ; ABCD
000014FC  6700 05C4                518          Beq     OP_SET_BAD_BUFFER        
00001500  B03C 0020                519          Cmp.B     #%100000,D0    ; ABCD
00001504  6700 05BC                520          Beq     OP_SET_BAD_BUFFER        
00001508  B03C 0028                521          Cmp.B     #%101000,D0    ; EXG
0000150C  6700 05B4                522          Beq     OP_SET_BAD_BUFFER
00001510  B03C 0029                523          Cmp.B     #%101001,D0    ; EXG
00001514  6700 05AC                524          Beq     OP_SET_BAD_BUFFER
00001518  B03C 0031                525          Cmp.B     #%110001,D0    ; EXG
0000151C  6700 FC3A                526          Beq     ILLEGAL        
00001520                           527  
00001520  4EB9 00002176            528          Jsr     GET6TO8        ; Change out test bits        
00001526                           529  
00001526  B03C 0007                530          Cmp.B     #%111, D0    ; Multiply signed
0000152A  6700 045C                531          Beq     OP_MULS
0000152E                           532          
0000152E  6000 047A                533          Bra     OP_AND      ; Probably AND, check more in OP_AND
00001532                           534          
00001532                           535  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
00001532                           536          
00001532                           537          ; Determine if the shift is Register or Memory shifting
00001532                           538          
00001532  4EB9 000021D0            539          Jsr     GET6AND7
00001538                           540          
00001538  B03C 0003                541          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
0000153C  6700 0006                542          Beq     BIT_SHIFT_MEM
00001540                           543  
00001540  6000 0024                544          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
00001544                           545  
00001544                           546  BIT_SHIFT_MEM
00001544                           547          
00001544  4EB9 000021BE            548          Jsr     GET9AND10         ; Change out test bits
0000154A                           549          
0000154A  B03C 0000                550          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
0000154E  6700 0494                551          Beq     OP_AS_MEM
00001552                           552          
00001552  B03C 0001                553          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001556  6700 04C2                554          Beq     OP_LS_MEM
0000155A                           555          
0000155A  B03C 0003                556          Cmp.B     #%11, D0        ; Rotate (Left or Right)
0000155E  6700 04F0                557          Beq     OP_RO_MEM
00001562                           558          
00001562  6000 055E                559          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001566                           560  
00001566                           561  BIT_SHIFT_REG
00001566                           562          
00001566  4EB9 000021F4            563          Jsr     GET3AND4        ; Change out test bits
0000156C                           564          
0000156C  B03C 0000                565          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001570  6700 0454                566          Beq     OP_AS_REG
00001574                           567          
00001574  B03C 0001                568          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001578  6700 0482                569          Beq     OP_LS_REG
0000157C                           570          
0000157C  B03C 0003                571          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001580  6700 04B0                572          Beq     OP_RO_REG
00001584                           573          
00001584  6000 053C                574          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001588                           575  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
00001588                           576          
00001588  4EB9 00002176            577          Jsr     GET6TO8         ; Change out test bits
0000158E                           578          
0000158E  B03C 0004                579          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
00001592  6700 0512                580          Beq     OP_EOR
00001596                           581          
00001596  B03C 0005                582          Cmp.B     #%101,D0
0000159A  6700 050A                583          Beq     OP_EOR
0000159E                           584          
0000159E  B03C 0006                585          Cmp.B     #%110,D0
000015A2  6700 0502                586          Beq     OP_EOR
000015A6                           587          
000015A6                           588          
000015A6  6000 04C0                589          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015AA                           590  
000015AA                           591  ;---------------------OP_CODE Functions---------------------;
000015AA                           592  ; These Functions have all determined what Op-code or group
000015AA                           593  ; of op-codes I have. The next goal is to Add to the string
000015AA                           594  ; and call the accompying EA function to get the rest of the
000015AA                           595  ; String
000015AA                           596  
000015AA                           597  ; REGISTERS USED: D0, D4 (const), A6
000015AA                           598  
000015AA                           599  ;-----------------------  MOVE  -----------------------------;
000015AA                           600  OP_MOVE
000015AA                           601      ; start string
000015AA                           602      
000015AA  1CFC 004D                603          Move.B  #'M', (A6)+
000015AE  1CFC 004F                604          Move.B  #'O', (A6)+
000015B2  1CFC 0056                605          Move.B  #'V', (A6)+
000015B6  1CFC 0045                606          Move.B  #'E', (A6)+
000015BA                           607      
000015BA                           608      ; is it an address move?
000015BA  4EB9 00002176            609          Jsr     GET6TO8     ; Get the mode
000015C0  4EB9 00001ADC            610          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
000015C6                           611          
000015C6                           612      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
000015C6                           613      ; But move does not use the Op-mode bits, so i'll do it manually
000015C6                           614      
000015C6  4EB9 00002134            615          Jsr     GET12TO15
000015CC                           616  
000015CC                           617          ; Jump to a sub routine to get the data, so it returns back correctly
000015CC  4EB9 000015DC            618          Jsr     OP_MOVE_DATA
000015D2                           619          
000015D2                           620          ; Put in tabs
000015D2  4EB9 00001AC8            621          Jsr     OP_TAB
000015D8                           622          
000015D8                           623          ; Hand the function off to John
000015D8  6000 0580                624          BRA     EA_MOVE        
000015DC                           625  
000015DC                           626  OP_MOVE_DATA
000015DC                           627          
000015DC  B07C 0001                628          Cmp     #%0001, D0
000015E0  6700 053C                629          Beq     OP_SET_DATA_BYTE
000015E4                           630          
000015E4  B07C 0002                631          Cmp     #%0010, D0
000015E8  6700 0548                632          Beq     OP_SET_DATA_LONG
000015EC                           633          
000015EC  B07C 0003                634          Cmp     #%0011, D0
000015F0  6700 0536                635          Beq     OP_SET_DATA_WORD
000015F4                           636          
000015F4  4E75                     637          Rts
000015F6                           638  
000015F6                           639  ;-----------------------  ADDQ  -----------------------------;
000015F6                           640          
000015F6                           641  OP_ADDQ
000015F6                           642      ; Check fringe cases
000015F6  4EB9 000021AC            643          Jsr     GETBIT8
000015FC  B03C 0001                644          Cmp.B   #%1,D0
00001600  6700 04C0                645          Beq     OP_SET_BAD_BUFFER        
00001604  4EB9 000021D0            646          Jsr     GET6AND7
0000160A  B03C 0003                647          Cmp.B   #%11,D0
0000160E  6700 04B2                648          Beq     OP_SET_BAD_BUFFER       
00001612                           649  
00001612                           650      ; start string
00001612                           651      
00001612  1CFC 0041                652          Move.B  #'A', (A6)+
00001616  1CFC 0044                653          Move.B  #'D', (A6)+
0000161A  1CFC 0044                654          Move.B  #'D', (A6)+
0000161E  1CFC 0051                655          Move.B  #'Q', (A6)+
00001622                           656          
00001622                           657      ; Check data type        
00001622  4EB9 00001AEC            658          Jsr     OP_CHECK_DATA_SIZE
00001628                           659          
00001628                           660      ; Put in tabs
00001628  4EB9 00001AC8            661          Jsr     OP_TAB
0000162E                           662          
0000162E                           663      ; Hand the function off to John
0000162E  6000 082A                664          BRA     EA_ADDQ
00001632                           665  
00001632                           666      
00001632                           667  ;------------------  DIVIDE SINGED  -------------------------;
00001632                           668      
00001632                           669  OP_DIVS
00001632                           670      ; One last check to make sure I have the right stuff
00001632                           671      
00001632  4EB9 00002176            672          Jsr     GET6TO8
00001638  B07C 0007                673          Cmp     #%111,D0
0000163C  6600 0484                674          Bne     OP_SET_BAD_BUFFER
00001640                           675          
00001640                           676      ; start string
00001640                           677      
00001640  1CFC 0044                678          Move.B  #'D', (A6)+
00001644  1CFC 0049                679          Move.B  #'I', (A6)+
00001648  1CFC 0056                680          Move.B  #'V', (A6)+
0000164C  1CFC 0053                681          Move.B  #'S', (A6)+
00001650  1CFC 002E                682          Move.B  #'.', (A6)+
00001654  1CFC 0057                683          Move.B  #'W', (A6)+
00001658                           684          
00001658                           685      ; Put in tabs
00001658  4EB9 00001AC8            686          Jsr     OP_TAB    
0000165E                           687      
0000165E                           688      ; Handoff to John
0000165E                           689          
0000165E  6000 093A                690          BRA     EA_DIVS
00001662                           691  
00001662                           692      
00001662                           693  ;-----------------------  SUB  ------------------------------;    
00001662                           694      
00001662                           695  OP_SUB
00001662                           696      ; start string
00001662                           697      
00001662  1CFC 0053                698          Move.B  #'S', (A6)+
00001666  1CFC 0055                699          Move.B  #'U', (A6)+
0000166A  1CFC 0042                700          Move.B  #'B', (A6)+
0000166E                           701  
0000166E                           702  
0000166E                           703       ; Check for address version
0000166E                           704          
0000166E  4EB9 000021D0            705          Jsr     GET6AND7
00001674  B03C 0003                706          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001678                           707          
00001678  6700 0012                708          Beq     OP_SUB_ADDR
0000167C                           709  
0000167C                           710          ; Don't need to worry about ADDA in V1
0000167C                           711          ; Check data size
0000167C  4EB9 00001AEC            712          Jsr     OP_CHECK_DATA_SIZE
00001682                           713          
00001682                           714          ; Put in tabs
00001682  4EB9 00001AC8            715          Jsr     OP_TAB
00001688                           716          
00001688  6000 080E                717          BRA     EA_SUB 
0000168C                           718          
0000168C                           719  OP_SUB_ADDR
0000168C                           720          
0000168C  1CFC 0041                721          Move.B  #'A',(A6)+ ; add to the string
00001690                           722          
00001690                           723          ; Find data size
00001690                           724          
00001690  4EB9 00001B0C            725          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001696                           726          
00001696                           727          ; Put in tabs
00001696  4EB9 00001AC8            728          Jsr     OP_TAB
0000169C                           729          
0000169C                           730          ; Handoff
0000169C  6000 07FA                731          BRA     EA_SUB
000016A0                           732          
000016A0                           733  ;-----------------------  ADD  ------------------------------;
000016A0                           734  
000016A0                           735  OP_ADD
000016A0                           736      ; start string
000016A0                           737      
000016A0  1CFC 0041                738          Move.B  #'A', (A6)+
000016A4  1CFC 0044                739          Move.B  #'D', (A6)+
000016A8  1CFC 0044                740          Move.B  #'D', (A6)+
000016AC                           741  
000016AC                           742      ; Check for address version
000016AC                           743          
000016AC  4EB9 000021D0            744          Jsr     GET6AND7
000016B2  B03C 0003                745          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016B6                           746          
000016B6  6700 0012                747          Beq     OP_ADD_ADDR
000016BA                           748          
000016BA                           749          ; Don't need to worry about ADDA in V1
000016BA                           750          ; Check data size
000016BA  4EB9 00001AEC            751          Jsr     OP_CHECK_DATA_SIZE
000016C0                           752          
000016C0                           753          ; Put in tabs
000016C0  4EB9 00001AC8            754          Jsr     OP_TAB
000016C6                           755          
000016C6  6000 06D6                756          BRA     EA_ADD
000016CA                           757          
000016CA                           758  OP_ADD_ADDR
000016CA                           759          
000016CA  1CFC 0041                760          Move.B  #'A',(A6)+ ; add to the string
000016CE                           761          
000016CE                           762          ; Find data size
000016CE                           763          
000016CE  4EB9 00001B0C            764          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016D4                           765          
000016D4                           766          ; Put in tabs
000016D4  4EB9 00001AC8            767          Jsr     OP_TAB
000016DA                           768          
000016DA                           769          ; Handoff
000016DA  6000 06F6                770          BRA     EA_ADDA
000016DE                           771  
000016DE                           772  ;------------------------  BTST -----------------------------;
000016DE                           773  
000016DE                           774  OP_BTST
000016DE                           775      ; start string
000016DE                           776      
000016DE  1CFC 0042                777          Move.B  #'B', (A6)+
000016E2  1CFC 0054                778          Move.B  #'T', (A6)+
000016E6  1CFC 0053                779          Move.B  #'S', (A6)+
000016EA  1CFC 0054                780          Move.B  #'T', (A6)+
000016EE                           781          
000016EE                           782      ; Btst has data sizes, but they are implicit based on mode
000016EE                           783          
000016EE                           784      ; Put in tabs
000016EE  4EB9 00001AC8            785          Jsr     OP_TAB
000016F4                           786          
000016F4                           787      ; Hand the function off to John
000016F4  6000 08A8                788          BRA     EA_BTST
000016F8                           789  
000016F8                           790  
000016F8                           791  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
000016F8                           792  
000016F8                           793  ;------------------------  ORI  -----------------------------;
000016F8                           794      
000016F8                           795  OP_ORI
000016F8                           796      ; start string
000016F8                           797      
000016F8  1CFC 004F                798          Move.B  #'O', (A6)+
000016FC  1CFC 0052                799          Move.B  #'R', (A6)+
00001700  1CFC 0049                800          Move.B  #'I', (A6)+
00001704                           801          
00001704                           802      ; Check data type        
00001704  4EB9 00001AEC            803          Jsr     OP_CHECK_DATA_SIZE
0000170A                           804          
0000170A                           805      ; Put in tabs
0000170A  4EB9 00001AC8            806          Jsr     OP_TAB
00001710                           807          
00001710                           808      ; Hand the function off to John
00001710  6000 0828                809          BRA     EA_IMMEDIATE
00001714                           810  
00001714                           811  ;-----------------------  SUBI  -----------------------------;
00001714                           812  
00001714                           813  OP_SUBI
00001714                           814      ; start string
00001714                           815      
00001714  1CFC 0053                816          Move.B  #'S', (A6)+
00001718  1CFC 0055                817          Move.B  #'U', (A6)+
0000171C  1CFC 0042                818          Move.B  #'B', (A6)+
00001720  1CFC 0049                819          Move.B  #'I', (A6)+
00001724                           820          
00001724                           821      ; Check data type        
00001724  4EB9 00001AEC            822          Jsr     OP_CHECK_DATA_SIZE
0000172A                           823          
0000172A                           824      ; Put in tabs
0000172A  4EB9 00001AC8            825          Jsr     OP_TAB
00001730                           826          
00001730                           827      ; Hand the function off to John
00001730  6000 0808                828          BRA     EA_IMMEDIATE  
00001734                           829          
00001734                           830  ;-----------------------  EORI  -----------------------------;        
00001734                           831          
00001734                           832  OP_EORI
00001734                           833      ; start string
00001734                           834      
00001734  1CFC 0045                835          Move.B  #'E', (A6)+
00001738  1CFC 004F                836          Move.B  #'O', (A6)+
0000173C  1CFC 0052                837          Move.B  #'R', (A6)+
00001740  1CFC 0049                838          Move.B  #'I', (A6)+
00001744                           839          
00001744                           840      ; Check data type        
00001744  4EB9 00001AEC            841          Jsr     OP_CHECK_DATA_SIZE
0000174A                           842          
0000174A                           843      ; Put in tabs
0000174A  4EB9 00001AC8            844          Jsr     OP_TAB
00001750                           845          
00001750                           846      ; Hand the function off to John
00001750  6000 07E8                847          BRA     EA_IMMEDIATE  
00001754                           848          
00001754                           849  ;-----------------------  CMPI  -----------------------------;        
00001754                           850          
00001754                           851  OP_CMPI
00001754                           852      ; start string
00001754                           853      
00001754  1CFC 0043                854          Move.B  #'C', (A6)+
00001758  1CFC 004D                855          Move.B  #'M', (A6)+
0000175C  1CFC 0050                856          Move.B  #'P', (A6)+
00001760  1CFC 0049                857          Move.B  #'I', (A6)+
00001764                           858          
00001764                           859      ; Check data type        
00001764  4EB9 00001AEC            860          Jsr     OP_CHECK_DATA_SIZE
0000176A                           861          
0000176A                           862      ; Put in tabs
0000176A  4EB9 00001AC8            863          Jsr     OP_TAB
00001770                           864          
00001770                           865      ; Hand the function off to John
00001770  6000 07C8                866          BRA     EA_IMMEDIATE  
00001774                           867          
00001774                           868  ;-----------------------  LEA  ------------------------------;
00001774                           869  
00001774                           870  OP_LEA
00001774                           871      ; start string
00001774                           872      
00001774  1CFC 004C                873          Move.B  #'L', (A6)+
00001778  1CFC 0045                874          Move.B  #'E', (A6)+
0000177C  1CFC 0041                875          Move.B  #'A', (A6)+
00001780                           876          
00001780                           877      ; No data size for LEA
00001780                           878          
00001780                           879      ; Put in tabs
00001780  4EB9 00001AC8            880          Jsr     OP_TAB
00001786                           881          
00001786                           882      ; Hand the function off to John
00001786  6000 0718                883          BRA     EA_LEA  
0000178A                           884  
0000178A                           885  ;-----------------------  NEG  ------------------------------;
0000178A                           886  
0000178A                           887  OP_NEG
0000178A                           888      ; start string
0000178A                           889      
0000178A  1CFC 004E                890          Move.B  #'N', (A6)+
0000178E  1CFC 0045                891          Move.B  #'E', (A6)+
00001792  1CFC 0047                892          Move.B  #'G', (A6)+
00001796                           893          
00001796                           894      ; Data size
00001796  4EB9 00001AEC            895          Jsr     OP_CHECK_DATA_SIZE
0000179C                           896          
0000179C                           897      ; Put in tabs
0000179C  4EB9 00001AC8            898          Jsr     OP_TAB
000017A2                           899          
000017A2                           900      ; Hand the function off to John
000017A2  6000 0708                901          BRA     EA_NEG  
000017A6                           902  
000017A6                           903      
000017A6                           904  ;-----------------------  NOT  ------------------------------;    
000017A6                           905      
000017A6                           906  OP_NOT
000017A6                           907      ; start string
000017A6                           908      
000017A6  1CFC 004E                909          Move.B  #'N', (A6)+
000017AA  1CFC 004F                910          Move.B  #'O', (A6)+
000017AE  1CFC 0054                911          Move.B  #'T', (A6)+
000017B2                           912          
000017B2                           913      ; Data size
000017B2  4EB9 00001AEC            914          Jsr     OP_CHECK_DATA_SIZE
000017B8                           915          
000017B8                           916      ; Put in tabs
000017B8  4EB9 00001AC8            917          Jsr     OP_TAB
000017BE                           918          
000017BE                           919      ; Hand the function off to John
000017BE  6000 06F4                920          BRA     EA_NOT
000017C2                           921  
000017C2                           922  ;-------------------  MOVE MULITPLE  ------------------------;
000017C2                           923          
000017C2                           924  OP_MOVEM
000017C2                           925      ; Exception checks
000017C2  4EB9 000021E2            926          Jsr     GET7AND8
000017C8  B03C 0001                927          Cmp.B   #%01,D0
000017CC  6600 02F4                928          Bne     OP_SET_BAD_BUFFER
000017D0                           929          
000017D0  4EB9 00002188            930          Jsr     GET3TO5
000017D6  B03C 0000                931          Cmp.B   #%000,D0
000017DA  6700 02E6                932          Beq     OP_SET_BAD_BUFFER
000017DE                           933  
000017DE                           934      ; start string
000017DE                           935      
000017DE  1CFC 004D                936          Move.B  #'M', (A6)+
000017E2  1CFC 004F                937          Move.B  #'O', (A6)+
000017E6  1CFC 0056                938          Move.B  #'V', (A6)+
000017EA  1CFC 0045                939          Move.B  #'E', (A6)+
000017EE  1CFC 004D                940          Move.B  #'M', (A6)+        
000017F2                           941  
000017F2                           942      ; Data size has to be checked manually
000017F2  4EB9 00001802            943          Jsr     OP_MOVEM_DATA
000017F8                           944          
000017F8                           945      ; Put in tabs
000017F8  4EB9 00001AC8            946          Jsr     OP_TAB
000017FE                           947          
000017FE                           948      ; Hand the function off to John
000017FE  6000 03E4                949          BRA     EA_MOVEM
00001802                           950          
00001802                           951  OP_MOVEM_DATA
00001802                           952      ; get the size bit
00001802  4EB9 000021D0            953          Jsr     GET6AND7
00001808                           954          
00001808  B03C 0002                955          Cmp.B   #%10,D0
0000180C  6700 031A                956          Beq     OP_SET_DATA_WORD
00001810                           957          
00001810  6000 0320                958          Bra     OP_SET_DATA_LONG   
00001814                           959  
00001814                           960  OP_RTS
00001814                           961      ; start string
00001814                           962      
00001814  1CFC 0052                963          Move.B  #'R', (A6)+
00001818  1CFC 0054                964          Move.B  #'T', (A6)+
0000181C  1CFC 0053                965          Move.B  #'S', (A6)+
00001820                           966  
00001820                           967      ; Put in tabs
00001820  4EB9 00001AC8            968          Jsr     OP_TAB
00001826                           969  
00001826                           970      ; Handoff to Blong
00001826                           971      
00001826  4E75                     972          Rts
00001828                           973          
00001828                           974  ;-----------------------  JSR  ------------------------------;        
00001828                           975          
00001828                           976  OP_JSR
00001828                           977      ; start string
00001828                           978      
00001828  1CFC 004A                979          Move.B  #'J', (A6)+
0000182C  1CFC 0053                980          Move.B  #'S', (A6)+
00001830  1CFC 0052                981          Move.B  #'R', (A6)+
00001834                           982          
00001834                           983      ; No data size
00001834                           984          
00001834                           985      ; Put in tabs
00001834  4EB9 00001AC8            986          Jsr     OP_TAB
0000183A                           987          
0000183A                           988      ; Hand the function off to John
0000183A  6000 067C                989          BRA     EA_JSR
0000183E                           990  
0000183E                           991  ;------------------  BRANCH CONDITIONALS  ------------------------;
0000183E                           992  
0000183E                           993  OP_BRANCH
0000183E                           994      ; start string
0000183E                           995      
0000183E  1CFC 0042                996          Move.B  #'B', (A6)+
00001842  1CFC 0052                997          Move.B  #'R', (A6)+
00001846  1CFC 0041                998          Move.B  #'A', (A6)+
0000184A                           999  
0000184A                          1000      ; Put in tabs
0000184A  4EB9 00001AC8           1001          Jsr     OP_TAB
00001850                          1002  
00001850                          1003      ; Handoff to John
00001850                          1004      
00001850  6000 0796               1005          BRA     EA_BRANCH
00001854                          1006      
00001854                          1007  OP_BRA_HIGH
00001854                          1008      ; start string
00001854                          1009      
00001854  1CFC 0042               1010          Move.B  #'B', (A6)+
00001858  1CFC 0048               1011          Move.B  #'H', (A6)+
0000185C  1CFC 0049               1012          Move.B  #'I', (A6)+
00001860                          1013  
00001860                          1014      ; Put in tabs
00001860  4EB9 00001AC8           1015          Jsr     OP_TAB
00001866                          1016  
00001866                          1017      ; Handoff to John
00001866                          1018      
00001866  6000 0780               1019          BRA     EA_BRANCH
0000186A                          1020      
0000186A                          1021  OP_BRA_LOW
0000186A                          1022      ; start string
0000186A                          1023      
0000186A  1CFC 0042               1024          Move.B  #'B', (A6)+
0000186E  1CFC 004C               1025          Move.B  #'L', (A6)+
00001872  1CFC 0053               1026          Move.B  #'S', (A6)+
00001876                          1027  
00001876                          1028      ; Put in tabs
00001876  4EB9 00001AC8           1029          Jsr     OP_TAB
0000187C                          1030  
0000187C                          1031      ; Handoff to John
0000187C                          1032      
0000187C  6000 076A               1033          BRA     EA_BRANCH
00001880                          1034      
00001880                          1035  OP_BRA_CC
00001880                          1036      ; start string
00001880                          1037      
00001880  1CFC 0042               1038          Move.B  #'B', (A6)+
00001884  1CFC 0043               1039          Move.B  #'C', (A6)+
00001888  1CFC 0043               1040          Move.B  #'C', (A6)+
0000188C                          1041  
0000188C                          1042      ; Put in tabs
0000188C  4EB9 00001AC8           1043          Jsr     OP_TAB
00001892                          1044  
00001892                          1045      ; Handoff to John
00001892                          1046      
00001892  6000 0754               1047          BRA     EA_BRANCH
00001896                          1048  
00001896                          1049  OP_BRA_CS
00001896                          1050      ; start string
00001896                          1051      
00001896  1CFC 0042               1052          Move.B  #'B', (A6)+
0000189A  1CFC 0043               1053          Move.B  #'C', (A6)+
0000189E  1CFC 0053               1054          Move.B  #'S', (A6)+
000018A2                          1055  
000018A2                          1056      ; Put in tabs
000018A2  4EB9 00001AC8           1057          Jsr     OP_TAB
000018A8                          1058  
000018A8                          1059      ; Handoff to John
000018A8                          1060      
000018A8  6000 073E               1061          BRA     EA_BRANCH
000018AC                          1062  
000018AC                          1063  OP_BRA_NE
000018AC                          1064      ; start string
000018AC                          1065      
000018AC  1CFC 0042               1066          Move.B  #'B', (A6)+
000018B0  1CFC 004E               1067          Move.B  #'N', (A6)+
000018B4  1CFC 0045               1068          Move.B  #'E', (A6)+
000018B8                          1069  
000018B8                          1070      ; Put in tabs
000018B8  4EB9 00001AC8           1071          Jsr     OP_TAB
000018BE                          1072  
000018BE                          1073      ; Handoff to John
000018BE                          1074      
000018BE  6000 0728               1075          BRA     EA_BRANCH
000018C2                          1076  
000018C2                          1077  OP_BRA_EQ
000018C2                          1078      ; start string
000018C2                          1079      
000018C2  1CFC 0042               1080          Move.B  #'B', (A6)+
000018C6  1CFC 0045               1081          Move.B  #'E', (A6)+
000018CA  1CFC 0051               1082          Move.B  #'Q', (A6)+
000018CE                          1083  
000018CE                          1084      ; Put in tabs
000018CE  4EB9 00001AC8           1085          Jsr     OP_TAB
000018D4                          1086  
000018D4                          1087      ; Handoff to John
000018D4                          1088      
000018D4  6000 0712               1089          BRA     EA_BRANCH
000018D8                          1090  
000018D8                          1091  OP_BRA_VC
000018D8                          1092      ; start string
000018D8                          1093      
000018D8  1CFC 0042               1094          Move.B  #'B', (A6)+
000018DC  1CFC 0056               1095          Move.B  #'V', (A6)+
000018E0  1CFC 0043               1096          Move.B  #'C', (A6)+
000018E4                          1097  
000018E4                          1098      ; Put in tabs
000018E4  4EB9 00001AC8           1099          Jsr     OP_TAB
000018EA                          1100  
000018EA                          1101      ; Handoff to John
000018EA                          1102      
000018EA  6000 06FC               1103          BRA     EA_BRANCH
000018EE                          1104  
000018EE                          1105  OP_BRA_VS
000018EE                          1106      ; start string
000018EE                          1107      
000018EE  1CFC 0042               1108          Move.B  #'B', (A6)+
000018F2  1CFC 0056               1109          Move.B  #'V', (A6)+
000018F6  1CFC 0053               1110          Move.B  #'S', (A6)+
000018FA                          1111  
000018FA                          1112      ; Put in tabs
000018FA  4EB9 00001AC8           1113          Jsr     OP_TAB
00001900                          1114  
00001900                          1115      ; Handoff to John
00001900                          1116      
00001900  6000 06E6               1117          BRA     EA_BRANCH
00001904                          1118  
00001904                          1119  OP_BRA_PL
00001904                          1120      ; start string
00001904                          1121      
00001904  1CFC 0042               1122          Move.B  #'B', (A6)+
00001908  1CFC 0050               1123          Move.B  #'P', (A6)+
0000190C  1CFC 004C               1124          Move.B  #'L', (A6)+
00001910                          1125  
00001910                          1126      ; Put in tabs
00001910  4EB9 00001AC8           1127          Jsr     OP_TAB
00001916                          1128  
00001916                          1129      ; Handoff to John
00001916                          1130      
00001916  6000 06D0               1131          BRA     EA_BRANCH
0000191A                          1132  
0000191A                          1133  OP_BRA_MI
0000191A                          1134      ; start string
0000191A                          1135      
0000191A  1CFC 0042               1136          Move.B  #'B', (A6)+
0000191E  1CFC 004D               1137          Move.B  #'M', (A6)+
00001922  1CFC 0049               1138          Move.B  #'I', (A6)+
00001926                          1139  
00001926                          1140      ; Put in tabs
00001926  4EB9 00001AC8           1141          Jsr     OP_TAB
0000192C                          1142  
0000192C                          1143      ; Handoff to John
0000192C                          1144      
0000192C  6000 06BA               1145          BRA     EA_BRANCH
00001930                          1146  
00001930                          1147  OP_BRA_GE
00001930                          1148      ; start string
00001930                          1149      
00001930  1CFC 0042               1150          Move.B  #'B', (A6)+
00001934  1CFC 0047               1151          Move.B  #'G', (A6)+
00001938  1CFC 0045               1152          Move.B  #'E', (A6)+
0000193C                          1153  
0000193C                          1154      ; Put in tabs
0000193C  4EB9 00001AC8           1155          Jsr     OP_TAB
00001942                          1156  
00001942                          1157      ; Handoff to John
00001942                          1158      
00001942  6000 06A4               1159          BRA     EA_BRANCH
00001946                          1160  
00001946                          1161  OP_BRA_LT
00001946                          1162      ; start string
00001946                          1163      
00001946  1CFC 0042               1164          Move.B  #'B', (A6)+
0000194A  1CFC 004C               1165          Move.B  #'L', (A6)+
0000194E  1CFC 0054               1166          Move.B  #'T', (A6)+
00001952                          1167  
00001952                          1168      ; Put in tabs
00001952  4EB9 00001AC8           1169          Jsr     OP_TAB
00001958                          1170  
00001958                          1171      ; Handoff to John
00001958                          1172      
00001958  6000 068E               1173          BRA     EA_BRANCH
0000195C                          1174  
0000195C                          1175  OP_BRA_GT
0000195C                          1176      ; start string
0000195C                          1177      
0000195C  1CFC 0042               1178          Move.B  #'B', (A6)+
00001960  1CFC 0047               1179          Move.B  #'G', (A6)+
00001964  1CFC 0054               1180          Move.B  #'T', (A6)+
00001968                          1181  
00001968                          1182      ; Put in tabs
00001968  4EB9 00001AC8           1183          Jsr     OP_TAB
0000196E                          1184  
0000196E                          1185      ; Handoff to John
0000196E                          1186      
0000196E  6000 0678               1187          BRA     EA_BRANCH
00001972                          1188  
00001972                          1189  OP_BRA_LE
00001972                          1190      ; start string
00001972                          1191      
00001972  1CFC 0042               1192          Move.B  #'B', (A6)+
00001976  1CFC 004C               1193          Move.B  #'L', (A6)+
0000197A  1CFC 0045               1194          Move.B  #'E', (A6)+
0000197E                          1195  
0000197E                          1196      ; Put in tabs
0000197E  4EB9 00001AC8           1197          Jsr     OP_TAB
00001984                          1198  
00001984                          1199      ; Handoff to John
00001984                          1200      
00001984  6000 0662               1201          BRA     EA_BRANCH
00001988                          1202  
00001988                          1203  ;------------------  Multiply Singed ----------------------;    
00001988                          1204  
00001988                          1205  OP_MULS
00001988                          1206      ; MULS only has one format, and that data size of word, so I don't need
00001988                          1207      ; a very intelligent system
00001988                          1208      
00001988  1CFC 004D               1209          Move.B  #'M', (A6)+
0000198C  1CFC 0055               1210          Move.B  #'U', (A6)+
00001990  1CFC 004C               1211          Move.B  #'L', (A6)+
00001994  1CFC 0053               1212          Move.B  #'S', (A6)+
00001998  1CFC 002E               1213          Move.B  #'.', (A6)+
0000199C  1CFC 0057               1214          Move.B  #'W', (A6)+
000019A0                          1215  
000019A0                          1216      ; Put in tabs
000019A0  4EB9 00001AC8           1217          Jsr     OP_TAB       
000019A6                          1218      
000019A6                          1219      ; Give to john
000019A6                          1220      
000019A6  6000 05CA               1221          BRA     EA_MULS
000019AA                          1222  
000019AA                          1223      
000019AA                          1224  ;-----------------------  AND  ------------------------------;    
000019AA                          1225      
000019AA                          1226  OP_AND
000019AA                          1227      ; start string
000019AA                          1228      
000019AA  1CFC 0041               1229          Move.B  #'A', (A6)+
000019AE  1CFC 004E               1230          Move.B  #'N', (A6)+
000019B2  1CFC 0044               1231          Move.B  #'D', (A6)+
000019B6                          1232  
000019B6                          1233      ; No Address Version
000019B6                          1234          
000019B6                          1235      ; Check data size
000019B6  4EB9 00001AEC           1236          Jsr     OP_CHECK_DATA_SIZE
000019BC                          1237          
000019BC                          1238      ; Put in tabs
000019BC  4EB9 00001AC8           1239          Jsr     OP_TAB
000019C2                          1240          
000019C2  6000 04E0               1241      BRA     EA_AND
000019C6                          1242  
000019C6                          1243      
000019C6                          1244  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
000019C6                          1245          
000019C6                          1246  OP_AS_REG
000019C6                          1247      ; start string
000019C6                          1248      
000019C6  1CFC 0041               1249          Move.B  #'A', (A6)+
000019CA  1CFC 0053               1250          Move.B  #'S', (A6)+
000019CE                          1251          
000019CE                          1252      ; Determine Left or right shift
000019CE                          1253      
000019CE  4EB9 00001B3C           1254          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019D4                          1255          
000019D4                          1256      ; Determine data size
000019D4                          1257      
000019D4  4EB9 00001AEC           1258          Jsr     OP_CHECK_DATA_SIZE
000019DA                          1259         
000019DA                          1260      ; Tab out function
000019DA                          1261      
000019DA  4EB9 00001AC8           1262          Jsr     OP_TAB
000019E0                          1263         
000019E0                          1264      ; Handoff function
000019E0  6000 04DA               1265          BRA     EA_BIT_SHIFT
000019E4                          1266          
000019E4                          1267  OP_AS_MEM
000019E4                          1268      
000019E4                          1269      ; start string
000019E4                          1270      
000019E4  1CFC 0041               1271          Move.B  #'A', (A6)+
000019E8  1CFC 0053               1272          Move.B  #'S', (A6)+
000019EC                          1273          
000019EC                          1274      ; Determine Left or right shift
000019EC                          1275      
000019EC  4EB9 00001B3C           1276          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019F2                          1277         
000019F2                          1278      ; Tab out function
000019F2                          1279      
000019F2  4EB9 00001AC8           1280          Jsr     OP_TAB
000019F8                          1281         
000019F8                          1282      ; Handoff function
000019F8  6000 04C2               1283          BRA     EA_BIT_SHIFT
000019FC                          1284  
000019FC                          1285  
000019FC                          1286  ;-------------------  LOGICAL SHIFT  ------------------------;
000019FC                          1287  
000019FC                          1288  OP_LS_REG
000019FC                          1289      ; start string
000019FC                          1290      
000019FC  1CFC 004C               1291          Move.B  #'L', (A6)+
00001A00  1CFC 0053               1292          Move.B  #'S', (A6)+
00001A04                          1293          
00001A04                          1294      ; Determine Left or right shift
00001A04                          1295      
00001A04  4EB9 00001B3C           1296          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A0A                          1297          
00001A0A                          1298      ; Determine data size
00001A0A                          1299      
00001A0A  4EB9 00001AEC           1300          Jsr     OP_CHECK_DATA_SIZE
00001A10                          1301         
00001A10                          1302      ; Tab out function
00001A10                          1303      
00001A10  4EB9 00001AC8           1304          Jsr     OP_TAB
00001A16                          1305         
00001A16                          1306      ; Handoff function
00001A16  6000 04A4               1307          BRA     EA_BIT_SHIFT
00001A1A                          1308  
00001A1A                          1309      
00001A1A                          1310  OP_LS_MEM    
00001A1A                          1311  
00001A1A                          1312      ; start string
00001A1A                          1313      
00001A1A  1CFC 004C               1314          Move.B  #'L', (A6)+
00001A1E  1CFC 0053               1315          Move.B  #'S', (A6)+
00001A22                          1316          
00001A22                          1317      ; Determine Left or right shift
00001A22                          1318      
00001A22  4EB9 00001B3C           1319          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A28                          1320         
00001A28                          1321      ; Tab out function
00001A28                          1322      
00001A28  4EB9 00001AC8           1323          Jsr     OP_TAB
00001A2E                          1324         
00001A2E                          1325      ; Handoff function
00001A2E  6000 048C               1326          BRA     EA_BIT_SHIFT
00001A32                          1327  
00001A32                          1328  
00001A32                          1329  ;----------------------  ROTATE  ----------------------------;
00001A32                          1330  
00001A32                          1331  OP_RO_REG
00001A32                          1332      ; start string
00001A32                          1333      
00001A32  1CFC 0052               1334          Move.B  #'R', (A6)+
00001A36  1CFC 004F               1335          Move.B  #'O', (A6)+
00001A3A                          1336          
00001A3A                          1337      ; Determine Left or right shift
00001A3A                          1338      
00001A3A  4EB9 00001B3C           1339          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A40                          1340          
00001A40                          1341      ; Determine data size
00001A40                          1342      
00001A40  4EB9 00001AEC           1343          Jsr     OP_CHECK_DATA_SIZE
00001A46                          1344         
00001A46                          1345      ; Tab out function
00001A46                          1346      
00001A46  4EB9 00001AC8           1347          Jsr     OP_TAB
00001A4C                          1348         
00001A4C                          1349      ; Handoff function
00001A4C  6000 046E               1350          BRA     EA_BIT_SHIFT
00001A50                          1351  
00001A50                          1352      
00001A50                          1353  OP_RO_MEM
00001A50                          1354  
00001A50                          1355      ; start string
00001A50                          1356      
00001A50  1CFC 0052               1357          Move.B  #'R', (A6)+
00001A54  1CFC 004F               1358          Move.B  #'O', (A6)+
00001A58                          1359          
00001A58                          1360      ; Determine Left or right shift
00001A58                          1361      
00001A58  4EB9 00001B3C           1362          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A5E                          1363         
00001A5E                          1364      ; Tab out function
00001A5E                          1365      
00001A5E  4EB9 00001AC8           1366          Jsr     OP_TAB
00001A64                          1367         
00001A64                          1368      ; Handoff function
00001A64  6000 0456               1369          BRA     EA_BIT_SHIFT
00001A68                          1370  
00001A68                          1371  
00001A68                          1372  ;-----------------------  CMP  ------------------------------;
00001A68                          1373  
00001A68                          1374  OP_Cmp
00001A68                          1375      ; start string
00001A68                          1376      
00001A68  1CFC 0043               1377          Move.B  #'C', (A6)+
00001A6C  1CFC 004D               1378          Move.B  #'M', (A6)+
00001A70  1CFC 0050               1379          Move.B  #'P', (A6)+
00001A74                          1380  
00001A74                          1381      ; Check for address version
00001A74                          1382          
00001A74  4EB9 000021D0           1383          Jsr     GET6AND7
00001A7A  B03C 0003               1384          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001A7E                          1385          
00001A7E  6700 0012               1386          Beq     OP_CMP_ADDR
00001A82                          1387          
00001A82                          1388      ; Check which of the two versions is it?
00001A82                          1389  
00001A82  4EB9 00001AEC           1390          Jsr     OP_CHECK_DATA_SIZE
00001A88                          1391          
00001A88                          1392      ; Put in tabs
00001A88  4EB9 00001AC8           1393          Jsr     OP_TAB
00001A8E                          1394  
00001A8E                          1395      ; Handoff
00001A8E  6000 040C               1396          BRA     EA_CMP
00001A92                          1397          
00001A92                          1398  OP_CMP_ADDR
00001A92                          1399          
00001A92  1CFC 0041               1400          Move.B  #'A',(A6)+ ; add to the string
00001A96                          1401      
00001A96                          1402      ; Find data size
00001A96                          1403          
00001A96  4EB9 00001B0C           1404          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001A9C                          1405          
00001A9C                          1406      ; Put in tabs
00001A9C  4EB9 00001AC8           1407          Jsr     OP_TAB
00001AA2                          1408  
00001AA2                          1409      ; Handoff
00001AA2  6000 03F8               1410          BRA     EA_CMP
00001AA6                          1411      
00001AA6                          1412  ;-----------------------  EOR  ------------------------------;
00001AA6                          1413  
00001AA6                          1414  OP_EOR
00001AA6                          1415      ; start string
00001AA6                          1416      
00001AA6  1CFC 0045               1417          Move.B  #'E', (A6)+
00001AAA  1CFC 004F               1418          Move.B  #'O', (A6)+
00001AAE  1CFC 0052               1419          Move.B  #'R', (A6)+
00001AB2                          1420  
00001AB2                          1421      ; No Address Version
00001AB2                          1422          
00001AB2                          1423      ; Check data size
00001AB2  4EB9 00001AEC           1424          Jsr     OP_CHECK_DATA_SIZE
00001AB8                          1425          
00001AB8                          1426      ; Put in tabs
00001AB8  4EB9 00001AC8           1427          Jsr     OP_TAB
00001ABE                          1428          
00001ABE  6000 03E8               1429      BRA     EA_EOR
00001AC2                          1430  
00001AC2                          1431  ;---------------- Misc Op-Code Sub Routines ----------------;
00001AC2                          1432  ; Set Bad Buffer
00001AC2                          1433  ; Sub Routine that sets the Bad buffer bit and returns
00001AC2                          1434  ;
00001AC2                          1435  ; REGISTERS USED: D7
00001AC2                          1436  
00001AC2                          1437  OP_SET_BAD_BUFFER
00001AC2  1E3C 0001               1438      Move.B  #%1, D7
00001AC6  4E75                    1439      Rts
00001AC8                          1440  
00001AC8                          1441  ;-------------------------- Tab ----------------------------;
00001AC8                          1442  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001AC8                          1443  ; taking into account the current size of the string
00001AC8                          1444  
00001AC8                          1445  ; REGISTERS USED: A6, A5(const), D0
00001AC8                          1446  
00001AC8                          1447  OP_TAB
00001AC8  220D                    1448      Move.L      A5,D1   ; Move the start of string to a Dn
00001ACA  928E                    1449      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001ACC  0681 00000014           1450      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001AD2                          1451      
00001AD2                          1452      ; Loop till you have enough spaces
00001AD2                          1453  LOOP_TAB
00001AD2  1CFC 0020               1454      Move.B      #' ',(A6)+  ; Add a space to the string
00001AD6  5301                    1455      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001AD8  66F8                    1456      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001ADA                          1457      
00001ADA  4E75                    1458      Rts
00001ADC                          1459  
00001ADC                          1460  ;--------------------- Address Version ---------------------;
00001ADC                          1461  ; This Sub Routine Checks if the Src address is an An and
00001ADC                          1462  ; Adds an A to the sring if it is, to represent that it is
00001ADC                          1463  ; Is the Address version of the Op-code. This function assumes
00001ADC                          1464  ; That D0 will have the mode for the Destination in it.
00001ADC                          1465  
00001ADC                          1466  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001ADC                          1467  ;                 A6 (Add string input)
00001ADC                          1468  
00001ADC                          1469  OP_CHECK_ADDRESS_VERSION
00001ADC                          1470  
00001ADC  B03C 0001               1471      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001AE0  6700 0004               1472      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001AE4                          1473      
00001AE4  4E75                    1474      Rts     ; Otherwise go back without changing anything
00001AE6                          1475  
00001AE6                          1476  OP_ADD_ADDRESS_VERSION
00001AE6  1CFC 0041               1477      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001AEA                          1478      
00001AEA  4E75                    1479      Rts     ; Finish up and go back
00001AEC                          1480      
00001AEC                          1481  ;--------------------- Data Size Check ---------------------;
00001AEC                          1482  ; A set of sub routines to check the size of the data and add it
00001AEC                          1483  ; To the string.
00001AEC                          1484  
00001AEC                          1485  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001AEC                          1486  ;                 A6(adds letters)    
00001AEC                          1487  OP_CHECK_DATA_SIZE
00001AEC  4EB9 000021D0           1488      Jsr     GET6AND7
00001AF2                          1489      
00001AF2  B03C 0000               1490      Cmp.B    #%00, D0    ; Byte Size
00001AF6  6700 0026               1491      Beq     OP_SET_DATA_BYTE
00001AFA                          1492      
00001AFA  B03C 0001               1493      Cmp.B    #%01, D0    ; Word Size
00001AFE  6700 0028               1494      Beq     OP_SET_DATA_WORD
00001B02                          1495      
00001B02  B03C 0002               1496      Cmp.B    #%10, D0    ; Long Size
00001B06  6700 002A               1497      Beq     OP_SET_DATA_LONG
00001B0A                          1498      
00001B0A                          1499      ; If it was not one of those three types, it is not a legal operation
00001B0A  60B6                    1500      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001B0C                          1501  
00001B0C                          1502  OP_CHECK_DATA_SIZE_ADDR
00001B0C  4EB9 000021AC           1503      Jsr     GETBIT8
00001B12                          1504      
00001B12  B03C 0000               1505      Cmp.B   #%0, D0     ; Word Size
00001B16  6700 0010               1506      Beq     OP_SET_DATA_WORD
00001B1A                          1507                          ; Otherwise its Long Size
00001B1A  6000 0016               1508      Bra     OP_SET_DATA_LONG
00001B1E                          1509  
00001B1E                          1510  OP_SET_DATA_BYTE
00001B1E                          1511  
00001B1E  1CFC 002E               1512      Move.B  #'.',(A6)+  ; Add Letters
00001B22  1CFC 0042               1513      Move.B  #'B',(A6)+
00001B26                          1514      
00001B26  4E75                    1515      Rts
00001B28                          1516  
00001B28                          1517  OP_SET_DATA_WORD
00001B28                          1518  
00001B28  1CFC 002E               1519      Move.B  #'.',(A6)+  ; Add Letters
00001B2C  1CFC 0057               1520      Move.B  #'W',(A6)+
00001B30                          1521  
00001B30  4E75                    1522      Rts
00001B32                          1523  
00001B32                          1524  OP_SET_DATA_LONG
00001B32                          1525  
00001B32  1CFC 002E               1526      Move.B  #'.',(A6)+  ; Add Letters
00001B36  1CFC 004C               1527      Move.B  #'L',(A6)+
00001B3A                          1528  
00001B3A  4E75                    1529      Rts
00001B3C                          1530  
00001B3C                          1531  ;------------------- Bit Shift Direction -------------------;
00001B3C                          1532  ; This checks bit 8 to see what direction the shift is going
00001B3C                          1533  
00001B3C                          1534  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B3C                          1535  
00001B3C                          1536  OP_SHIFT_DIRECTION
00001B3C  4EB9 000021AC           1537      Jsr     GETBIT8 ; Get the shift direction bit
00001B42                          1538      
00001B42  B03C 0000               1539      Cmp.B   #%0,D0  ; 0 is Right
00001B46  6700 0006               1540      Beq     OP_SHIFT_RIGHT
00001B4A                          1541  
00001B4A  6000 0008               1542      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001B4E                          1543  
00001B4E                          1544  OP_SHIFT_RIGHT
00001B4E                          1545      ; Add the character and return
00001B4E  1CFC 0052               1546      Move.B  #'R',(A6)+
00001B52                          1547  
00001B52  4E75                    1548      Rts    
00001B54                          1549  
00001B54                          1550  OP_SHIFT_LEFT
00001B54                          1551      ; Add the character and return
00001B54  1CFC 004C               1552      Move.B  #'L',(A6)+
00001B58                          1553  
00001B58  4E75                    1554      Rts
00001B5A                          1555      
00001B5A                          1556  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001B5A                          1557  ;-------------------- Effective Address Sub Routines --------------------;
00001B5A                          1558  ; These subroutines look for the correct effective address
00001B5A                          1559  ; in each OP code.
00001B5A                          1560  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001B5A                          1561  
00001B5A                          1562  ;=============================================;
00001B5A                          1563  ;--------------- EA Move/MoveA ---------------;
00001B5A                          1564  ;=============================================;
00001B5A                          1565  EA_MOVE
00001B5A  4EB9 00001B6C           1566          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001B60  1CFC 002C               1567          Move.B  #',', (A6)+             ; Add a comma
00001B64  4EB9 00001B7C           1568          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001B6A                          1569          
00001B6A  4E75                    1570          RTS
00001B6C                          1571                  
00001B6C                          1572  EA_MOVE_SOURCE  ; Find out Move's source
00001B6C  4EB9 000020EE           1573          Jsr     EA_0TO5                 ; Get the EA
00001B72                          1574          
00001B72  B03C 0004               1575          Cmp.B   #Imm_Reg, D0            ; #<data>
00001B76  6700 004C               1576          Beq     EA_MOVE_SIZE
00001B7A                          1577          
00001B7A  4E75                    1578          Rts
00001B7C                          1579          
00001B7C                          1580  EA_MOVE_DEST    ; Find out Move's destination
00001B7C  4EB9 00002176           1581          Jsr     GET6TO8                 ; Get destination mode
00001B82  1A00                    1582          Move.B  D0, D5                  ; Move destination mode to D5
00001B84  4EB9 00002164           1583          Jsr     GET9TO11                ; Get destination register
00001B8A                          1584          
00001B8A                          1585          ; List of valid effective addresses
00001B8A  BA3C 0000               1586          Cmp.B   #Dn_Mode, D5            ; Dn
00001B8E  6700 0482               1587          Beq     EA_DN
00001B92                          1588          
00001B92  BA3C 0001               1589          Cmp.B   #An_Mode, D5            ; An
00001B96  6700 0486               1590          Beq     EA_AN
00001B9A                          1591          
00001B9A  BA3C 0002               1592          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001B9E  6700 048A               1593          Beq     EA_AN_PNTR
00001BA2                          1594          
00001BA2  BA3C 0003               1595          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001BA6  6700 0496               1596          Beq     EA_AN_INC
00001BAA                          1597          
00001BAA  BA3C 0004               1598          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001BAE  6700 04A6               1599          Beq     EA_AN_DEC
00001BB2                          1600          
00001BB2                          1601          ; Comparing registers at this point because modes are the same
00001BB2  B03C 0000               1602          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001BB6  6700 04B6               1603          Beq     EA_WORD_ADDR
00001BBA                          1604          
00001BBA  B03C 0001               1605          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001BBE  6700 04F2               1606          Beq     EA_LONG_ADDR
00001BC2                          1607          
00001BC2  4E75                    1608          Rts
00001BC4                          1609          
00001BC4                          1610  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001BC4  4EB9 00002140           1611          Jsr     GET12TO13               ; Get Move size
00001BCA                          1612  
00001BCA  B03C 0001               1613          Cmp.B   #%01, D0                ; Byte
00001BCE  6700 04EE               1614          Beq     EA_IMM_BYTE
00001BD2                          1615  
00001BD2  B03C 0003               1616          Cmp.B   #%11, D0                ; Word
00001BD6  6700 04F6               1617          Beq     EA_IMM_WORD
00001BDA                          1618          
00001BDA  B03C 0002               1619          Cmp.B   #%10, D0                ; Long
00001BDE  6700 04FE               1620          Beq     EA_IMM_LONG
00001BE2                          1621          
00001BE2  4E75                    1622          Rts
00001BE4                          1623          
00001BE4                          1624  ;=================================================================;
00001BE4                          1625  ;---------------------------- EA MoveM ---------------------------;
00001BE4                          1626  ; D2 stores the counter for the number of consecutive ones in the
00001BE4                          1627  ; register list mask
00001BE4                          1628  ;
00001BE4                          1629  ; D3 stores a 1 if the register being added is the first register, 
00001BE4                          1630  ; or 0 if the register is not the first register being added
00001BE4                          1631  ;
00001BE4                          1632  ; D5 stores the register list mask
00001BE4                          1633  ;
00001BE4                          1634  ; D6 stores any expansion words
00001BE4                          1635  ;
00001BE4                          1636  ; D7 stores the loop counter
00001BE4                          1637  ;=================================================================;
00001BE4                          1638  EA_MOVEM    ; Determines the EA for MoveM
00001BE4  48E7 3F00               1639          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001BE8                          1640          
00001BE8  4282                    1641          Clr.L   D2                      ; Clear out the data registers
00001BEA  4283                    1642          Clr.L   D3
00001BEC  4285                    1643          Clr.L   D5
00001BEE  4286                    1644          Clr.L   D6
00001BF0  4287                    1645          Clr.L   D7
00001BF2                          1646          
00001BF2  5203                    1647          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001BF4  3A1B                    1648          Move.W  (A3)+, D5               ; Store the register list mask
00001BF6                          1649          
00001BF6  4EB9 00002226           1650          Jsr     GETBIT10                ; Get the direction bit
00001BFC                          1651          
00001BFC  B03C 0000               1652          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001C00  6700 0008               1653          Beq     EA_MOVEM_REG_TO_MEM
00001C04                          1654          
00001C04  4EF9 00001C20           1655          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001C0A                          1656          
00001C0A                          1657  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001C0A  4EB9 00001C3C           1658          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C10  1CFC 002C               1659          Move.B  #',', (A6)+             ; Add a comma
00001C14  4EB9 000020EE           1660          Jsr     EA_0TO5                 ; Get the EA
00001C1A                          1661          
00001C1A  4CDF 00FC               1662          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C1E                          1663                  
00001C1E  4E75                    1664          RTS
00001C20                          1665          
00001C20                          1666  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C20  3E05                    1667          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C22  4EB9 000020EE           1668          Jsr     EA_0TO5                 ; Get the EA
00001C28  1CFC 002C               1669          Move.B  #',', (A6)+             ; Add a comma
00001C2C  3A07                    1670          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C2E  4287                    1671          Clr.L   D7                      ; Clear D7
00001C30  4EB9 00001C3C           1672          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C36                          1673          
00001C36  4CDF 00FC               1674          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C3A                          1675                  
00001C3A  4E75                    1676          RTS
00001C3C                          1677                  
00001C3C                          1678  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C3C  BE3C 0010               1679          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C40  6C00 0016               1680          Bge     EA_MOVEM_LIST_END
00001C44                          1681  
00001C44  4EB9 00002188           1682          Jsr     GET3TO5                 ; Get the EA mode
00001C4A                          1683          
00001C4A  B03C 0004               1684          Cmp.B   #%100, D0               ; Predecrement mode
00001C4E  6700 000A               1685          Beq     EA_MOVEM_PRE_DEC
00001C52                          1686          
00001C52  4EF9 00001C64           1687          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001C58                          1688          
00001C58                          1689  EA_MOVEM_LIST_END   ; Ends the list loop
00001C58  4E75                    1690          Rts
00001C5A                          1691          
00001C5A                          1692  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001C5A  E35D                    1693          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001C5C                          1694          
00001C5C  6500 0010               1695          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C60                          1696          
00001C60  6400 002C               1697          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C64                          1698          
00001C64                          1699  EA_MOVEM_POST_INC   ; Post increment mode
00001C64  E25D                    1700          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001C66                          1701          
00001C66  6500 0006               1702          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C6A                          1703          
00001C6A  6400 0022               1704          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C6E                          1705          
00001C6E                          1706  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001C6E  B63C 0001               1707          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001C72  6700 002A               1708          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001C76                          1709          
00001C76  B43C 0000               1710          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001C7A  6700 0032               1711          Beq     EA_MOVEM_ADD_SINGLE_REG
00001C7E                          1712          
00001C7E  5207                    1713          Add.B   #1, D7                  ; Increment the loop counter
00001C80  5202                    1714          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C82                          1715          
00001C82  BE3C 0010               1716          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001C86  6700 0038               1717          Beq     EA_MOVEM_LAST_REG
00001C8A                          1718          
00001C8A  4EF8 1C3C               1719          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C8E                          1720          
00001C8E                          1721  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001C8E  B43C 0001               1722          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001C92  6E00 003A               1723          Bgt     EA_MOVEM_ADD_LAST_REG
00001C96                          1724          
00001C96  5207                    1725          Add.B   #1, D7                  ; Increment the loop counter
00001C98                          1726          
00001C98  4282                    1727          Clr.L   D2                      ; Clear the counter for consecutive ones
00001C9A                          1728          
00001C9A  4EF8 1C3C               1729          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C9E                          1730  
00001C9E                          1731  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001C9E  4EB9 00001CE2           1732          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001CA4                          1733          
00001CA4  4283                    1734          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001CA6                          1735          
00001CA6  5207                    1736          Add.B   #1, D7                  ; Increment the loop counter
00001CA8  5202                    1737          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CAA                          1738          
00001CAA  4EF8 1C3C               1739          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CAE                          1740          
00001CAE                          1741  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001CAE  1CFC 002F               1742          Move.B  #'/', (A6)+
00001CB2                          1743          
00001CB2  4EB9 00001CE2           1744          Jsr     EA_MOVEM_REG            ; Add a register
00001CB8                          1745          
00001CB8  5207                    1746          Add.B   #1, D7                  ; Increment the loop counter 
00001CBA  5202                    1747          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CBC                          1748          
00001CBC  4EF8 1C3C               1749          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CC0                          1750          
00001CC0                          1751  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001CC0  B43C 0001               1752          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001CC4  6E00 0008               1753          Bgt     EA_MOVEM_ADD_LAST_REG
00001CC8                          1754          
00001CC8  5207                    1755          Add.B   #1, D7                  ; Increment the loop counter
00001CCA                          1756          
00001CCA  4EF8 1C3C               1757          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CCE                          1758          
00001CCE                          1759  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001CCE  1CFC 002D               1760          Move.B  #'-', (A6)+
00001CD2                          1761          
00001CD2  5307                    1762          Sub.B   #1, D7                  ; Move back to the previous register
00001CD4                          1763          
00001CD4  4EB9 00001CE2           1764          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001CDA                          1765          
00001CDA  5407                    1766          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001CDC                          1767          
00001CDC  4282                    1768          Clr.L   D2                      ; Clear the consecutive ones counter
00001CDE                          1769          
00001CDE  4EF8 1C3C               1770          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CE2                          1771          
00001CE2                          1772  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001CE2  4280                    1773          Clr.L   D0                      ; Clear D0
00001CE4  BE3C 0000               1774          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001CE8  6700 0328               1775          Beq     EA_DN
00001CEC                          1776          
00001CEC  103C 0001               1777          Move.B  #1, D0                  ; Move a 1 into D0
00001CF0  BE3C 0001               1778          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001CF4  6700 031C               1779          Beq     EA_DN
00001CF8                          1780          
00001CF8  103C 0002               1781          Move.B  #2, D0
00001CFC  BE3C 0002               1782          Cmp.B   #2, D7
00001D00  6700 0310               1783          Beq     EA_DN
00001D04                          1784  
00001D04  103C 0003               1785          Move.B  #3, D0
00001D08  BE3C 0003               1786          Cmp.B   #3, D7
00001D0C  6700 0304               1787          Beq     EA_DN
00001D10                          1788  
00001D10  103C 0004               1789          Move.B  #4, D0
00001D14  BE3C 0004               1790          Cmp.B   #4, D7
00001D18  6700 02F8               1791          Beq     EA_DN
00001D1C                          1792  
00001D1C  103C 0005               1793          Move.B  #5, D0
00001D20  BE3C 0005               1794          Cmp.B   #5, D7
00001D24  6700 02EC               1795          Beq     EA_DN
00001D28                          1796  
00001D28  103C 0006               1797          Move.B  #6, D0
00001D2C  BE3C 0006               1798          Cmp.B   #6, D7
00001D30  6700 02E0               1799          Beq     EA_DN
00001D34                          1800          
00001D34  103C 0007               1801          Move.B  #7, D0
00001D38  BE3C 0007               1802          Cmp.B   #7, D7
00001D3C  6700 02D4               1803          Beq     EA_DN
00001D40                          1804          
00001D40  4280                    1805          Clr.L   D0
00001D42  BE3C 0008               1806          Cmp.B   #8, D7
00001D46  6700 02D6               1807          Beq     EA_AN
00001D4A                          1808  
00001D4A  103C 0001               1809          Move.B  #1, D0
00001D4E  BE3C 0009               1810          Cmp.B   #9, D7
00001D52  6700 02CA               1811          Beq     EA_AN
00001D56                          1812  
00001D56  103C 0002               1813          Move.B  #2, D0
00001D5A  BE3C 000A               1814          Cmp.B   #10, D7
00001D5E  6700 02BE               1815          Beq     EA_AN
00001D62                          1816          
00001D62  103C 0003               1817          Move.B  #3, D0
00001D66  BE3C 000B               1818          Cmp.B   #11, D7
00001D6A  6700 02B2               1819          Beq     EA_AN
00001D6E                          1820          
00001D6E  103C 0004               1821          Move.B  #4, D0
00001D72  BE3C 000C               1822          Cmp.B   #12, D7
00001D76  6700 02A6               1823          Beq     EA_AN
00001D7A                          1824          
00001D7A  103C 0005               1825          Move.B  #5, D0
00001D7E  BE3C 000D               1826          Cmp.B   #13, D7
00001D82  6700 029A               1827          Beq     EA_AN
00001D86                          1828          
00001D86  103C 0006               1829          Move.B  #6, D0
00001D8A  BE3C 000E               1830          Cmp.B   #14, D7
00001D8E  6700 028E               1831          Beq     EA_AN
00001D92                          1832          
00001D92  103C 0007               1833          Move.B  #7, D0
00001D96  BE3C 000F               1834          Cmp.B   #15, D7
00001D9A  6700 0282               1835          Beq     EA_AN
00001D9E                          1836  
00001D9E                          1837  ;===========================================;        
00001D9E                          1838  ;--------------- EA Add/AddA ---------------;
00001D9E                          1839  ;===========================================;       
00001D9E                          1840  EA_ADD  ; Figures out the EA for Add        
00001D9E  4EB9 00002176           1841          Jsr     GET6TO8                 ; Isolate the Op mode
00001DA4                          1842          
00001DA4  B03C 0003               1843          Cmp.B   #%011, D0               ; Compare to AddA word
00001DA8  6700 0028               1844          Beq     EA_ADDA
00001DAC                          1845          
00001DAC  B03C 0007               1846          Cmp.B   #%111, D0               ; Compare to AddA long
00001DB0  6700 0020               1847          Beq     EA_ADDA
00001DB4                          1848  
00001DB4  B03C 0000               1849          Cmp.B   #%000, D0               ; Compare to Add source byte
00001DB8  6700 0030               1850          Beq     EA_ADD_OPMODE_SOURCE
00001DBC                          1851          
00001DBC  B03C 0001               1852          Cmp.B   #%001, D0               ; Compare to Add source word
00001DC0  6700 0028               1853          Beq     EA_ADD_OPMODE_SOURCE
00001DC4                          1854          
00001DC4  B03C 0002               1855          Cmp.B   #%010, D0               ; Compare to Add source Long
00001DC8  6700 0020               1856          Beq     EA_ADD_OPMODE_SOURCE
00001DCC                          1857          
00001DCC  4EF9 00001E02           1858          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001DD2                          1859          
00001DD2                          1860  EA_ADDA ; Figures out the EA for AddA
00001DD2  4EB9 00001E1A           1861          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DD8  1CFC 002C               1862          Move.B  #',', (A6)+             ; Add a comma
00001DDC  4EB9 00002164           1863          Jsr     GET9TO11                ; Get the register
00001DE2  4EB9 0000201E           1864          Jsr     EA_AN                   ; Add An
00001DE8                          1865          
00001DE8  4E75                    1866          RTS
00001DEA                          1867          
00001DEA                          1868  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001DEA  4EB9 00001E1A           1869          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DF0  1CFC 002C               1870          Move.B  #',', (A6)+             ; Add a comma
00001DF4  4EB9 00002164           1871          Jsr     GET9TO11                ; Get the register
00001DFA  4EB9 00002012           1872          Jsr     EA_DN                   ; Add Dn
00001E00                          1873          
00001E00  4E75                    1874          RTS
00001E02                          1875          
00001E02                          1876  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001E02  4EB9 00002164           1877          Jsr     GET9TO11                ; Get the register
00001E08  4EB9 00002012           1878          Jsr     EA_DN                   ; Add Dn
00001E0E  1CFC 002C               1879          Move.B  #',', (A6)+             ; Add a comma
00001E12  4EB9 00001E1A           1880          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001E18                          1881          
00001E18  4E75                    1882          RTS
00001E1A                          1883          
00001E1A                          1884  EA_ADD_ADDRESS
00001E1A  4EB9 000020EE           1885          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E20                          1886          
00001E20  B03C 0004               1887          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E24  6700 0004               1888          Beq     EA_ADD_SIZE
00001E28                          1889  
00001E28  4E75                    1890          Rts
00001E2A                          1891          
00001E2A                          1892  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E2A  4EB9 00002176           1893          Jsr     GET6TO8                 ; Get Move size
00001E30                          1894  
00001E30  B03C 0000               1895          Cmp.B   #%000, D0               ; Byte
00001E34  6700 0288               1896          Beq     EA_IMM_BYTE
00001E38                          1897  
00001E38  B03C 0001               1898          Cmp.B   #%001, D0               ; Word
00001E3C  6700 0290               1899          Beq     EA_IMM_WORD
00001E40                          1900          
00001E40  B03C 0002               1901          Cmp.B   #%010, D0               ; Long
00001E44  6700 0298               1902          Beq     EA_IMM_LONG
00001E48                          1903          
00001E48  B03C 0003               1904          Cmp.B   #%011, D0               ; AddA Word
00001E4C  6700 0280               1905          Beq     EA_IMM_WORD
00001E50                          1906     
00001E50  B03C 0007               1907          Cmp.B   #%111, D0               ; AddA Long
00001E54  6700 0288               1908          Beq     EA_IMM_LONG
00001E58                          1909          
00001E58  4E75                    1910          Rts
00001E5A                          1911          
00001E5A                          1912  ;=================================================;        
00001E5A                          1913  ;-------------------- EA AddQ --------------------;
00001E5A                          1914  ;=================================================;
00001E5A                          1915  EA_ADDQ ; Figures out the EA for AddQ
00001E5A  4EB9 00001E6C           1916          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001E60  1CFC 002C               1917          Move.B  #',', (A6)+             ; Add a comma
00001E64  4EB9 00001E90           1918          Jsr     EA_ADDQ_DEST            ; Add the destination
00001E6A                          1919          
00001E6A  4E75                    1920          Rts
00001E6C                          1921  
00001E6C                          1922  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001E6C  4EB9 00002164           1923          Jsr     GET9TO11                ; Isolate the count/register bits
00001E72                          1924          
00001E72  B03C 0000               1925          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001E76  6E00 000C               1926          Bgt     EA_ADDQ_IMMEDIATE
00001E7A                          1927          
00001E7A  103C 0008               1928          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001E7E                          1929          
00001E7E  4EF9 00001E84           1930          Jmp     EA_ADDQ_IMMEDIATE
00001E84                          1931          
00001E84                          1932  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001E84  1CFC 0023               1933          Move.B  #'#', (A6)+
00001E88  0600 0030               1934          Add.B   #$30, D0
00001E8C  1CC0                    1935          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001E8E                          1936          
00001E8E  4E75                    1937          Rts
00001E90                          1938          
00001E90                          1939  EA_ADDQ_DEST    ; Determines the destination       
00001E90  4EB9 000020EE           1940          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E96                          1941          
00001E96  4E75                    1942          Rts     
00001E98                          1943          
00001E98                          1944  ;=========================================================;        
00001E98                          1945  ;---------------------- EA Sub/SubA ----------------------;
00001E98                          1946  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E98                          1947  ; Sub/SubA are exactly the same.
00001E98                          1948  ;=========================================================;
00001E98                          1949  EA_SUB
00001E98  4EF8 1D9E               1950          Jmp     EA_ADD
00001E9C                          1951  
00001E9C                          1952  ;=========================================================;        
00001E9C                          1953  ;---------------------- EA Cmp/CmpA ----------------------;
00001E9C                          1954  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E9C                          1955  ; Cmp/CmpA are exactly the same.
00001E9C                          1956  ;=========================================================;
00001E9C                          1957  EA_CMP       
00001E9C  4EF8 1D9E               1958          Jmp     EA_ADD
00001EA0                          1959          
00001EA0                          1960  ;=========================================================;        
00001EA0                          1961  ;------------------------ EA Lea -------------------------;
00001EA0                          1962  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001EA0                          1963  ; are exactly the same.
00001EA0                          1964  ;=========================================================;
00001EA0                          1965  EA_LEA
00001EA0  4EF8 1D9E               1966          Jmp     EA_ADD
00001EA4                          1967          
00001EA4                          1968  ;=========================================================;        
00001EA4                          1969  ;------------------------ EA And -------------------------;
00001EA4                          1970  ; Jumps straight to EA_ADD because the EA for Add and And
00001EA4                          1971  ; are exactly the same.
00001EA4                          1972  ;=========================================================;
00001EA4                          1973  EA_AND
00001EA4  4EF8 1D9E               1974          Jmp     EA_ADD
00001EA8                          1975          
00001EA8                          1976  ;=========================================================;        
00001EA8                          1977  ;------------------------ EA Eor -------------------------;
00001EA8                          1978  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001EA8                          1979  ; are exactly the same.
00001EA8                          1980  ;=========================================================;
00001EA8                          1981  EA_EOR
00001EA8  4EF8 1D9E               1982          Jmp     EA_ADD
00001EAC                          1983          
00001EAC                          1984  ;=========================================================;        
00001EAC                          1985  ;------------------------ EA Neg -------------------------;
00001EAC                          1986  ;=========================================================;
00001EAC                          1987  EA_NEG
00001EAC  4EB9 000020EE           1988          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EB2                          1989          
00001EB2  4E75                    1990          RTS
00001EB4                          1991          
00001EB4                          1992  ;=========================================================;        
00001EB4                          1993  ;------------------------ EA Not -------------------------;
00001EB4                          1994  ; Jumps straight to EA_NEG because Neg and Not have the
00001EB4                          1995  ; exact same EAs. 
00001EB4                          1996  ;=========================================================;
00001EB4                          1997  EA_NOT
00001EB4  4EF8 1EAC               1998          Jmp     EA_NEG 
00001EB8                          1999          
00001EB8                          2000  ;=========================================================;        
00001EB8                          2001  ;------------------------ EA Jsr -------------------------;
00001EB8                          2002  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001EB8                          2003  ; exact same EAs. 
00001EB8                          2004  ;=========================================================;
00001EB8                          2005  EA_Jsr
00001EB8  4EF8 1EAC               2006          Jmp     EA_NEG 
00001EBC                          2007  
00001EBC                          2008  ;=========================================================;
00001EBC                          2009  ;--------------------- EA Bit Shift ----------------------;
00001EBC                          2010  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001EBC                          2011  ; are combined because the EA for each code is exactly the
00001EBC                          2012  ; same.
00001EBC                          2013  ;=========================================================;
00001EBC                          2014  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001EBC  4EB9 00002238           2015          Jsr     GET6TO7
00001EC2                          2016          
00001EC2  B03C 0003               2017          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001EC6  6600 0012               2018          Bne     EA_SHIFT_REGISTER
00001ECA                          2019          
00001ECA  4EB9 00001ED2           2020          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001ED0                          2021          
00001ED0  4E75                    2022          RTS
00001ED2                          2023                  
00001ED2                          2024  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001ED2  4EB9 000020EE           2025          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001ED8                          2026          
00001ED8  4E75                    2027          Rts
00001EDA                          2028          
00001EDA                          2029  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001EDA  4EB9 00002206           2030          Jsr     GETBIT5
00001EE0                          2031          
00001EE0  B03C 0000               2032          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001EE4  6700 0008               2033          Beq     EA_SHIFT_CHECK_8
00001EE8                          2034          
00001EE8  4EF9 00001F16           2035          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001EEE                          2036          
00001EEE                          2037  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001EEE  4EB9 00002164           2038          Jsr     GET9TO11                ; Isolate the count/register bits
00001EF4                          2039          
00001EF4  B03C 0000               2040          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001EF8  6E00 000C               2041          Bgt     EA_SHIFT_IMMEDIATE
00001EFC                          2042          
00001EFC  103C 0008               2043          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001F00                          2044                  
00001F00  4EF9 00001F06           2045          Jmp     EA_SHIFT_IMMEDIATE
00001F06                          2046          
00001F06                          2047  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001F06  1CFC 0023               2048          Move.B  #'#', (A6)+
00001F0A  0600 0030               2049          Add.B   #$30, D0
00001F0E  1CC0                    2050          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001F10                          2051  
00001F10  4EF9 00001F28           2052          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001F16                          2053          
00001F16                          2054  EA_SHIFT_DN ; Adds a data register before the comma
00001F16  4EB9 00002164           2055          Jsr     GET9TO11                ; Isolate the data register bits
00001F1C                          2056          
00001F1C  4EB9 00002012           2057          Jsr     EA_DN                   ; Add the data register to the string
00001F22                          2058          
00001F22  4EF9 00001F28           2059          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F28                          2060          
00001F28                          2061  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F28  1CFC 002C               2062          Move.B  #',', (A6)+
00001F2C                          2063          
00001F2C  4EB9 0000219A           2064          Jsr     GET0TO2                 ; Get the register number
00001F32                          2065          
00001F32  4EB9 00002012           2066          Jsr     EA_DN                   ; Add the register
00001F38                          2067          
00001F38  4E75                    2068          RTS
00001F3A                          2069  
00001F3A                          2070  ;============================================;        
00001F3A                          2071  ;--------------- EA Immediate ---------------;
00001F3A                          2072  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F3A                          2073  ;============================================;
00001F3A                          2074  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F3A  4EB9 00001F4C           2075          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F40  1CFC 002C               2076          Move.B  #',', (A6)+             ; Add a comma
00001F44  4EB9 00001F6A           2077          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001F4A                          2078          
00001F4A  4E75                    2079          RTS
00001F4C                          2080          
00001F4C                          2081  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001F4C  4EB9 00002238           2082          Jsr     GET6TO7                 ; Isolate the size bits
00001F52                          2083                  
00001F52  B03C 0001               2084          Cmp.B   #%01, D0                ; Immediate word
00001F56  6700 0176               2085          Beq     EA_IMM_WORD
00001F5A                          2086          
00001F5A  B03C 0002               2087          Cmp.B   #%10, D0                ; Immediate long
00001F5E  6700 017E               2088          Beq     EA_IMM_LONG
00001F62                          2089        
00001F62  4EF9 000020BE           2090          Jmp     EA_IMM_BYTE
00001F68                          2091  
00001F68  4E75                    2092          Rts
00001F6A                          2093          
00001F6A                          2094  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001F6A  4EB9 000020EE           2095          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F70                          2096          
00001F70  4E75                    2097          Rts
00001F72                          2098        
00001F72                          2099  ;=================================================;  
00001F72                          2100  ;-------------------- EA Muls --------------------;
00001F72                          2101  ;=================================================;
00001F72                          2102  EA_MULS ; Determines the EA for Muls
00001F72  4EB9 00001F8A           2103          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001F78  1CFC 002C               2104          Move.B  #',', (A6)+             ; Add a comma
00001F7C  4EB9 00002164           2105          Jsr     GET9TO11                ; Get the register
00001F82  4EB9 00002012           2106          Jsr     EA_DN                   ; Add Dn
00001F88                          2107          
00001F88  4E75                    2108          RTS
00001F8A                          2109          
00001F8A                          2110  EA_MULS_ADDRESS ; Determines the EA
00001F8A  4EB9 000020EE           2111          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F90                          2112          
00001F90  B03C 0004               2113          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001F94  6700 0138               2114          Beq     EA_IMM_WORD
00001F98                          2115          
00001F98  4E75                    2116          Rts
00001F9A                          2117          
00001F9A                          2118  ;=================================================;  
00001F9A                          2119  ;-------------------- EA DIVS --------------------;
00001F9A                          2120  ; Jumps straight to EA_DIVS because the EA for
00001F9A                          2121  ; both OP codes is exactly the same.
00001F9A                          2122  ;=================================================;
00001F9A                          2123  EA_DIVS
00001F9A  4EF8 1F72               2124          Jmp     EA_MULS
00001F9E                          2125          
00001F9E                          2126  ;=================================================;        
00001F9E                          2127  ;-------------------- EA BTST --------------------;
00001F9E                          2128  ;=================================================;
00001F9E                          2129  EA_BTST ; Determines the EA for Btst
00001F9E  4EB9 000021AC           2130          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001FA4                          2131          
00001FA4  B03C 0001               2132          Cmp.B   #%1, D0                 ; 1 is a data register
00001FA8  6700 0008               2133          Beq     EA_BTST_DN
00001FAC                          2134          
00001FAC  4EF9 00001FC6           2135          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
00001FB2                          2136          
00001FB2                          2137  EA_BTST_DN  ; Gets the register for the bit number
00001FB2  4EB9 00002164           2138          Jsr     GET9TO11                ; Get the register
00001FB8  4EB9 00002012           2139          Jsr     EA_DN                   ; Add the register to the string
00001FBE                          2140          
00001FBE  4EB9 00001FD4           2141          Jsr     EA_BTST_ADDRESS         ; Add the EA
00001FC4                          2142          
00001FC4  4E75                    2143          RTS
00001FC6                          2144  
00001FC6                          2145  EA_BTST_IMM ; Gets the immediate data for the bit number
00001FC6  4EB9 000020BE           2146          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00001FCC                          2147          
00001FCC  4EB9 00001FD4           2148          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
00001FD2                          2149          
00001FD2  4E75                    2150          RTS
00001FD4                          2151  
00001FD4                          2152  EA_BTST_ADDRESS ; Get the EA
00001FD4  1CFC 002C               2153          Move.B  #',', (A6)+
00001FD8                          2154  
00001FD8  4EB9 000020EE           2155          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
00001FDE                          2156          
00001FDE  B03C 0004               2157          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
00001FE2  6700 00DA               2158          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
00001FE6                          2159          
00001FE6  4E75                    2160          Rts
00001FE8                          2161          
00001FE8                          2162  ;==================================================;        
00001FE8                          2163  ;------------------- EA Branch --------------------;
00001FE8                          2164  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00001FE8                          2165  ;==================================================;
00001FE8                          2166  EA_BRANCH  ; Determines the EA for Branch codes
00001FE8  4EB9 00002218           2167          Jsr     GET0TO7                 ; Get the 8 displacement bits
00001FEE                          2168          
00001FEE  2C0B                    2169          Move.L  A3, D6                  ; Move address after the Bra word to D6
00001FF0                          2170          
00001FF0  B03C 0000               2171          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
00001FF4  6700 0008               2172          Beq     EA_BRANCH_16_BIT
00001FF8                          2173          
00001FF8  4EF9 00002006           2174          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
00001FFE                          2175  
00001FFE                          2176  EA_BRANCH_16_BIT   ; Gets the next word
00001FFE  301B                    2177          Move.W  (A3)+, D0               ; Stores the word in D0
00002000                          2178  
00002000  4EF9 00002006           2179          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
00002006                          2180          
00002006                          2181  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
00002006  DC40                    2182          Add.W   D0, D6                  ; Add the displacement to D6
00002008                          2183      
00002008  1CFC 0024               2184          Move.B  #'$', (A6)+             ; Add '$' to the string
0000200C                          2185          
0000200C  4EB8 1290               2186          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
00002010                          2187  
00002010  4E75                    2188          RTS
00002012                          2189                         
00002012                          2190  ;==========================================;        
00002012                          2191  ;---------- General EA functions ----------;
00002012                          2192  ;==========================================;
00002012                          2193  EA_DN   ; Adds Dn EA to string
00002012  1CFC 0044               2194          Move.B  #'D', (A6)+             
00002016  0600 0030               2195          Add.B   #$30, D0        
0000201A  1CC0                    2196          Move.B  D0, (A6)+               
0000201C                          2197                  
0000201C  4E75                    2198          Rts
0000201E                          2199  
0000201E                          2200  EA_AN   ; Adds An EA to string
0000201E  1CFC 0041               2201          Move.B  #'A', (A6)+
00002022  0600 0030               2202          Add.B   #$30, D0    
00002026  1CC0                    2203          Move.B  D0, (A6)+               
00002028                          2204                  
00002028  4E75                    2205          Rts
0000202A                          2206  
0000202A                          2207  EA_AN_PNTR  ; Adds (An) EA to string
0000202A  1CFC 0028               2208          Move.B  #'(', (A6)+
0000202E  1CFC 0041               2209          Move.B  #'A', (A6)+
00002032  0600 0030               2210          Add.B   #$30, D0
00002036  1CC0                    2211          Move.B  D0, (A6)+
00002038  1CFC 0029               2212          Move.B  #')', (A6)+
0000203C                          2213                  
0000203C  4E75                    2214          Rts
0000203E                          2215          
0000203E                          2216  EA_AN_INC   ; Adds (An)+ EA to string
0000203E  1CFC 0028               2217          Move.B  #'(', (A6)+
00002042  1CFC 0041               2218          Move.B  #'A', (A6)+
00002046  0600 0030               2219          Add.B   #$30, D0
0000204A  1CC0                    2220          Move.B  D0, (A6)+
0000204C  1CFC 0029               2221          Move.B  #')', (A6)+
00002050  1CFC 002B               2222          Move.B  #'+', (A6)+
00002054                          2223                  
00002054  4E75                    2224          Rts 
00002056                          2225          
00002056                          2226  EA_AN_DEC   ; Adds -(An) EA to string
00002056  1CFC 002D               2227          Move.B  #'-', (A6)+
0000205A  1CFC 0028               2228          Move.B  #'(', (A6)+
0000205E  1CFC 0041               2229          Move.B  #'A', (A6)+
00002062  0600 0030               2230          Add.B   #$30, D0
00002066  1CC0                    2231          Move.B  D0, (A6)+
00002068  1CFC 0029               2232          Move.B  #')', (A6)+
0000206C                          2233                  
0000206C  4E75                    2234          Rts 
0000206E                          2235  
0000206E                          2236  EA_WORD_ADDR    ; Adds $Word to string
0000206E  3C1B                    2237          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
00002070                          2238          
00002070  1CFC 0024               2239          Move.B  #'$', (A6)+
00002074                          2240          
00002074  BC7C 8000               2241          Cmp.W   #$8000, D6          ; Word address is less than 8000
00002078  6500 000C               2242          Bcs     EA_SIGN_EXT_16
0000207C                          2243          
0000207C  BC7C 8000               2244          Cmp.W   #$8000, D6          ; Word address is greater than 8000
00002080  6400 001A               2245          Bcc     EA_SIGN_EXT_32
00002084                          2246          
00002084  4E75                    2247          Rts
00002086                          2248                  
00002086                          2249  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
00002086  1CFC 0030               2250          Move.B  #'0', (A6)+
0000208A  1CFC 0030               2251          Move.B  #'0', (A6)+
0000208E  1CFC 0030               2252          Move.B  #'0', (A6)+
00002092  1CFC 0030               2253          Move.B  #'0', (A6)+
00002096                          2254          
00002096  4EB8 12B0               2255          Jsr     hex_to_ASCII_W       
0000209A                          2256          
0000209A  4E75                    2257          Rts
0000209C                          2258  
0000209C                          2259  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
0000209C  1CFC 0046               2260          Move.B  #'F', (A6)+
000020A0  1CFC 0046               2261          Move.B  #'F', (A6)+
000020A4  1CFC 0046               2262          Move.B  #'F', (A6)+
000020A8  1CFC 0046               2263          Move.B  #'F', (A6)+
000020AC                          2264          
000020AC  4EB8 12B0               2265          Jsr     hex_to_ASCII_W   
000020B0                          2266          
000020B0  4E75                    2267          Rts
000020B2                          2268                  
000020B2                          2269  EA_LONG_ADDR    ; Adds $Long to string
000020B2  2C1B                    2270          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
000020B4                          2271          
000020B4  1CFC 0024               2272          Move.B  #'$', (A6)+
000020B8                          2273          
000020B8  4EB8 1290               2274          Jsr     hex_to_ASCII_L
000020BC                          2275  
000020BC  4E75                    2276          Rts
000020BE                          2277                  
000020BE                          2278  
000020BE                          2279  EA_IMM_BYTE ; Finds the immediate byte data
000020BE  3C1B                    2280          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
000020C0                          2281          
000020C0  1CFC 0023               2282          Move.B  #'#', (A6)+         
000020C4  1CFC 0024               2283          Move.B  #'$', (A6)+         
000020C8                          2284          
000020C8  4EB8 12D0               2285          Jsr     hex_to_ASCII_B    ; Add the byte to the string
000020CC                          2286          
000020CC  4E75                    2287          Rts
000020CE                          2288                  
000020CE                          2289  EA_IMM_WORD ; Finds the immediate word data
000020CE  3C1B                    2290          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
000020D0                          2291          
000020D0  1CFC 0023               2292          Move.B  #'#', (A6)+         
000020D4  1CFC 0024               2293          Move.B  #'$', (A6)+         
000020D8                          2294          
000020D8  4EB8 12B0               2295          Jsr     hex_to_ASCII_W    ; Add the word to the string
000020DC                          2296          
000020DC  4E75                    2297          Rts
000020DE                          2298          
000020DE                          2299  EA_IMM_LONG ; Finds the immediate long data
000020DE  2C1B                    2300          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
000020E0                          2301          
000020E0  1CFC 0023               2302          Move.B  #'#', (A6)+
000020E4  1CFC 0024               2303          Move.B  #'$', (A6)+
000020E8                          2304          
000020E8  4EB8 1290               2305          Jsr     hex_to_ASCII_L    ; Add the long to the string
000020EC                          2306          
000020EC  4E75                    2307          Rts
000020EE                          2308          
000020EE                          2309  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
000020EE  4EB9 00002188           2310          Jsr     GET3TO5                 ; Get source mode
000020F4  1A00                    2311          Move.B  D0, D5                  ; Move source mode to D5
000020F6  4EB9 0000219A           2312          Jsr     Get0TO2                 ; Get source register
000020FC                          2313          
000020FC                          2314          ; List of valid effective addresses
000020FC  BA3C 0000               2315          Cmp.B   #Dn_Mode, D5            ; Dn
00002100  6700 FF10               2316          Beq     EA_DN
00002104                          2317          
00002104  BA3C 0001               2318          Cmp.B   #An_Mode, D5            ; An
00002108  6700 FF14               2319          Beq     EA_AN
0000210C                          2320          
0000210C  BA3C 0002               2321          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00002110  6700 FF18               2322          Beq     EA_AN_PNTR
00002114                          2323          
00002114  BA3C 0003               2324          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00002118  6700 FF24               2325          Beq     EA_AN_INC
0000211C                          2326          
0000211C  BA3C 0004               2327          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00002120  6700 FF34               2328          Beq     EA_AN_DEC
00002124                          2329          
00002124                          2330          ; Comparing registers at this point because modes are the same
00002124  B03C 0000               2331          Cmp.B   #Word_Reg, D0           ; (xxx).W
00002128  6700 FF44               2332          Beq     EA_WORD_ADDR
0000212C                          2333          
0000212C  B03C 0001               2334          Cmp.B   #Long_Reg, D0           ; (xxx).L
00002130  6780                    2335          Beq     EA_LONG_ADDR
00002132                          2336          
00002132  4E75                    2337          Rts
00002134                          2338      
00002134                          2339  
00002134                          2340  ;---------------- Bit Chopping Sub Routines ----------------;
00002134                          2341  ; These Sub Routines Chop a WORD size piece of data from
00002134                          2342  ; Data register 4 into a smaller piece, leaving just the
00002134                          2343  ; Piece in register 0 while leaving the original piece
00002134                          2344  ; of data intact.
00002134                          2345  
00002134                          2346  ; REGISTERS USED: D0, D1, D4 (const input)
00002134                          2347  
00002134                          2348  GET12TO15   ;1001 0000 0000 0000 -> 1001
00002134  4280                    2349                  CLR.L   D0      
00002136  3004                    2350                  Move.W  D4, D0      
00002138                          2351                  
00002138  123C 000C               2352                  Move.B  #12, D1     
0000213C  E268                    2353                  LSR.W       D1, D0      
0000213E                          2354                  
0000213E  4E75                    2355                  RTS
00002140                          2356                  
00002140                          2357  GET12TO13
00002140  4280                    2358          CLR.L   D0
00002142  3004                    2359          Move.W  D4, D0
00002144                          2360          
00002144  123C 0002               2361          Move.B  #2, D1
00002148  E368                    2362          LSL     D1, D0
0000214A                          2363          
0000214A  123C 000E               2364          Move.B  #14, D1
0000214E  E268                    2365          LSR     D1, D0
00002150                          2366          
00002150  4E75                    2367          RTS             
00002152                          2368  
00002152                          2369  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
00002152  4280                    2370                  CLR.L   D0      ; Clear out D0
00002154  3004                    2371                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002156                          2372                  
00002156  123C 0004               2373                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
0000215A  E368                    2374                  LSL.W   D1, D0      ; Move the string all the way to the left
0000215C                          2375                  
0000215C  123C 000C               2376                  Move.B  #12, D1     ; Change the amount of bits shifted
00002160  E268                    2377                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
00002162                          2378                  
00002162  4E75                    2379                  RTS         ; Return from the subroutine
00002164                          2380                      
00002164                          2381  GET9TO11    ; 0000 1010 0000 0000 -> 101    
00002164  4280                    2382                  CLR.L   D0      ; Clear out D0
00002166  3004                    2383                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002168                          2384                  
00002168  123C 0004               2385                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
0000216C  E368                    2386                  LSL.W   D1, D0      ; Move the string all the way to the left
0000216E                          2387                  
0000216E  123C 000D               2388                  Move.B  #13, D1     ; Change the amount of bits shifted
00002172  E268                    2389                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
00002174                          2390                  
00002174  4E75                    2391                  RTS         ; Return from the subroutine
00002176                          2392                  
00002176                          2393  GET6TO8     ; 0000 0001 1000 0000 -> 110
00002176  4280                    2394                  CLR.L   D0
00002178  3004                    2395                  Move.W  D4, D0
0000217A                          2396                  
0000217A  123C 0007               2397                  Move.B  #7, D1
0000217E  E368                    2398                  LSL.W   D1, D0
00002180                          2399                  
00002180  123C 000D               2400                  Move.B  #13, D1
00002184  E268                    2401                  LSR.W       D1, D0
00002186                          2402                  
00002186  4E75                    2403                  RTS
00002188                          2404                  
00002188                          2405  GET3TO5     ; 0000 0000 0011 1000 -> 111
00002188  4280                    2406                  CLR.L   D0
0000218A  3004                    2407                  Move.W  D4, D0
0000218C                          2408                  
0000218C  123C 000A               2409                  Move.B  #10, D1
00002190  E368                    2410                  LSL.W   D1, D0
00002192                          2411                  
00002192  123C 000D               2412                  Move.B  #13, D1
00002196  E268                    2413                  LSR.W       D1, D0
00002198                          2414                  
00002198  4E75                    2415                  RTS
0000219A                          2416  GET0TO2     ; 0000 0000 0000 0011 -> 011
0000219A  4280                    2417                  CLR.L   D0
0000219C  3004                    2418                  Move.W  D4, D0
0000219E                          2419                  
0000219E  123C 000D               2420                  Move.B  #13, D1
000021A2  E368                    2421                  LSL.W   D1, D0
000021A4                          2422                  
000021A4  123C 000D               2423                  Move.B  #13, D1
000021A8  E268                    2424                  LSR.W       D1, D0
000021AA                          2425                  
000021AA  4E75                    2426                  RTS
000021AC                          2427  GETBIT8     ; 0000 0001 0000 0000 -> 1
000021AC  4280                    2428                  CLR.L   D0
000021AE  3004                    2429                  Move.W  D4, D0
000021B0                          2430                  
000021B0  123C 0007               2431                  Move.B  #7, D1
000021B4  E368                    2432                  LSL.W   D1, D0
000021B6                          2433                  
000021B6  123C 000F               2434                  Move.B  #15, D1
000021BA  E268                    2435                  LSR.W       D1, D0
000021BC                          2436                  
000021BC  4E75                    2437                  RTS
000021BE                          2438                  
000021BE                          2439  GET9AND10    ; 0000 0110 0000 0000 -> 11
000021BE  4280                    2440                  CLR.L   D0
000021C0  3004                    2441                  Move.W  D4, D0
000021C2                          2442                  
000021C2  123C 0005               2443                  Move.B  #5, D1
000021C6  E368                    2444                  LSL.W   D1, D0
000021C8                          2445                  
000021C8  123C 000E               2446                  Move.B  #14, D1
000021CC  E268                    2447                  LSR.W   D1, D0
000021CE                          2448                  
000021CE  4E75                    2449                  RTS             
000021D0                          2450                  
000021D0                          2451  GET6AND7    
000021D0  4280                    2452                  CLR.L   D0
000021D2  3004                    2453                  Move.W  D4, D0
000021D4                          2454                  
000021D4  123C 0008               2455                  Move.B  #8, D1
000021D8  E368                    2456                  LSL.W   D1, D0
000021DA                          2457                  
000021DA  123C 000E               2458                  Move.B  #14, D1
000021DE  E268                    2459                  LSR.W   D1, D0
000021E0                          2460                  
000021E0  4E75                    2461                  RTS
000021E2                          2462                  
000021E2                          2463  GET7AND8    
000021E2  4280                    2464                  CLR.L   D0
000021E4  3004                    2465                  Move.W  D4, D0
000021E6                          2466                  
000021E6  123C 0007               2467                  Move.B  #7, D1
000021EA  E368                    2468                  LSL.W   D1, D0
000021EC                          2469                  
000021EC  123C 000E               2470                  Move.B  #14, D1
000021F0  E268                    2471                  LSR.W   D1, D0
000021F2                          2472                  
000021F2  4E75                    2473                  RTS             
000021F4                          2474                  
000021F4                          2475  GET3AND4    
000021F4  4280                    2476                  CLR.L   D0
000021F6  3004                    2477                  Move.W  D4, D0
000021F8                          2478                  
000021F8  123C 000B               2479                  Move.B  #11, D1
000021FC  E368                    2480                  LSL.W   D1, D0
000021FE                          2481                  
000021FE  123C 000E               2482                  Move.B  #14, D1
00002202  E268                    2483                  LSR.W   D1, D0
00002204                          2484                  
00002204  4E75                    2485                  RTS
00002206                          2486                  
00002206                          2487  GETBIT5
00002206  4280                    2488          Clr.L   D0
00002208  3004                    2489          Move.W  D4, D0
0000220A                          2490          
0000220A  123C 000A               2491          Move.B  #10, D1
0000220E  E368                    2492          Lsl     D1, D0
00002210                          2493          
00002210  123C 000F               2494          Move.B  #15, D1
00002214  E268                    2495          Lsr     D1, D0
00002216                          2496          
00002216  4E75                    2497          Rts
00002218                          2498  
00002218                          2499  GET0TO7
00002218  4280                    2500          Clr.L   D0
0000221A  3004                    2501          Move.W  D4, D0
0000221C                          2502          
0000221C  123C 0008               2503          Move.B  #8, D1
00002220  E368                    2504          Lsl     D1, D0
00002222                          2505          
00002222  E268                    2506          Lsr     D1, D0
00002224                          2507          
00002224  4E75                    2508          Rts
00002226                          2509          
00002226                          2510  GETBIT10
00002226  4280                    2511          Clr.L   D0
00002228  3004                    2512          Move.W  D4, D0
0000222A                          2513          
0000222A  123C 0005               2514          Move.B  #5, D1
0000222E  E368                    2515          Lsl     D1, D0
00002230                          2516          
00002230  123C 000F               2517          Move.B  #15, D1
00002234  E268                    2518          Lsr     D1, D0
00002236                          2519          
00002236  4E75                    2520          Rts
00002238                          2521          
00002238                          2522  GET6TO7
00002238  4280                    2523          Clr.L   D0
0000223A  3004                    2524          Move.W  D4, D0
0000223C                          2525          
0000223C  123C 0008               2526          Move.B  #8, D1
00002240  E368                    2527          Lsl     D1, D0
00002242                          2528          
00002242  123C 000E               2529          Move.B  #14, D1
00002246  E268                    2530          Lsr     D1, D0
00002248                          2531          
00002248  4E75                    2532          Rts
0000224A                          2533  
0000224A                          2534  GET3TO8    ; 0000 0000 1100 0000 -> 11
0000224A  4280                    2535                  CLR.L   D0
0000224C  3004                    2536                  Move.W  D4, D0
0000224E                          2537                  
0000224E  123C 0007               2538                  Move.B  #7, D1
00002252  E368                    2539                  LSL.W   D1, D0
00002254                          2540                  
00002254  123C 000A               2541                  Move.B  #10, D1
00002258  E268                    2542                  LSR.W   D1, D0
0000225A                          2543                  
0000225A  4E75                    2544                  RTS
0000225C                          2545  
0000225C                          2546  GET6TO11    ; 0000 0000 1100 0000 -> 11
0000225C  4280                    2547                  CLR.L   D0
0000225E  3004                    2548                  Move.W  D4, D0
00002260                          2549                  
00002260  123C 0004               2550                  Move.B  #4, D1
00002264  E368                    2551                  LSL.W   D1, D0
00002266                          2552                  
00002266  123C 000A               2553                  Move.B  #10, D1
0000226A  E268                    2554                  LSR.W   D1, D0
0000226C                          2555                  
0000226C  4E75                    2556                  RTS        
0000226E                          2557                  
0000226E                          2558             
0000226E                          2559  ;-----------Constants/Messages-------------------------------------------------
0000226E= 09 2D 2D 2D 2D 2D ...   2560  intro_stuff     DC.B    HT,'------------------------------------------------------',CR,LF,0
000022A8                          2561  
000022A8= 09 20 57 65 6C 63 ...   2562  intro_msg       DC.B    HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000022E0= 09 20 43 72 65 61 ...   2563                  DC.B    HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
00002319                          2564         
00002319= 50 6C 65 61 73 65 ...   2565  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
00002352= 50 6C 65 61 73 65 ...   2566  end_address1    DC.B    'Please enter the ending address from $',0
00002379= 20 74 6F 20 24 30 ...   2567  end_address2    DC.B    ' to $00FFFFFE: ',0
00002389= 54 68 61 6E 6B 20 ...   2568  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
000023BB= 57 6F 75 6C 64 20 ...   2569  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000023EB= 48 69 74 20 65 6E ...   2570  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
00002419                          2571  
00002419= 09 41 64 64 72 65 ...   2572  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
0000244F= 09 59 6F 75 20 6E ...   2573  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
0000247B= 09 50 6C 65 61 73 ...   2574  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
000024B3                          2575  
000024B4                          2576  start_input     DS.L    2               ; Allocates space for start address
000024BC                          2577  end_input       DS.L    2               ; Allocates space for end address
000024C4                          2578  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
000024CC                          2579  hit_enter       DS.L    2               ; User input to hit enter
000024D4                          2580  line_count      DS.L    1               ; Holds the display line count  
000024D8                          2581  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
00002618                          2582  valid_data      DS.L    80              ; Instructions that we converted
00002758                          2583                  
00002758                          2584                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            14F2
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           247B
ASK_INPUT           24C4
ASK_USER            23BB
BADADDR_INPUT       2419
BAD_BUFF            1134
BEGIN               0
BIT_SHIFT           1532
BIT_SHIFT_MEM       1544
BIT_SHIFT_REG       1566
BRANCH_CONDITIONALS  1470
CHECK_10_LINES      118A
CHECK_INPUT         1244
CHK_BOUND           1336
CMP_EOR             1588
CONVERT_HEX         12F0
CR                  D
DISASSEMBLE         10DE
DISPLAY_DATA        114E
DN_MODE             0
DONE                1222
DONE_CONVERTING     1312
EA_0TO5             20EE
EA_ADD              1D9E
EA_ADDA             1DD2
EA_ADDQ             1E5A
EA_ADDQ_CHECK_8     1E6C
EA_ADDQ_DEST        1E90
EA_ADDQ_IMMEDIATE   1E84
EA_ADD_ADDRESS      1E1A
EA_ADD_OPMODE_DEST  1E02
EA_ADD_OPMODE_SOURCE  1DEA
EA_ADD_SIZE         1E2A
EA_AN               201E
EA_AND              1EA4
EA_AN_DEC           2056
EA_AN_INC           203E
EA_AN_PNTR          202A
EA_BIT_SHIFT        1EBC
EA_BRANCH           1FE8
EA_BRANCH_16_BIT    1FFE
EA_BRANCH_ADD_DIS   2006
EA_BTST             1F9E
EA_BTST_ADDRESS     1FD4
EA_BTST_DN          1FB2
EA_BTST_IMM         1FC6
EA_CMP              1E9C
EA_DIVS             1F9A
EA_DN               2012
EA_EOR              1EA8
EA_IMMEDIATE        1F3A
EA_IMMEDIATE_DEST   1F6A
EA_IMMEDIATE_SIZE   1F4C
EA_IMM_BYTE         20BE
EA_IMM_LONG         20DE
EA_IMM_WORD         20CE
EA_JSR              1EB8
EA_LEA              1EA0
EA_LONG_ADDR        20B2
EA_MOVE             1B5A
EA_MOVEM            1BE4
EA_MOVEM_ADD_LAST_REG  1CCE
EA_MOVEM_ADD_SINGLE_REG  1CAE
EA_MOVEM_CARRY_CLEAR  1C8E
EA_MOVEM_CARRY_SET  1C6E
EA_MOVEM_FIRST_REG  1C9E
EA_MOVEM_LAST_REG   1CC0
EA_MOVEM_LIST_END   1C58
EA_MOVEM_LIST_LOOP  1C3C
EA_MOVEM_MEM_TO_REG  1C20
EA_MOVEM_POST_INC   1C64
EA_MOVEM_PRE_DEC    1C5A
EA_MOVEM_REG        1CE2
EA_MOVEM_REG_TO_MEM  1C0A
EA_MOVE_DEST        1B7C
EA_MOVE_SIZE        1BC4
EA_MOVE_SOURCE      1B6C
EA_MULS             1F72
EA_MULS_ADDRESS     1F8A
EA_NEG              1EAC
EA_NOT              1EB4
EA_SHIFT_CHECK_8    1EEE
EA_SHIFT_COMMA      1F28
EA_SHIFT_DN         1F16
EA_SHIFT_IMMEDIATE  1F06
EA_SHIFT_MEMORY     1ED2
EA_SHIFT_REGISTER   1EDA
EA_SIGN_EXT_16      2086
EA_SIGN_EXT_32      209C
EA_SUB              1E98
EA_WORD_ADDR        206E
END                 FFFFFE
ENDING              2389
END_ADDRESS1        2352
END_ADDRESS2        2379
END_ERROR           131E
END_INPUT           24BC
GET0TO2             219A
GET0TO7             2218
GET12TO13           2140
GET12TO15           2134
GET3AND4            21F4
GET3TO5             2188
GET3TO8             224A
GET6AND7            21D0
GET6TO11            225C
GET6TO7             2238
GET6TO8             2176
GET7AND8            21E2
GET8TO11            2152
GET9AND10           21BE
GET9TO11            2164
GETBIT10            2226
GETBIT5             2206
GETBIT8             21AC
GOOD_BUFF           1144
HEX_ASCII_LOOPB     12DA
HEX_ASCII_LOOPL     129A
HEX_ASCII_LOOPW     12BA
HEX_TO_ASCII_B      12D0
HEX_TO_ASCII_L      1290
HEX_TO_ASCII_W      12B0
HIT_ENTER           24CC
HIT_ENTER_MSG       23EB
HT                  9
ILLEGAL             1158
ILLEGAL_DATA        24D8
IMMEDIATE_BTST      13D8
IMM_MODE            7
IMM_REG             4
INTRO_MSG           22A8
INTRO_STUFF         226E
INVALID             1288
IS_LETTER           127A
IS_NUMBER           1272
JSR_CHECK           145E
LF                  A
LINE_COUNT          24D4
LOAD_BAD_INPUT      1328
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1AD2
MAIN_LOOP           1124
MAKE_LETTER         1308
MAKE_NUMBER         12FC
ODD_ERR             134A
ODD_INPUT           244F
OP_ADD              16A0
OP_ADDQ             15F6
OP_ADD_ADDR         16CA
OP_ADD_ADDRESS_VERSION  1AE6
OP_AND              19AA
OP_AS_MEM           19E4
OP_AS_REG           19C6
OP_BRANCH           183E
OP_BRA_CC           1880
OP_BRA_CS           1896
OP_BRA_EQ           18C2
OP_BRA_GE           1930
OP_BRA_GT           195C
OP_BRA_HIGH         1854
OP_BRA_LE           1972
OP_BRA_LOW          186A
OP_BRA_LT           1946
OP_BRA_MI           191A
OP_BRA_NE           18AC
OP_BRA_PL           1904
OP_BRA_VC           18D8
OP_BRA_VS           18EE
OP_BTST             16DE
OP_CHECK_ADDRESS_VERSION  1ADC
OP_CHECK_DATA_SIZE  1AEC
OP_CHECK_DATA_SIZE_ADDR  1B0C
OP_CMP              1A68
OP_CMPI             1754
OP_CMP_ADDR         1A92
OP_CODE_TREE        135C
OP_DIVS             1632
OP_EOR              1AA6
OP_EORI             1734
OP_JSR              1828
OP_LEA              1774
OP_LS_MEM           1A1A
OP_LS_REG           19FC
OP_MOVE             15AA
OP_MOVEM            17C2
OP_MOVEM_DATA       1802
OP_MOVE_DATA        15DC
OP_MULS             1988
OP_NEG              178A
OP_NOT              17A6
OP_ORI              16F8
OP_RO_MEM           1A50
OP_RO_REG           1A32
OP_RTS              1814
OP_SET_BAD_BUFFER   1AC2
OP_SET_DATA_BYTE    1B1E
OP_SET_DATA_LONG    1B32
OP_SET_DATA_WORD    1B28
OP_SHIFT_DIRECTION  1B3C
OP_SHIFT_LEFT       1B54
OP_SHIFT_RIGHT      1B4E
OP_SUB              1662
OP_SUBI             1714
OP_SUB_ADDR         168C
OP_TAB              1AC8
PROMPT_END          107A
PROMPT_FOR_DATA     119C
PROMPT_START        1024
PROMPT_TO_RERUN     11BA
RERUN_ERR_MSG       1214
RETURN              128C
SINGLE_OPERATOR_CODES  141E
START               1000
START_ADDRESS       2319
START_ERROR         1314
START_INPUT         24B4
VALID_DATA          2618
VALID_END           10BE
VALID_START         1058
VERIFIED            1282
VERIFY_INPUT        1232
WORD_MODE           7
WORD_REG            0
