00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/1/2014 11:53:59 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 00002240             30                  LEA     intro_stuff, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 0000227A             33                  LEA     intro_msg, A1       ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 00002240             36                  LEA     intro_stuff, A1     ; Load introduction
0000101E  103C 000D                 37                  MOVE.B  #13, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024                            39                  
00001024                            40  
00001024                            41  *-----------Prompt For Starting Address---------------------                  
00001024  43F9 000022EB             42  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
0000102A  103C 000E                 43                  MOVE.B  #14,D0              ; Load task code for display
0000102E  4E4F                      44                  TRAP    #15                 ; Display prompt message
00001030                            45                  
00001030  43F9 00002486             46                  LEA     start_input,A1      ; Load address to store user's input
00001036  103C 0002                 47                  MOVE.B  #2,D0               ; Load task code for user input
0000103A  4E4F                      48                  TRAP    #15                 ; Ask for user input
0000103C  4EB9 00001232             49                  JSR     verify_input        ; Verifies user input string
00001042  B83C 0001                 50                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001046  6700 0010                 51                  BEQ     valid_start         ; Go to valid start if equal 
0000104A                            52                  
0000104A  43F9 000023EB             53                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
00001050  103C 000E                 54                  MOVE.B  #14,D0              ; Load task code for display
00001054  4E4F                      55                  TRAP    #15                 ; Display bad input message
00001056  60CC                      56                  BRA     prompt_start        ; Go back beginning, asking for start address
00001058                            57  
00001058  4EB9 00001336             58  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000105E  B67C FFFF                 59                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
00001062  67C0                      60                  BEQ     prompt_start        ; Go back and ask for correct input
00001064  7C00                      61                  MOVE.L  #begin,D6           ; Store minimum address in D6
00001066  B686                      62                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001068  6D00 02AA                 63                  BLT     start_error         ; Then, start address is too low
0000106C  2C3C 00FFFFFE             64                  MOVE.L  #end,D6             ; Store max end address for comparison
00001072  B686                      65                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001074  6E00 029E                 66                  BGT     start_error         ; Then, start address is too high
00001078  2643                      67                  MOVEA.L D3,A3               ; Load starting address                 
0000107A                            68  
0000107A                            69  *-----------Prompt for Ending Address-----------------------            
0000107A  43F9 00002324             70  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
00001080  103C 000E                 71                  MOVE.B  #14,D0              ; Load task code for display
00001084  4E4F                      72                  TRAP    #15                 ; Display prompt message
00001086  43F9 00002486             73                  LEA     start_input,A1      ; Load starting address
0000108C  4E4F                      74                  TRAP    #15                 ; Display starting address
0000108E  43F9 0000234B             75                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
00001094  4E4F                      76                  TRAP    #15                 ; Display prompt message
00001096  43F9 0000248E             77                  LEA     end_input,A1        ; Ask for ending address
0000109C  103C 0002                 78                  MOVE.B  #2,D0               ; Load task code for input
000010A0  4E4F                      79                  TRAP    #15                 ; Prompt for input
000010A2  4EB9 00001232             80                  JSR     verify_input        ; Verifies user input string
000010A8  B83C 0001                 81                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010AC  6700 0010                 82                  BEQ     valid_end           ; Now validate the ending address
000010B0  43F9 000023EB             83                  LEA     badAddr_input,A1        ; Else, bad input
000010B6  103C 000E                 84                  MOVE.B  #14,D0              ; Load task code for display
000010BA  4E4F                      85                  TRAP    #15                 ; Display bad input message
000010BC  60BC                      86                  BRA     prompt_end          ; Restart process
000010BE                            87  
000010BE  4EB9 00001336             88  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
000010C4  B67C FFFF                 89                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
000010C8  67B0                      90                  BEQ     prompt_end          ; Go back and ask for correct input
000010CA  2C3C 00FFFFFE             91                  MOVE.L  #end,D6             ; Move max address to compare with input
000010D0  B686                      92                  CMP.L   D6,D3               ; Is input higher than max
000010D2  6E00 024A                 93                  BGT     end_error           ; Input address is too high
000010D6  B68B                      94                  CMP.L   A3,D3               ; Is input at or above minimum address
000010D8  6D00 0244                 95                  BLT     end_error           ; Input address is too low
000010DC  2843                      96                  MOVEA.L D3,A4               ; Load ending address
000010DE                            97                                 
000010DE                            98  ;-------------- disassemble ---------------------------------------------------
000010DE                            99  ; -- Reads the data from the specified memory locations
000010DE                           100  ; -- Passes the data over to OP-code to verify the instruction
000010DE                           101  ; -- Decodes the word data from the specified memory location until the end
000010DE                           102  ; -- Checks for illegal data and valid data with the bad buffer bit
000010DE                           103  ;------------------------------------------------------------------------------
000010DE  4283                     104  disassemble     CLR.L   D3                  ; Clear for IO usage
000010E0  4284                     105                  CLR.L   D4                  ; Clear for OP Code usage              
000010E2  B7CC                     106                  CMP.L   A4,A3               ; At the end address?
000010E4  6E00 00D4                107                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
000010E8                           108                  
000010E8  4EB9 0000118A            109                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
000010EE  2C0B                     110                  MOVE.L  A3,D6               ; Store current address
000010F0                           111                  
000010F0  4DF9 000024AA            112                  LEA     illegal_data,A6     ; Load illegal data's address
000010F6  4EB9 00001290            113                  JSR     hex_to_ASCII_L      ; Store address to memory for display
000010FC  204E                     114                  MOVEA.L A6,A0               ; Store current location of illegal data
000010FE                           115                  
000010FE  4BF9 000025EA            116                  LEA     valid_data,A5       ; Store current address to memory
00001104                           117                  
00001104  4DF9 000025EA            118                  LEA     valid_data,A6       ; Store current address to memory
0000110A  4EB9 00001290            119                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
00001110  1CFC 0009                120                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001114                           121                  
00001114  381B                     122                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001116  4EB9 0000135C            123                  JSR     OP_CODE_TREE        ; Go to OP code jump table
0000111C                           124                  
0000111C  BE3C 0001                125                  CMP.B   #1,D7               ; Bad buffer set?
00001120  6700 0036                126                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001124                           127  main_loop
00001124                           128                  ; Store new line in memory
00001124  1CFC 000A                129                  MOVE.B  #LF,(A6)+
00001128  1CFC 000D                130                  MOVE.B  #CR,(A6)+
0000112C  BE3C 0001                131                  CMP.B   #1,D7               ; Bad buffer set?
00001130  6600 0012                132                  BNE     good_buff           ; Good Buffer, go prep for display
00001134                           133                  
00001134  4287                     134  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001136  1CFC 0000                135                  MOVE.B  #00,(A6)+           ; Add null terminator
0000113A  43F9 000024AA            136                  LEA     illegal_data,A1     ; Load the illegal data for display
00001140  6000 000C                137                  BRA     display_data        ; Go to display data
00001144                           138                  
00001144  1CFC 0000                139  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001148  43F9 000025EA            140                  LEA     valid_data,A1       ; Load the valid data for display
0000114E                           141                  
0000114E  4280                     142  display_data    CLR.L   D0                  ; Clear for TASK TRAP
00001150  103C 000E                143                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001154  4E4F                     144                  TRAP    #15                 ; to in memory.
00001156  6086                     145                  BRA     disassemble         ; Done disassembling the word, next word                
00001158                           146                                                 
00001158                           147  ILLEGAL         ; word data from memory is not a required instruction
00001158  4BF9 000024AA            148                  LEA     illegal_data,A5     ; Store current address to memory
0000115E  2C48                     149                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
00001160  1CFC 0009                150                  MOVE.B  #HT,(A6)+           ; Store TAB 
00001164  1CFC 0044                151                  MOVE.B  #'D',(A6)+          ; Store DATA
00001168  1CFC 0041                152                  MOVE.B  #'A',(A6)+
0000116C  1CFC 0054                153                  MOVE.B  #'T',(A6)+
00001170  1CFC 0041                154                  MOVE.B  #'A',(A6)+
00001174  4EB9 00001AAC            155                  JSR     OP_TAB              ; Set up third collumn
0000117A  1CFC 0024                156                  MOVE.B  #'$',(A6)+
0000117E                           157                  
0000117E                           158                  ; Store 4 hex digits that represent the word into memory
0000117E  4286                     159                  CLR.L   D6
00001180  3C04                     160                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
00001182  4EB9 000012B0            161                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
00001188  609A                     162                  BRA     main_loop           ; Store info to memory as string              
0000118A                           163  
0000118A                           164  ;------------check_10_lines----------------------------------------------------
0000118A                           165  ; -- Prompt user to hit enter when there are 10 lines of data
0000118A                           166  ; -- Then reset the line count and go back to disassemble more data
0000118A                           167  ;------------------------------------------------------------------------------
0000118A                           168  check_10_lines
0000118A  45F9 000024A6            169                  LEA     line_count,A2       ; Assign A2 pointer for line count
00001190  5212                     170                  ADD.B   #1,(A2)             ; Increment counter
00001192  0C12 0014                171                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
00001196  6700 0004                172                  BEQ     prompt_for_data     ; At 31
0000119A  4E75                     173                  RTS                         ; Return to disassemble
0000119C                           174  
0000119C  43F9 000023BD            175  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011A2  103C 000E                176                  MOVE.B  #14,D0              ; Display message
000011A6  4E4F                     177                  TRAP    #15
000011A8  43F9 0000249E            178                  LEA     hit_enter,A1        ; Take user input
000011AE  103C 0002                179                  MOVE.B  #2,D0               
000011B2  4E4F                     180                  TRAP    #15
000011B4  14BC 0000                181                  MOVE.B  #0,(A2)             ; Reset counter
000011B8  4E75                     182                  RTS                         ; Return to disassemble
000011BA                           183  
000011BA                           184  ;------------prompt_to_rerun----------------------------------------------------
000011BA                           185  ; -- Prompt user to rerun or end program
000011BA                           186  ;------------------------------------------------------------------------------
000011BA  43F9 0000238D            187  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011C0  103C 000E                188                  MOVE.B  #14,D0
000011C4  4E4F                     189                  TRAP    #15
000011C6  43F9 00002496            190                  LEA     ask_input,A1        ; Take user input
000011CC  103C 0002                191                  MOVE.B  #2,D0
000011D0  4E4F                     192                  TRAP    #15
000011D2  45F9 000024A6            193                  LEA     line_count,A2       ; Load line count to reset
000011D8  14BC 0000                194                  MOVE.B  #0,(A2)             ; Reset the line_count
000011DC  B23C 0001                195                  CMP.B   #1,D1               ; User input must be the length of 1
000011E0  6E00 0032                196                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
000011E4  6D00 002E                197                  BLT     rerun_err_msg       ; until the user inputs correctly.
000011E8  4240                     198                  CLR     D0                  ; Clear D0 for comparison
000011EA  1039 00002496            199                  MOVE.B  ask_input,D0        ; Load user input for comparison
000011F0  B03C 004E                200                  CMP.B   #'N',D0             ; User input is N
000011F4  6700 002C                201                  BEQ     done                ; End of program if N
000011F8  B03C 006E                202                  CMP.B   #'n',D0             ; User input is n
000011FC  6700 0024                203                  BEQ     done                ; End of program if n
00001200  B03C 0059                204                  CMP.B   #'Y',D0             ; User input is Y
00001204  6700 FE1E                205                  BEQ     prompt_start        ; Run the program again
00001208  B03C 0079                206                  CMP.B   #'y',D0             ; User input is y
0000120C  6700 FE16                207                  BEQ     prompt_start        ; Run the program again
00001210  6000 0002                208                  BRA     rerun_err_msg       ; Bad input, prompt user
00001214                           209                  
00001214  43F9 0000244D            210  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
0000121A  103C 000E                211                  MOVE.B  #14,D0
0000121E  4E4F                     212                  TRAP    #15
00001220  6098                     213                  BRA     prompt_to_rerun     ; Prompt user for rerun           
00001222                           214                  
00001222                           215      
00001222                           216  ;------------End-of-Program----------------------------------------------------                
00001222  43F9 0000235B            217  done            LEA     ending,A1           ; Load ending message
00001228  103C 000D                218                  MOVE.B  #13,D0              ; Load task code for display
0000122C  4E4F                     219                  TRAP    #15                 ; Display ending message
0000122E  4E72 2700                220                  STOP    #$00002700          ; End of program
00001232                           221                  
00001232                           222  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
00001232  4283                     223  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001234  4285                     224                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001236  B205                     225                  CMP.B   D5,D1               ; Check input length, if lower than one
00001238  6700 004E                226                  BEQ     invalid             ; Its an invalid input
0000123C  0C41 0008                227                  CMPI    #$8,D1              ; Check input length, if higher than 8
00001240  6E00 0046                228                  BGT     invalid             ; Its an invalid input
00001244                           229                  
00001244  4282                     230  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001246  1419                     231                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001248  B405                     232                  CMP.B   D5,D2               ; Check to see if next char is null(0)
0000124A  6700 0040                233                  BEQ     return              ; Character is null, end of input
0000124E                           234                  
0000124E  B43C 0046                235                  CMP.B   #70,D2              ; Invalid character if decimal value
00001252  6E00 0034                236                  BGT     invalid             ; is higher than 70.
00001256  B43C 0040                237                  CMP.B   #64,D2              ; Is a letter if decimal value is 
0000125A  6E00 001E                238                  BGT     is_letter           ; between 65 - 70.
0000125E                           239                  
0000125E  B43C 0039                240                  CMP.B   #57,D2              ; Invalid character if decimal value is
00001262  6E00 0024                241                  BGT     invalid             ; between 58 - 64
00001266  B43C 002F                242                  CMP.B   #47,D2              ; Is a number if decimal value is 
0000126A  6E00 0006                243                  BGT     is_number           ; between 48 - 57.
0000126E  6000 0018                244                  BRA     invalid             ; Decimal values below 48 are invalid 
00001272                           245                               
00001272  0402 0030                246  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
00001276  6000 000A                247                  BRA     verified            ; Put character into a register
0000127A                           248                               
0000127A  0402 0037                249  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
0000127E  6000 0002                250                  BRA     verified            ; Put character into a register
00001282                           251                 
00001282  E983                     252  verified        ASL.L   #4,D3               ; Shift hex bit left one
00001284  D602                     253                  ADD.B   D2,D3               ; Add to verified register
00001286  60BC                     254                  BRA     check_input         ; Check the rest of the input                       
00001288                           255                  
00001288  7800                     256  invalid         MOVEQ   #0,D4               ; Invalid address
0000128A  4E75                     257                  RTS                         ; Return to start/end prompt
0000128C                           258                  
0000128C  7801                     259  return          MOVEQ   #1,D4               ; Valid address
0000128E  4E75                     260                  RTS                         ; Return to start/end prompt
00001290                           261                  
00001290                           262  ;----------------------------------------------------------
00001290                           263  ; Convert Hexidecimal to ASCII (Stores into Memory)
00001290                           264  ;
00001290                           265  ; -- At the moment, takes the Illegal data and stores 
00001290                           266  ;    it into memory so that it can be printed later
00001290                           267  ;----------------------------------------------------------
00001290  4281                     268  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
00001292  4282                     269                  CLR.L   D2                      ; Used for shifting left
00001294  4283                     270                  CLR.L   D3                      ; Counter
00001296  123C 001C                271                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
0000129A                           272  hex_ASCII_loopL
0000129A  B63C 0008                273                  CMP.B   #8,D3                   ; Done converting?
0000129E  6700 0072                274                  BEQ     done_converting         ; If equal to 8, done
000012A2  2006                     275                  MOVE.L  D6,D0                   ; Do calculations in D0
000012A4  E5A8                     276                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012A6  E2A8                     277                  LSR.L   D1,D0                   ; Isolate number
000012A8  4EB9 000012F0            278                  JSR     convert_hex
000012AE  60EA                     279                  BRA     hex_ASCII_loopL
000012B0                           280                  
000012B0  4281                     281  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012B2  4282                     282                  CLR.L   D2                      ; Used for shifting left
000012B4  4283                     283                  CLR.L   D3                      ; Counter
000012B6  123C 000C                284                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012BA                           285  hex_ASCII_loopW
000012BA  B63C 0004                286                  CMP.B   #4,D3                   ; Done converting?
000012BE  6700 0052                287                  BEQ     done_converting         ; If equal to 4, done
000012C2  2006                     288                  MOVE.L  D6,D0                   ; Do calculations in D0
000012C4  E568                     289                  LSL.W   D2,D0                   ; Eliminate stuff to the left
000012C6  E268                     290                  LSR.W   D1,D0                   ; Isolate number
000012C8  4EB9 000012F0            291                  JSR     convert_hex
000012CE  60EA                     292                  BRA     hex_ASCII_loopW
000012D0                           293  
000012D0  4281                     294  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
000012D2  4282                     295                  CLR.L   D2                      ; Used for shifting left
000012D4  4283                     296                  CLR.L   D3                      ; Counter
000012D6  123C 0004                297                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
000012DA                           298  hex_ASCII_loopB
000012DA  B63C 0002                299                  CMP.B   #2,D3                   ; Done converting?
000012DE  6700 0032                300                  BEQ     done_converting         ; If equal to 2, done
000012E2  2006                     301                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E4  E528                     302                  LSL.B   D2,D0                   ; Eliminate stuff to the left
000012E6  E228                     303                  LSR.B   D1,D0                   ; Isolate number
000012E8  4EB9 000012F0            304                  JSR     convert_hex
000012EE  60EA                     305                  BRA     hex_ASCII_loopB                  
000012F0                           306  
000012F0  B03C 000A                307  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
000012F4  6D00 0006                308                  BLT     make_number             ; Make it a number, if lower than 10
000012F8  6C00 000E                309                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
000012FC                           310                       
000012FC  0600 0030                311  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
00001300  1CC0                     312                  MOVE.B  D0,(A6)+                ; Store in memory
00001302  5203                     313                  ADD.B   #1,D3                   ; Add to counter
00001304  5802                     314                  ADD.B   #4,D2                   ; Shift left by one digit
00001306  4E75                     315                  RTS                             ; Check next number
00001308                           316                  
00001308  0600 0037                317  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
0000130C  1CC0                     318                  MOVE.B  D0,(A6)+                ; Store to memory
0000130E  5203                     319                  ADD.B   #1,D3                   ; Add to counter
00001310  5802                     320                  ADD.B   #4,D2                   ; Shift left by one digit                 
00001312  4E75                     321  done_converting RTS                             ; Check next number              
00001314                           322  
00001314                           323  ;-----------Error Messages ----------------------------------------------------
00001314  4EB9 00001328            324  start_error     JSR     load_bad_input      ; Print bad input error message
0000131A  4EF8 1024                325                  JMP     prompt_start        ; Return to prompt for start address
0000131E                           326                  
0000131E  4EB9 00001328            327  end_error       JSR     load_bad_input      ; Print bad input error message
00001324  4EF8 107A                328                  JMP     prompt_end          ; Return to prompt for end address
00001328                           329  
00001328  43F9 000023EB            330  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000132E  103C 000D                331                  MOVE.B  #13,D0              ; Load task code for display
00001332  4E4F                     332                  TRAP    #15                 ; Display bad input message
00001334  4E75                     333                  RTS                         ; Return to (start/end)_error
00001336                           334  
00001336  4282                     335  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001338  3403                     336                  MOVE.W  D3,D2               ; Put address in D2 for calulation
0000133A  7202                     337                  MOVE.L  #2,D1               ; Load 2 into D1 for division
0000133C  84C1                     338                  DIVU    D1,D2               ; Divide address by 2
0000133E  4842                     339                  SWAP    D2                  ; Swap contents of D2 to get remainder
00001340  B43C 0001                340                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001344  6700 0004                341                  BEQ     odd_err             ; Go to print out odd bound error message
00001348  4E75                     342                  RTS                         ; Return to valid_(start/end)
0000134A                           343                  
0000134A  43F9 00002421            344  odd_err         LEA     odd_input,A1        ; Load odd input message
00001350  103C 000E                345                  MOVE.B  #14,D0              ; Load task code for display
00001354  4E4F                     346                  TRAP    #15                 ; Display odd input message
00001356  4685                     347                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001358  2605                     348                  MOVE.L  D5,D3               ; Load -1 to returned data register
0000135A  4E75                     349                  RTS                         ; Return to valid_(start/end)
0000135C                           350  
0000135C                           351  OP_CODE_TREE    ; Parses the Op-Code to find what it is
0000135C                           352          
0000135C  B8BC 00004E75            353          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
00001362  6700 0494                354          Beq     OP_RTS
00001366                           355  
00001366  4EB9 00002118            356          Jsr     GET12TO15
0000136C                           357          
0000136C  B03C 0000                358          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
00001370  6700 0066                359          Beq     IMMEDIATE_BTST
00001374                           360          
00001374  B03C 0001                361          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
00001378  6700 0230                362          Beq     OP_MOVE
0000137C                           363          
0000137C  B03C 0003                364          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
00001380  6700 0228                365          Beq     OP_MOVE
00001384                           366  
00001384  B03C 0002                367          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
00001388  6700 0220                368          Beq     OP_MOVE
0000138C                           369          
0000138C  B03C 0004                370          Cmp.B     #%0100, D0       ; not enough info, Single OPs
00001390  6700 008C                371          Beq     SINGLE_OPERATOR_CODES
00001394                           372      
00001394  B03C 0006                373          Cmp.B     #%0110, D0       ; Beqnch conditionals
00001398  6700 00D6                374          Beq     BRANCH_CONDITIONALS
0000139C                           375          
0000139C  B03C 000C                376          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013A0  6700 0150                377          Beq     AND_MULS
000013A4                           378          
000013A4  B03C 000E                379          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013A8  6700 0188                380          Beq     BIT_SHIFT
000013AC                           381          
000013AC  B03C 0005                382          Cmp.B     #%0101, D0       ; Add Quick
000013B0  6700 0244                383          Beq     OP_ADDQ
000013B4                           384          
000013B4  B03C 0008                385          Cmp.B     #%1000, D0       ; Signed Divide
000013B8  6700 0278                386          Beq     OP_DIVS
000013BC                           387          
000013BC  B03C 0009                388          Cmp.B     #%1001, D0       ; Sub & SubA
000013C0  6700 02A0                389          Beq     OP_SUB
000013C4                           390          
000013C4  B03C 000B                391          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
000013C8  6700 01BE                392          Beq     CMP_EOR
000013CC                           393          
000013CC  B03C 000D                394          Cmp.B     #%1101, D0       ; Add & AddA
000013D0  6700 02CE                395          Beq     OP_ADD
000013D4                           396          
000013D4  6000 06D0                397          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
000013D8                           398          
000013D8                           399  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
000013D8                           400          
000013D8  4EB9 0000215A            401          Jsr     GET6TO8         ; Change out test bits
000013DE                           402          
000013DE  B03C 0004                403          Cmp.B     #%100, D0          ; Bit test
000013E2  6700 02FA                404          Beq     OP_BTST
000013E6                           405          
000013E6  4EB9 0000222E            406          Jsr     GET6TO11
000013EC                           407          
000013EC  B03C 0020                408          Cmp.B   #%100000,D0     ;BTST
000013F0  6700 02EC                409          Beq     OP_BTST
000013F4                           410          
000013F4  4EB9 00002148            411          Jsr     GET9TO11        ; Change out test bits
000013FA                           412          
000013FA  B03C 0000                413          Cmp.B     #%000, D0        ; Or I
000013FE  6700 02F8                414          Beq     OP_ORI
00001402                           415          
00001402  B03C 0002                416          Cmp.B     #%010, D0        ; Subtract I
00001406  6700 030C                417          Beq     OP_SUBI
0000140A                           418          
0000140A  B03C 0005                419          Cmp.B     #%101, D0        ; Exclusive or, I
0000140E  6700 0324                420          Beq     OP_EORI
00001412                           421          
00001412  B03C 0006                422          Cmp.B     #%110, D0        ; Compare I
00001416  6700 033C                423          Beq     OP_CMPI
0000141A                           424          
0000141A  6000 068A                425          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
0000141E                           426          
0000141E                           427  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
0000141E                           428  
0000141E  4EB9 00002190            429          Jsr     GETBIT8        ; Change out test bits
00001424                           430          
00001424  B03C 0001                431          Cmp.B     #%1, D0      ; Load effetive address
00001428  6700 034A                432          Beq     OP_LEA
0000142C                           433          
0000142C  4EB9 00002148            434          Jsr     GET9TO11       ; Change out test bits        
00001432                           435  
00001432  B03C 0002                436          Cmp.B     #%010, D0    ; Negate
00001436  6700 0352                437          Beq     OP_NEG
0000143A                           438         
0000143A  B03C 0003                439          Cmp.B     #%011, D0    ; Not
0000143E  6700 0366                440          Beq     OP_NOT
00001442                           441          
00001442  B03C 0004                442          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001446  6700 037A                443          Beq     OP_MOVEM
0000144A                           444          
0000144A  B03C 0006                445          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
0000144E  6700 0372                446          Beq     OP_MOVEM
00001452                           447          
00001452  6000 0652                448          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
00001456                           449  
00001456                           450  JSR_RTS     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
00001456                           451  
00001456  4EB9 0000215A            452          Jsr     GET6TO8        ; Change out test bits        
0000145C                           453  
0000145C  B03C 0001                454          Cmp.B     #%001, D0    ; Return from subroutine
00001460  6700 0396                455          Beq     OP_RTS
00001464                           456          
00001464  B03C 0002                457          Cmp.B     #%010, D0    ; Jump to Subroutine
00001468  6700 03A2                458          Beq     OP_JSR
0000146C                           459          
0000146C  6000 0638                460          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
00001470                           461  
00001470                           462  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
00001470                           463  
00001470  4EB9 00002136            464          Jsr     GET8TO11    ; Change out test bits        
00001476                           465  
00001476  B03C 0000                466          Cmp.B     #%0000, D0   ; Branch
0000147A  6700 03A6                467          Beq     OP_BRANCH      
0000147E                           468          
0000147E  B03C 0002                469          Cmp.B     #%0010, D0   ; High
00001482  6700 03B4                470          Beq     OP_BRA_HIGH
00001486                           471          
00001486  B03C 0003                472          Cmp.B     #%0011, D0   ; Low/same
0000148A  6700 03C2                473          Beq     OP_BRA_LOW
0000148E                           474          
0000148E  B03C 0004                475          Cmp.B     #%0100, D0   ; Carry Clear
00001492  6700 03D0                476          Beq     OP_BRA_CC
00001496                           477          
00001496  B03C 0005                478          Cmp.B     #%0101, D0   ; Carry Set
0000149A  6700 03DE                479          Beq     OP_BRA_CS
0000149E                           480          
0000149E  B03C 0006                481          Cmp.B     #%0110, D0   ; Not Equal
000014A2  6700 03EC                482          Beq     OP_BRA_NE
000014A6                           483          
000014A6  B03C 0007                484          Cmp.B     #%0111, D0   ; Equal
000014AA  6700 03FA                485          Beq     OP_BRA_EQ
000014AE                           486          
000014AE  B03C 0008                487          Cmp.B     #%1000, D0   ; Overflow Clear
000014B2  6700 0408                488          Beq     OP_BRA_VC
000014B6                           489          
000014B6  B03C 0009                490          Cmp.B     #%1001, D0   ; Overflow Set
000014BA  6700 0416                491          Beq     OP_BRA_VS
000014BE                           492          
000014BE  B03C 000A                493          Cmp.B     #%1010, D0   ; Plus
000014C2  6700 0424                494          Beq     OP_BRA_PL
000014C6                           495          
000014C6  B03C 000B                496          Cmp.B     #%1011, D0   ; Minus
000014CA  6700 0432                497          Beq     OP_BRA_MI
000014CE                           498          
000014CE  B03C 000C                499          Cmp.B     #%1100, D0   ; Greater than or Equal
000014D2  6700 0440                500          Beq     OP_BRA_GE
000014D6                           501          
000014D6  B03C 000D                502          Cmp.B     #%1101, D0   ; Less Than
000014DA  6700 044E                503          Beq     OP_BRA_LT
000014DE                           504          
000014DE  B03C 000E                505          Cmp.B     #%1110, D0   ; Greater Than
000014E2  6700 045C                506          Beq     OP_BRA_GT
000014E6                           507          
000014E6  B03C 000F                508          Cmp.B     #%1111, D0   ; Less than or Equal
000014EA  6700 046A                509          Beq     OP_BRA_LE
000014EE                           510          
000014EE  6000 05B6                511          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
000014F2                           512  
000014F2                           513  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
000014F2                           514  
000014F2  4EB9 0000221C            515          Jsr     Get3TO8
000014F8                           516          
000014F8  B03C 0021                517          Cmp.B     #%100001, D0   ; ABCD
000014FC  6700 05A8                518          Beq     OP_SET_BAD_BUFFER        
00001500  B03C 0020                519          Cmp.B     #%100000,D0    ; ABCD
00001504  6700 05A0                520          Beq     OP_SET_BAD_BUFFER        
00001508  B03C 0028                521          Cmp.B     #%101000,D0    ; EXG
0000150C  6700 0598                522          Beq     OP_SET_BAD_BUFFER
00001510  B03C 0029                523          Cmp.B     #%101001,D0    ; EXG
00001514  6700 0590                524          Beq     OP_SET_BAD_BUFFER
00001518  B03C 0031                525          Cmp.B     #%110001,D0    ; EXG
0000151C  6700 FC3A                526          Beq     ILLEGAL        
00001520                           527  
00001520  4EB9 0000215A            528          Jsr     GET6TO8        ; Change out test bits        
00001526                           529  
00001526  B03C 0007                530          Cmp.B     #%111, D0    ; Multiply signed
0000152A  6700 0440                531          Beq     OP_MULS
0000152E                           532          
0000152E  6000 045E                533          Bra     OP_AND      ; Probably AND, check more in OP_AND
00001532                           534          
00001532                           535  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
00001532                           536          
00001532                           537          ; Determine if the shift is Register or Memory shifting
00001532                           538          
00001532  4EB9 000021B4            539          Jsr     GET6AND7
00001538                           540          
00001538  B03C 0003                541          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
0000153C  6700 0006                542          Beq     BIT_SHIFT_MEM
00001540                           543  
00001540  6000 0024                544          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
00001544                           545  
00001544                           546  BIT_SHIFT_MEM
00001544                           547          
00001544  4EB9 000021A2            548          Jsr     GET9AND10         ; Change out test bits
0000154A                           549          
0000154A  B03C 0000                550          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
0000154E  6700 0478                551          Beq     OP_AS_MEM
00001552                           552          
00001552  B03C 0001                553          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001556  6700 04A6                554          Beq     OP_LS_MEM
0000155A                           555          
0000155A  B03C 0003                556          Cmp.B     #%11, D0        ; Rotate (Left or Right)
0000155E  6700 04D4                557          Beq     OP_RO_MEM
00001562                           558          
00001562  6000 0542                559          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001566                           560  
00001566                           561  BIT_SHIFT_REG
00001566                           562          
00001566  4EB9 000021C6            563          Jsr     GET3AND4        ; Change out test bits
0000156C                           564          
0000156C  B03C 0000                565          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001570  6700 0438                566          Beq     OP_AS_REG
00001574                           567          
00001574  B03C 0001                568          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001578  6700 0466                569          Beq     OP_LS_REG
0000157C                           570          
0000157C  B03C 0003                571          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001580  6700 0494                572          Beq     OP_RO_REG
00001584                           573          
00001584  6000 0520                574          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001588                           575  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
00001588                           576          
00001588  4EB9 0000215A            577          Jsr     GET6TO8         ; Change out test bits
0000158E                           578          
0000158E  B03C 0004                579          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
00001592  6700 04F6                580          Beq     OP_EOR
00001596                           581          
00001596  B03C 0005                582          Cmp.B     #%101,D0
0000159A  6700 04EE                583          Beq     OP_EOR
0000159E                           584          
0000159E  B03C 0006                585          Cmp.B     #%110,D0
000015A2  6700 04E6                586          Beq     OP_EOR
000015A6                           587          
000015A6                           588          
000015A6  6000 04A4                589          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015AA                           590  
000015AA                           591  ;---------------------OP_CODE Functions---------------------;
000015AA                           592  ; These Functions have all determined what Op-code or group
000015AA                           593  ; of op-codes I have. The next goal is to Add to the string
000015AA                           594  ; and call the accompying EA function to get the rest of the
000015AA                           595  ; String
000015AA                           596  
000015AA                           597  ; REGISTERS USED: D0, D4 (const), A6
000015AA                           598  
000015AA                           599  ;-----------------------  MOVE  -----------------------------;
000015AA                           600  OP_MOVE
000015AA                           601      ; start string
000015AA                           602      
000015AA  1CFC 004D                603          Move.B  #'M', (A6)+
000015AE  1CFC 004F                604          Move.B  #'O', (A6)+
000015B2  1CFC 0056                605          Move.B  #'V', (A6)+
000015B6  1CFC 0045                606          Move.B  #'E', (A6)+
000015BA                           607      
000015BA                           608      ; is it an address move?
000015BA  4EB9 0000215A            609          Jsr     GET6TO8     ; Get the mode
000015C0  4EB9 00001AC0            610          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
000015C6                           611          
000015C6                           612      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
000015C6                           613      ; But move does not use the Op-mode bits, so i'll do it manually
000015C6                           614      
000015C6  4EB9 00002118            615          Jsr     GET12TO15
000015CC                           616  
000015CC                           617          ; Jump to a sub routine to get the data, so it returns back correctly
000015CC  4EB9 000015DC            618          Jsr     OP_MOVE_DATA
000015D2                           619          
000015D2                           620          ; Put in tabs
000015D2  4EB9 00001AAC            621          Jsr     OP_TAB
000015D8                           622          
000015D8                           623          ; Hand the function off to John
000015D8  6000 0564                624          BRA     EA_MOVE        
000015DC                           625  
000015DC                           626  OP_MOVE_DATA
000015DC                           627          
000015DC  B07C 0001                628          Cmp     #%0001, D0
000015E0  6700 0520                629          Beq     OP_SET_DATA_BYTE
000015E4                           630          
000015E4  B07C 0002                631          Cmp     #%0010, D0
000015E8  6700 052C                632          Beq     OP_SET_DATA_LONG
000015EC                           633          
000015EC  B07C 0003                634          Cmp     #%0011, D0
000015F0  6700 051A                635          Beq     OP_SET_DATA_WORD
000015F4                           636          
000015F4  4E75                     637          Rts
000015F6                           638  
000015F6                           639  ;-----------------------  ADDQ  -----------------------------;
000015F6                           640          
000015F6                           641  OP_ADDQ
000015F6                           642      ; Check fringe cases
000015F6  4EB9 00002190            643          Jsr     GETBIT8
000015FC  B03C 0001                644          Cmp.B   #%1,D0
00001600  6700 04A4                645          Beq     OP_SET_BAD_BUFFER        
00001604  4EB9 000021B4            646          Jsr     GET6AND7
0000160A  B03C 0003                647          Cmp.B   #%11,D0
0000160E  6700 0496                648          Beq     OP_SET_BAD_BUFFER       ; Blong edited, was Bne
00001612                           649  
00001612                           650      ; start string
00001612                           651      
00001612  1CFC 0041                652          Move.B  #'A', (A6)+
00001616  1CFC 0044                653          Move.B  #'D', (A6)+
0000161A  1CFC 0044                654          Move.B  #'D', (A6)+
0000161E  1CFC 0051                655          Move.B  #'Q', (A6)+
00001622                           656          
00001622                           657      ; Check data type        
00001622  4EB9 00001AD0            658          Jsr     OP_CHECK_DATA_SIZE
00001628                           659          
00001628                           660      ; Put in tabs
00001628  4EB9 00001AAC            661          Jsr     OP_TAB
0000162E                           662          
0000162E                           663      ; Hand the function off to John / Blong edited, was EA_IMMEDIATE
0000162E  6000 080E                664          BRA     EA_ADDQ
00001632                           665  
00001632                           666      
00001632                           667  ;------------------  DIVIDE SINGED  -------------------------;
00001632                           668      
00001632                           669  OP_DIVS
00001632                           670      ; One last check to make sure I have the right stuff
00001632                           671      
00001632  4EB9 0000215A            672          Jsr     GET6TO8
00001638  B07C 0007                673          Cmp     #%111,D0
0000163C  6600 0468                674          Bne     OP_SET_BAD_BUFFER
00001640                           675          
00001640                           676      ; start string
00001640                           677      
00001640  1CFC 0044                678          Move.B  #'D', (A6)+
00001644  1CFC 0049                679          Move.B  #'I', (A6)+
00001648  1CFC 0056                680          Move.B  #'V', (A6)+
0000164C  1CFC 0053                681          Move.B  #'S', (A6)+
00001650  1CFC 002E                682          Move.B  #'.', (A6)+
00001654  1CFC 0057                683          Move.B  #'W', (A6)+
00001658                           684          
00001658                           685      ; Put in tabs
00001658  4EB9 00001AAC            686          Jsr     OP_TAB    
0000165E                           687      
0000165E                           688      ; Handoff to John
0000165E                           689          
0000165E  6000 091C                690          BRA     EA_DIVS
00001662                           691  
00001662                           692      
00001662                           693  ;-----------------------  SUB  ------------------------------;    
00001662                           694      
00001662                           695  OP_SUB
00001662                           696      ; start string
00001662                           697      
00001662  1CFC 0053                698          Move.B  #'S', (A6)+
00001666  1CFC 0055                699          Move.B  #'U', (A6)+
0000166A  1CFC 0042                700          Move.B  #'B', (A6)+
0000166E                           701  
0000166E                           702  
0000166E                           703       ; Check for address version
0000166E                           704          
0000166E  4EB9 000021B4            705          Jsr     GET6AND7
00001674  B03C 0003                706          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001678                           707          
00001678  6700 0012                708          Beq     OP_SUB_ADDR
0000167C                           709  
0000167C                           710          ; Don't need to worry about ADDA in V1
0000167C                           711          ; Check data size
0000167C  4EB9 00001AD0            712          Jsr     OP_CHECK_DATA_SIZE
00001682                           713          
00001682                           714          ; Put in tabs
00001682  4EB9 00001AAC            715          Jsr     OP_TAB
00001688                           716          
00001688  6000 07F0                717          BRA     EA_SUB 
0000168C                           718          
0000168C                           719  OP_SUB_ADDR
0000168C                           720          
0000168C  1CFC 0041                721          Move.B  #'A',(A6)+ ; add to the string
00001690                           722          
00001690                           723          ; Find data size
00001690                           724          
00001690  4EB9 00001AF0            725          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001696                           726          
00001696                           727          ; Put in tabs
00001696  4EB9 00001AAC            728          Jsr     OP_TAB
0000169C                           729          
0000169C                           730          ; Handoff
0000169C  6000 07DC                731          BRA     EA_SUB
000016A0                           732          
000016A0                           733  ;-----------------------  ADD  ------------------------------;
000016A0                           734  
000016A0                           735  OP_ADD
000016A0                           736      ; start string
000016A0                           737      
000016A0  1CFC 0041                738          Move.B  #'A', (A6)+
000016A4  1CFC 0044                739          Move.B  #'D', (A6)+
000016A8  1CFC 0044                740          Move.B  #'D', (A6)+
000016AC                           741  
000016AC                           742      ; Check for address version
000016AC                           743          
000016AC  4EB9 000021B4            744          Jsr     GET6AND7
000016B2  B03C 0003                745          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016B6                           746          
000016B6  6700 0012                747          Beq     OP_ADD_ADDR
000016BA                           748          
000016BA                           749          ; Don't need to worry about ADDA in V1
000016BA                           750          ; Check data size
000016BA  4EB9 00001AD0            751          Jsr     OP_CHECK_DATA_SIZE
000016C0                           752          
000016C0                           753          ; Put in tabs
000016C0  4EB9 00001AAC            754          Jsr     OP_TAB
000016C6                           755          
000016C6  6000 06BA                756          BRA     EA_ADD
000016CA                           757          
000016CA                           758  OP_ADD_ADDR
000016CA                           759          
000016CA  1CFC 0041                760          Move.B  #'A',(A6)+ ; add to the string
000016CE                           761          
000016CE                           762          ; Find data size
000016CE                           763          
000016CE  4EB9 00001AF0            764          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016D4                           765          
000016D4                           766          ; Put in tabs
000016D4  4EB9 00001AAC            767          Jsr     OP_TAB
000016DA                           768          
000016DA                           769          ; Handoff
000016DA  6000 06DA                770          BRA     EA_ADDA
000016DE                           771  
000016DE                           772  ;------------------------  BTST -----------------------------;
000016DE                           773  
000016DE                           774  OP_BTST
000016DE                           775      ; start string
000016DE                           776      
000016DE  1CFC 0042                777          Move.B  #'B', (A6)+
000016E2  1CFC 0054                778          Move.B  #'T', (A6)+
000016E6  1CFC 0053                779          Move.B  #'S', (A6)+
000016EA  1CFC 0054                780          Move.B  #'T', (A6)+
000016EE                           781          
000016EE                           782      ; Btst has data sizes, but they are implicit based on mode
000016EE                           783          
000016EE                           784      ; Put in tabs
000016EE  4EB9 00001AAC            785          Jsr     OP_TAB
000016F4                           786          
000016F4                           787      ; Hand the function off to John
000016F4  6000 088A                788          BRA     EA_BTST
000016F8                           789  
000016F8                           790  
000016F8                           791  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
000016F8                           792  
000016F8                           793  ;------------------------  ORI  -----------------------------;
000016F8                           794      
000016F8                           795  OP_ORI
000016F8                           796      ; start string
000016F8                           797      
000016F8  1CFC 004F                798          Move.B  #'O', (A6)+
000016FC  1CFC 0052                799          Move.B  #'R', (A6)+
00001700  1CFC 0049                800          Move.B  #'I', (A6)+
00001704                           801          
00001704                           802      ; Check data type        
00001704  4EB9 00001AD0            803          Jsr     OP_CHECK_DATA_SIZE
0000170A                           804          
0000170A                           805      ; Put in tabs
0000170A  4EB9 00001AAC            806          Jsr     OP_TAB
00001710                           807          
00001710                           808      ; Hand the function off to John
00001710  6000 080A                809          BRA     EA_IMMEDIATE
00001714                           810  
00001714                           811  ;-----------------------  SUBI  -----------------------------;
00001714                           812  
00001714                           813  OP_SUBI
00001714                           814      ; start string
00001714                           815      
00001714  1CFC 0053                816          Move.B  #'S', (A6)+
00001718  1CFC 0055                817          Move.B  #'U', (A6)+
0000171C  1CFC 0042                818          Move.B  #'B', (A6)+
00001720  1CFC 0049                819          Move.B  #'I', (A6)+
00001724                           820          
00001724                           821      ; Check data type        
00001724  4EB9 00001AD0            822          Jsr     OP_CHECK_DATA_SIZE
0000172A                           823          
0000172A                           824      ; Put in tabs
0000172A  4EB9 00001AAC            825          Jsr     OP_TAB
00001730                           826          
00001730                           827      ; Hand the function off to John
00001730  6000 07EA                828          BRA     EA_IMMEDIATE  
00001734                           829          
00001734                           830  ;-----------------------  EORI  -----------------------------;        
00001734                           831          
00001734                           832  OP_EORI
00001734                           833      ; start string
00001734                           834      
00001734  1CFC 0045                835          Move.B  #'E', (A6)+
00001738  1CFC 004F                836          Move.B  #'O', (A6)+
0000173C  1CFC 0052                837          Move.B  #'R', (A6)+
00001740  1CFC 0049                838          Move.B  #'I', (A6)+
00001744                           839          
00001744                           840      ; Check data type        
00001744  4EB9 00001AD0            841          Jsr     OP_CHECK_DATA_SIZE
0000174A                           842          
0000174A                           843      ; Put in tabs
0000174A  4EB9 00001AAC            844          Jsr     OP_TAB
00001750                           845          
00001750                           846      ; Hand the function off to John
00001750  6000 07CA                847          BRA     EA_IMMEDIATE  
00001754                           848          
00001754                           849  ;-----------------------  CMPI  -----------------------------;        
00001754                           850          
00001754                           851  OP_CMPI
00001754                           852      ; start string
00001754                           853      
00001754  1CFC 0043                854          Move.B  #'C', (A6)+
00001758  1CFC 004D                855          Move.B  #'M', (A6)+
0000175C  1CFC 0050                856          Move.B  #'P', (A6)+
00001760  1CFC 0049                857          Move.B  #'I', (A6)+
00001764                           858          
00001764                           859      ; Check data type        
00001764  4EB9 00001AD0            860          Jsr     OP_CHECK_DATA_SIZE
0000176A                           861          
0000176A                           862      ; Put in tabs
0000176A  4EB9 00001AAC            863          Jsr     OP_TAB
00001770                           864          
00001770                           865      ; Hand the function off to John
00001770  6000 07AA                866          BRA     EA_IMMEDIATE  
00001774                           867          
00001774                           868  ;-----------------------  LEA  ------------------------------;
00001774                           869  
00001774                           870  OP_LEA
00001774                           871      ; start string
00001774                           872      
00001774  1CFC 004C                873          Move.B  #'L', (A6)+
00001778  1CFC 0045                874          Move.B  #'E', (A6)+
0000177C  1CFC 0041                875          Move.B  #'A', (A6)+
00001780                           876          
00001780                           877      ; No data size for LEA
00001780                           878          
00001780                           879      ; Put in tabs
00001780  4EB9 00001AAC            880          Jsr     OP_TAB
00001786                           881          
00001786                           882      ; Hand the function off to John
00001786  6000 06FA                883          BRA     EA_LEA  
0000178A                           884  
0000178A                           885  ;-----------------------  NEG  ------------------------------;
0000178A                           886  
0000178A                           887  OP_NEG
0000178A                           888      ; start string
0000178A                           889      
0000178A  1CFC 004E                890          Move.B  #'N', (A6)+
0000178E  1CFC 0045                891          Move.B  #'E', (A6)+
00001792  1CFC 0047                892          Move.B  #'G', (A6)+
00001796                           893          
00001796                           894      ; Data size
00001796  4EB9 00001AD0            895          Jsr     OP_CHECK_DATA_SIZE
0000179C                           896          
0000179C                           897      ; Put in tabs
0000179C  4EB9 00001AAC            898          Jsr     OP_TAB
000017A2                           899          
000017A2                           900      ; Hand the function off to John
000017A2  6000 06EA                901          BRA     EA_NEG  
000017A6                           902  
000017A6                           903      
000017A6                           904  ;-----------------------  NOT  ------------------------------;    
000017A6                           905      
000017A6                           906  OP_NOT
000017A6                           907      ; start string
000017A6                           908      
000017A6  1CFC 004E                909          Move.B  #'N', (A6)+
000017AA  1CFC 004F                910          Move.B  #'O', (A6)+
000017AE  1CFC 0054                911          Move.B  #'T', (A6)+
000017B2                           912          
000017B2                           913      ; Data size
000017B2  4EB9 00001AD0            914          Jsr     OP_CHECK_DATA_SIZE
000017B8                           915          
000017B8                           916      ; Put in tabs
000017B8  4EB9 00001AAC            917          Jsr     OP_TAB
000017BE                           918          
000017BE                           919      ; Hand the function off to John
000017BE  6000 06D6                920          BRA     EA_NOT
000017C2                           921  
000017C2                           922  ;-------------------  MOVE MULITPLE  ------------------------;
000017C2                           923          
000017C2                           924  OP_MOVEM
000017C2                           925      ; start string
000017C2                           926      
000017C2  1CFC 004D                927          Move.B  #'M', (A6)+
000017C6  1CFC 004F                928          Move.B  #'O', (A6)+
000017CA  1CFC 0056                929          Move.B  #'V', (A6)+
000017CE  1CFC 0045                930          Move.B  #'E', (A6)+
000017D2  1CFC 004D                931          Move.B  #'M', (A6)+        
000017D6                           932  
000017D6                           933      ; Data size has to be checked manually
000017D6  4EB9 000017E6            934          Jsr     OP_MOVEM_DATA
000017DC                           935          
000017DC                           936      ; Put in tabs
000017DC  4EB9 00001AAC            937          Jsr     OP_TAB
000017E2                           938          
000017E2                           939      ; Hand the function off to John
000017E2  6000 03E4                940          BRA     EA_MOVEM
000017E6                           941          
000017E6                           942  OP_MOVEM_DATA
000017E6                           943      ; get the size bit
000017E6  4EB9 000021B4            944          Jsr     GET6AND7
000017EC                           945          
000017EC  B03C 0002                946          Cmp.B   #%10,D0
000017F0  6700 031A                947          Beq     OP_SET_DATA_WORD
000017F4                           948          
000017F4  6000 0320                949          Bra     OP_SET_DATA_LONG   
000017F8                           950  
000017F8                           951  OP_RTS
000017F8                           952      ; start string
000017F8                           953      
000017F8  1CFC 0052                954          Move.B  #'R', (A6)+
000017FC  1CFC 0054                955          Move.B  #'T', (A6)+
00001800  1CFC 0053                956          Move.B  #'S', (A6)+
00001804                           957  
00001804                           958      ; Put in tabs
00001804  4EB9 00001AAC            959          Jsr     OP_TAB
0000180A                           960  
0000180A                           961      ; Handoff to Blong
0000180A                           962      
0000180A  4E75                     963          Rts
0000180C                           964          
0000180C                           965  ;-----------------------  JSR  ------------------------------;        
0000180C                           966          
0000180C                           967  OP_JSR
0000180C                           968      ; start string
0000180C                           969      
0000180C  1CFC 004A                970          Move.B  #'J', (A6)+
00001810  1CFC 0053                971          Move.B  #'S', (A6)+
00001814  1CFC 0052                972          Move.B  #'R', (A6)+
00001818                           973          
00001818                           974      ; No data size
00001818                           975          
00001818                           976      ; Put in tabs
00001818  4EB9 00001AAC            977          Jsr     OP_TAB
0000181E                           978          
0000181E                           979      ; Hand the function off to John
0000181E  6000 067A                980          BRA     EA_JSR
00001822                           981  
00001822                           982  ;------------------  BRANCH CONDITIONALS  ------------------------;
00001822                           983  
00001822                           984  OP_BRANCH
00001822                           985      ; start string
00001822                           986      
00001822  1CFC 0042                987          Move.B  #'B', (A6)+
00001826  1CFC 0052                988          Move.B  #'R', (A6)+
0000182A  1CFC 0041                989          Move.B  #'A', (A6)+
0000182E                           990  
0000182E                           991      ; Put in tabs
0000182E  4EB9 00001AAC            992          Jsr     OP_TAB
00001834                           993  
00001834                           994      ; Handoff to John
00001834                           995      
00001834  6000 0796                996          BRA     EA_BRANCH
00001838                           997      
00001838                           998  OP_BRA_HIGH
00001838                           999      ; start string
00001838                          1000      
00001838  1CFC 0042               1001          Move.B  #'B', (A6)+
0000183C  1CFC 0048               1002          Move.B  #'H', (A6)+
00001840  1CFC 0049               1003          Move.B  #'I', (A6)+
00001844                          1004  
00001844                          1005      ; Put in tabs
00001844  4EB9 00001AAC           1006          Jsr     OP_TAB
0000184A                          1007  
0000184A                          1008      ; Handoff to John
0000184A                          1009      
0000184A  6000 0780               1010          BRA     EA_BRANCH
0000184E                          1011      
0000184E                          1012  OP_BRA_LOW
0000184E                          1013      ; start string
0000184E                          1014      
0000184E  1CFC 0042               1015          Move.B  #'B', (A6)+
00001852  1CFC 004C               1016          Move.B  #'L', (A6)+
00001856  1CFC 0053               1017          Move.B  #'S', (A6)+
0000185A                          1018  
0000185A                          1019      ; Put in tabs
0000185A  4EB9 00001AAC           1020          Jsr     OP_TAB
00001860                          1021  
00001860                          1022      ; Handoff to John
00001860                          1023      
00001860  6000 076A               1024          BRA     EA_BRANCH
00001864                          1025      
00001864                          1026  OP_BRA_CC
00001864                          1027      ; start string
00001864                          1028      
00001864  1CFC 0042               1029          Move.B  #'B', (A6)+
00001868  1CFC 0043               1030          Move.B  #'C', (A6)+
0000186C  1CFC 0043               1031          Move.B  #'C', (A6)+
00001870                          1032  
00001870                          1033      ; Put in tabs
00001870  4EB9 00001AAC           1034          Jsr     OP_TAB
00001876                          1035  
00001876                          1036      ; Handoff to John
00001876                          1037      
00001876  6000 0754               1038          BRA     EA_BRANCH
0000187A                          1039  
0000187A                          1040  OP_BRA_CS
0000187A                          1041      ; start string
0000187A                          1042      
0000187A  1CFC 0042               1043          Move.B  #'B', (A6)+
0000187E  1CFC 0043               1044          Move.B  #'C', (A6)+
00001882  1CFC 0053               1045          Move.B  #'S', (A6)+
00001886                          1046  
00001886                          1047      ; Put in tabs
00001886  4EB9 00001AAC           1048          Jsr     OP_TAB
0000188C                          1049  
0000188C                          1050      ; Handoff to John
0000188C                          1051      
0000188C  6000 073E               1052          BRA     EA_BRANCH
00001890                          1053  
00001890                          1054  OP_BRA_NE
00001890                          1055      ; start string
00001890                          1056      
00001890  1CFC 0042               1057          Move.B  #'B', (A6)+
00001894  1CFC 004E               1058          Move.B  #'N', (A6)+
00001898  1CFC 0045               1059          Move.B  #'E', (A6)+
0000189C                          1060  
0000189C                          1061      ; Put in tabs
0000189C  4EB9 00001AAC           1062          Jsr     OP_TAB
000018A2                          1063  
000018A2                          1064      ; Handoff to John
000018A2                          1065      
000018A2  6000 0728               1066          BRA     EA_BRANCH
000018A6                          1067  
000018A6                          1068  OP_BRA_EQ
000018A6                          1069      ; start string
000018A6                          1070      
000018A6  1CFC 0042               1071          Move.B  #'B', (A6)+
000018AA  1CFC 0045               1072          Move.B  #'E', (A6)+
000018AE  1CFC 0051               1073          Move.B  #'Q', (A6)+
000018B2                          1074  
000018B2                          1075      ; Put in tabs
000018B2  4EB9 00001AAC           1076          Jsr     OP_TAB
000018B8                          1077  
000018B8                          1078      ; Handoff to John
000018B8                          1079      
000018B8  6000 0712               1080          BRA     EA_BRANCH
000018BC                          1081  
000018BC                          1082  OP_BRA_VC
000018BC                          1083      ; start string
000018BC                          1084      
000018BC  1CFC 0042               1085          Move.B  #'B', (A6)+
000018C0  1CFC 0056               1086          Move.B  #'V', (A6)+
000018C4  1CFC 0043               1087          Move.B  #'C', (A6)+
000018C8                          1088  
000018C8                          1089      ; Put in tabs
000018C8  4EB9 00001AAC           1090          Jsr     OP_TAB
000018CE                          1091  
000018CE                          1092      ; Handoff to John
000018CE                          1093      
000018CE  6000 06FC               1094          BRA     EA_BRANCH
000018D2                          1095  
000018D2                          1096  OP_BRA_VS
000018D2                          1097      ; start string
000018D2                          1098      
000018D2  1CFC 0042               1099          Move.B  #'B', (A6)+
000018D6  1CFC 0056               1100          Move.B  #'V', (A6)+
000018DA  1CFC 0053               1101          Move.B  #'S', (A6)+
000018DE                          1102  
000018DE                          1103      ; Put in tabs
000018DE  4EB9 00001AAC           1104          Jsr     OP_TAB
000018E4                          1105  
000018E4                          1106      ; Handoff to John
000018E4                          1107      
000018E4  6000 06E6               1108          BRA     EA_BRANCH
000018E8                          1109  
000018E8                          1110  OP_BRA_PL
000018E8                          1111      ; start string
000018E8                          1112      
000018E8  1CFC 0042               1113          Move.B  #'B', (A6)+
000018EC  1CFC 0050               1114          Move.B  #'P', (A6)+
000018F0  1CFC 004C               1115          Move.B  #'L', (A6)+
000018F4                          1116  
000018F4                          1117      ; Put in tabs
000018F4  4EB9 00001AAC           1118          Jsr     OP_TAB
000018FA                          1119  
000018FA                          1120      ; Handoff to John
000018FA                          1121      
000018FA  6000 06D0               1122          BRA     EA_BRANCH
000018FE                          1123  
000018FE                          1124  OP_BRA_MI
000018FE                          1125      ; start string
000018FE                          1126      
000018FE  1CFC 0042               1127          Move.B  #'B', (A6)+
00001902  1CFC 004D               1128          Move.B  #'M', (A6)+
00001906  1CFC 0049               1129          Move.B  #'I', (A6)+
0000190A                          1130  
0000190A                          1131      ; Put in tabs
0000190A  4EB9 00001AAC           1132          Jsr     OP_TAB
00001910                          1133  
00001910                          1134      ; Handoff to John
00001910                          1135      
00001910  6000 06BA               1136          BRA     EA_BRANCH
00001914                          1137  
00001914                          1138  OP_BRA_GE
00001914                          1139      ; start string
00001914                          1140      
00001914  1CFC 0042               1141          Move.B  #'B', (A6)+
00001918  1CFC 0047               1142          Move.B  #'G', (A6)+
0000191C  1CFC 0045               1143          Move.B  #'E', (A6)+
00001920                          1144  
00001920                          1145      ; Put in tabs
00001920  4EB9 00001AAC           1146          Jsr     OP_TAB
00001926                          1147  
00001926                          1148      ; Handoff to John
00001926                          1149      
00001926  6000 06A4               1150          BRA     EA_BRANCH
0000192A                          1151  
0000192A                          1152  OP_BRA_LT
0000192A                          1153      ; start string
0000192A                          1154      
0000192A  1CFC 0042               1155          Move.B  #'B', (A6)+
0000192E  1CFC 004C               1156          Move.B  #'L', (A6)+
00001932  1CFC 0054               1157          Move.B  #'T', (A6)+
00001936                          1158  
00001936                          1159      ; Put in tabs
00001936  4EB9 00001AAC           1160          Jsr     OP_TAB
0000193C                          1161  
0000193C                          1162      ; Handoff to John
0000193C                          1163      
0000193C  6000 068E               1164          BRA     EA_BRANCH
00001940                          1165  
00001940                          1166  OP_BRA_GT
00001940                          1167      ; start string
00001940                          1168      
00001940  1CFC 0042               1169          Move.B  #'B', (A6)+
00001944  1CFC 0047               1170          Move.B  #'G', (A6)+
00001948  1CFC 0054               1171          Move.B  #'T', (A6)+
0000194C                          1172  
0000194C                          1173      ; Put in tabs
0000194C  4EB9 00001AAC           1174          Jsr     OP_TAB
00001952                          1175  
00001952                          1176      ; Handoff to John
00001952                          1177      
00001952  6000 0678               1178          BRA     EA_BRANCH
00001956                          1179  
00001956                          1180  OP_BRA_LE
00001956                          1181      ; start string
00001956                          1182      
00001956  1CFC 0042               1183          Move.B  #'B', (A6)+
0000195A  1CFC 004C               1184          Move.B  #'L', (A6)+
0000195E  1CFC 0045               1185          Move.B  #'E', (A6)+
00001962                          1186  
00001962                          1187      ; Put in tabs
00001962  4EB9 00001AAC           1188          Jsr     OP_TAB
00001968                          1189  
00001968                          1190      ; Handoff to John
00001968                          1191      
00001968  6000 0662               1192          BRA     EA_BRANCH
0000196C                          1193  
0000196C                          1194  ;------------------  Multiply Singed ----------------------;    
0000196C                          1195  
0000196C                          1196  OP_MULS
0000196C                          1197      ; MULS only has one format, and that data size of word, so I don't need
0000196C                          1198      ; a very intelligent system
0000196C                          1199      
0000196C  1CFC 004D               1200          Move.B  #'M', (A6)+
00001970  1CFC 0055               1201          Move.B  #'U', (A6)+
00001974  1CFC 004C               1202          Move.B  #'L', (A6)+
00001978  1CFC 0053               1203          Move.B  #'S', (A6)+
0000197C  1CFC 002E               1204          Move.B  #'.', (A6)+
00001980  1CFC 0057               1205          Move.B  #'W', (A6)+
00001984                          1206  
00001984                          1207      ; Put in tabs
00001984  4EB9 00001AAC           1208          Jsr     OP_TAB       
0000198A                          1209      
0000198A                          1210      ; Give to john
0000198A                          1211      
0000198A  6000 05C8               1212          BRA     EA_MULS
0000198E                          1213  
0000198E                          1214      
0000198E                          1215  ;-----------------------  AND  ------------------------------;    
0000198E                          1216      
0000198E                          1217  OP_AND
0000198E                          1218      ; start string
0000198E                          1219      
0000198E  1CFC 0041               1220          Move.B  #'A', (A6)+
00001992  1CFC 004E               1221          Move.B  #'N', (A6)+
00001996  1CFC 0044               1222          Move.B  #'D', (A6)+
0000199A                          1223  
0000199A                          1224      ; No Address Version
0000199A                          1225          
0000199A                          1226      ; Check data size
0000199A  4EB9 00001AD0           1227          Jsr     OP_CHECK_DATA_SIZE
000019A0                          1228          
000019A0                          1229      ; Put in tabs
000019A0  4EB9 00001AAC           1230          Jsr     OP_TAB
000019A6                          1231          
000019A6  6000 04DE               1232      BRA     EA_AND
000019AA                          1233  
000019AA                          1234      
000019AA                          1235  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
000019AA                          1236          
000019AA                          1237  OP_AS_REG
000019AA                          1238      ; start string
000019AA                          1239      
000019AA  1CFC 0041               1240          Move.B  #'A', (A6)+
000019AE  1CFC 0053               1241          Move.B  #'S', (A6)+
000019B2                          1242          
000019B2                          1243      ; Determine Left or right shift
000019B2                          1244      
000019B2  4EB9 00001B20           1245          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019B8                          1246          
000019B8                          1247      ; Determine data size
000019B8                          1248      
000019B8  4EB9 00001AD0           1249          Jsr     OP_CHECK_DATA_SIZE
000019BE                          1250         
000019BE                          1251      ; Tab out function
000019BE                          1252      
000019BE  4EB9 00001AAC           1253          Jsr     OP_TAB
000019C4                          1254         
000019C4                          1255      ; Handoff function
000019C4  6000 04D8               1256          BRA     EA_BIT_SHIFT
000019C8                          1257          
000019C8                          1258  OP_AS_MEM
000019C8                          1259      
000019C8                          1260      ; start string
000019C8                          1261      
000019C8  1CFC 0041               1262          Move.B  #'A', (A6)+
000019CC  1CFC 0053               1263          Move.B  #'S', (A6)+
000019D0                          1264          
000019D0                          1265      ; Determine Left or right shift
000019D0                          1266      
000019D0  4EB9 00001B20           1267          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019D6                          1268         
000019D6                          1269      ; Tab out function
000019D6                          1270      
000019D6  4EB9 00001AAC           1271          Jsr     OP_TAB
000019DC                          1272         
000019DC                          1273      ; Handoff function
000019DC  6000 04C0               1274          BRA     EA_BIT_SHIFT
000019E0                          1275  
000019E0                          1276  
000019E0                          1277  ;-------------------  LOGICAL SHIFT  ------------------------;
000019E0                          1278  
000019E0                          1279  OP_LS_REG
000019E0                          1280      ; start string
000019E0                          1281      
000019E0  1CFC 004C               1282          Move.B  #'L', (A6)+
000019E4  1CFC 0053               1283          Move.B  #'S', (A6)+
000019E8                          1284          
000019E8                          1285      ; Determine Left or right shift
000019E8                          1286      
000019E8  4EB9 00001B20           1287          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019EE                          1288          
000019EE                          1289      ; Determine data size
000019EE                          1290      
000019EE  4EB9 00001AD0           1291          Jsr     OP_CHECK_DATA_SIZE
000019F4                          1292         
000019F4                          1293      ; Tab out function
000019F4                          1294      
000019F4  4EB9 00001AAC           1295          Jsr     OP_TAB
000019FA                          1296         
000019FA                          1297      ; Handoff function
000019FA  6000 04A2               1298          BRA     EA_BIT_SHIFT
000019FE                          1299  
000019FE                          1300      
000019FE                          1301  OP_LS_MEM    
000019FE                          1302  
000019FE                          1303      ; start string
000019FE                          1304      
000019FE  1CFC 004C               1305          Move.B  #'L', (A6)+
00001A02  1CFC 0053               1306          Move.B  #'S', (A6)+
00001A06                          1307          
00001A06                          1308      ; Determine Left or right shift
00001A06                          1309      
00001A06  4EB9 00001B20           1310          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A0C                          1311         
00001A0C                          1312      ; Tab out function
00001A0C                          1313      
00001A0C  4EB9 00001AAC           1314          Jsr     OP_TAB
00001A12                          1315         
00001A12                          1316      ; Handoff function
00001A12  6000 048A               1317          BRA     EA_BIT_SHIFT
00001A16                          1318  
00001A16                          1319  
00001A16                          1320  ;----------------------  ROTATE  ----------------------------;
00001A16                          1321  
00001A16                          1322  OP_RO_REG
00001A16                          1323      ; start string
00001A16                          1324      
00001A16  1CFC 0052               1325          Move.B  #'R', (A6)+
00001A1A  1CFC 004F               1326          Move.B  #'O', (A6)+
00001A1E                          1327          
00001A1E                          1328      ; Determine Left or right shift
00001A1E                          1329      
00001A1E  4EB9 00001B20           1330          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A24                          1331          
00001A24                          1332      ; Determine data size
00001A24                          1333      
00001A24  4EB9 00001AD0           1334          Jsr     OP_CHECK_DATA_SIZE
00001A2A                          1335         
00001A2A                          1336      ; Tab out function
00001A2A                          1337      
00001A2A  4EB9 00001AAC           1338          Jsr     OP_TAB
00001A30                          1339         
00001A30                          1340      ; Handoff function
00001A30  6000 046C               1341          BRA     EA_BIT_SHIFT
00001A34                          1342  
00001A34                          1343      
00001A34                          1344  OP_RO_MEM
00001A34                          1345  
00001A34                          1346      ; start string
00001A34                          1347      
00001A34  1CFC 0052               1348          Move.B  #'R', (A6)+
00001A38  1CFC 004F               1349          Move.B  #'O', (A6)+
00001A3C                          1350          
00001A3C                          1351      ; Determine Left or right shift
00001A3C                          1352      
00001A3C  4EB9 00001B20           1353          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A42                          1354         
00001A42                          1355      ; Tab out function
00001A42                          1356      
00001A42  4EB9 00001AAC           1357          Jsr     OP_TAB
00001A48                          1358         
00001A48                          1359      ; Handoff function
00001A48  6000 0454               1360          BRA     EA_BIT_SHIFT
00001A4C                          1361  
00001A4C                          1362  
00001A4C                          1363  ;-----------------------  CMP  ------------------------------;
00001A4C                          1364  
00001A4C                          1365  OP_Cmp
00001A4C                          1366      ; start string
00001A4C                          1367      
00001A4C  1CFC 0043               1368          Move.B  #'C', (A6)+
00001A50  1CFC 004D               1369          Move.B  #'M', (A6)+
00001A54  1CFC 0050               1370          Move.B  #'P', (A6)+
00001A58                          1371  
00001A58                          1372      ; Check for address version
00001A58                          1373          
00001A58  4EB9 000021B4           1374          Jsr     GET6AND7
00001A5E  B03C 0003               1375          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001A62                          1376          
00001A62  6700 0012               1377          Beq     OP_CMP_ADDR
00001A66                          1378          
00001A66                          1379      ; Check which of the two versions is it?
00001A66                          1380  
00001A66  4EB9 00001AD0           1381          Jsr     OP_CHECK_DATA_SIZE
00001A6C                          1382          
00001A6C                          1383      ; Put in tabs
00001A6C  4EB9 00001AAC           1384          Jsr     OP_TAB
00001A72                          1385  
00001A72                          1386      ; Handoff
00001A72  6000 040A               1387          BRA     EA_CMP
00001A76                          1388          
00001A76                          1389  OP_CMP_ADDR
00001A76                          1390          
00001A76  1CFC 0041               1391          Move.B  #'A',(A6)+ ; add to the string
00001A7A                          1392      
00001A7A                          1393      ; Find data size
00001A7A                          1394          
00001A7A  4EB9 00001AF0           1395          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001A80                          1396          
00001A80                          1397      ; Put in tabs
00001A80  4EB9 00001AAC           1398          Jsr     OP_TAB
00001A86                          1399  
00001A86                          1400      ; Handoff
00001A86  6000 03F6               1401          BRA     EA_CMP
00001A8A                          1402      
00001A8A                          1403  ;-----------------------  EOR  ------------------------------;
00001A8A                          1404  
00001A8A                          1405  OP_EOR
00001A8A                          1406      ; start string
00001A8A                          1407      
00001A8A  1CFC 0045               1408          Move.B  #'E', (A6)+
00001A8E  1CFC 004F               1409          Move.B  #'O', (A6)+
00001A92  1CFC 0052               1410          Move.B  #'R', (A6)+
00001A96                          1411  
00001A96                          1412      ; No Address Version
00001A96                          1413          
00001A96                          1414      ; Check data size
00001A96  4EB9 00001AD0           1415          Jsr     OP_CHECK_DATA_SIZE
00001A9C                          1416          
00001A9C                          1417      ; Put in tabs
00001A9C  4EB9 00001AAC           1418          Jsr     OP_TAB
00001AA2                          1419          
00001AA2  6000 03E6               1420      BRA     EA_EOR
00001AA6                          1421  
00001AA6                          1422  ;---------------- Misc Op-Code Sub Routines ----------------;
00001AA6                          1423  ; Set Bad Buffer
00001AA6                          1424  ; Sub Routine that sets the Bad buffer bit and returns
00001AA6                          1425  ;
00001AA6                          1426  ; REGISTERS USED: D7
00001AA6                          1427  
00001AA6                          1428  OP_SET_BAD_BUFFER
00001AA6  1E3C 0001               1429      Move.B  #%1, D7
00001AAA  4E75                    1430      Rts
00001AAC                          1431  
00001AAC                          1432  ;-------------------------- Tab ----------------------------;
00001AAC                          1433  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001AAC                          1434  ; taking into account the current size of the string
00001AAC                          1435  
00001AAC                          1436  ; REGISTERS USED: A6, A5(const), D0
00001AAC                          1437  
00001AAC                          1438  OP_TAB
00001AAC  220D                    1439      Move.L      A5,D1   ; Move the start of string to a Dn
00001AAE  928E                    1440      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001AB0  0681 00000014           1441      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001AB6                          1442      
00001AB6                          1443      ; Loop till you have enough spaces
00001AB6                          1444  LOOP_TAB
00001AB6  1CFC 0020               1445      Move.B      #' ',(A6)+  ; Add a space to the string
00001ABA  5301                    1446      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001ABC  66F8                    1447      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001ABE                          1448      
00001ABE  4E75                    1449      Rts
00001AC0                          1450  
00001AC0                          1451  ;--------------------- Address Version ---------------------;
00001AC0                          1452  ; This Sub Routine Checks if the Src address is an An and
00001AC0                          1453  ; Adds an A to the sring if it is, to represent that it is
00001AC0                          1454  ; Is the Address version of the Op-code. This function assumes
00001AC0                          1455  ; That D0 will have the mode for the Destination in it.
00001AC0                          1456  
00001AC0                          1457  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001AC0                          1458  ;                 A6 (Add string input)
00001AC0                          1459  
00001AC0                          1460  OP_CHECK_ADDRESS_VERSION
00001AC0                          1461  
00001AC0  B03C 0001               1462      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001AC4  6700 0004               1463      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001AC8                          1464      
00001AC8  4E75                    1465      Rts     ; Otherwise go back without changing anything
00001ACA                          1466  
00001ACA                          1467  OP_ADD_ADDRESS_VERSION
00001ACA  1CFC 0041               1468      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001ACE                          1469      
00001ACE  4E75                    1470      Rts     ; Finish up and go back
00001AD0                          1471      
00001AD0                          1472  ;--------------------- Data Size Check ---------------------;
00001AD0                          1473  ; A set of sub routines to check the size of the data and add it
00001AD0                          1474  ; To the string.
00001AD0                          1475  
00001AD0                          1476  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001AD0                          1477  ;                 A6(adds letters)    
00001AD0                          1478  OP_CHECK_DATA_SIZE
00001AD0  4EB9 000021B4           1479      Jsr     GET6AND7
00001AD6                          1480      
00001AD6  B03C 0000               1481      Cmp.B    #%00, D0    ; Byte Size
00001ADA  6700 0026               1482      Beq     OP_SET_DATA_BYTE
00001ADE                          1483      
00001ADE  B03C 0001               1484      Cmp.B    #%01, D0    ; Word Size
00001AE2  6700 0028               1485      Beq     OP_SET_DATA_WORD
00001AE6                          1486      
00001AE6  B03C 0002               1487      Cmp.B    #%10, D0    ; Long Size
00001AEA  6700 002A               1488      Beq     OP_SET_DATA_LONG
00001AEE                          1489      
00001AEE                          1490      ; If it was not one of those three types, it is not a legal operation
00001AEE  60B6                    1491      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001AF0                          1492  
00001AF0                          1493  OP_CHECK_DATA_SIZE_ADDR
00001AF0  4EB9 00002190           1494      Jsr     GETBIT8
00001AF6                          1495      
00001AF6  B03C 0000               1496      Cmp.B   #%0, D0     ; Word Size
00001AFA  6700 0010               1497      Beq     OP_SET_DATA_WORD
00001AFE                          1498                          ; Otherwise its Long Size
00001AFE  6000 0016               1499      Bra     OP_SET_DATA_LONG
00001B02                          1500  
00001B02                          1501  OP_SET_DATA_BYTE
00001B02                          1502  
00001B02  1CFC 002E               1503      Move.B  #'.',(A6)+  ; Add Letters
00001B06  1CFC 0042               1504      Move.B  #'B',(A6)+
00001B0A                          1505      
00001B0A  4E75                    1506      Rts
00001B0C                          1507  
00001B0C                          1508  OP_SET_DATA_WORD
00001B0C                          1509  
00001B0C  1CFC 002E               1510      Move.B  #'.',(A6)+  ; Add Letters
00001B10  1CFC 0057               1511      Move.B  #'W',(A6)+
00001B14                          1512  
00001B14  4E75                    1513      Rts
00001B16                          1514  
00001B16                          1515  OP_SET_DATA_LONG
00001B16                          1516  
00001B16  1CFC 002E               1517      Move.B  #'.',(A6)+  ; Add Letters
00001B1A  1CFC 004C               1518      Move.B  #'L',(A6)+
00001B1E                          1519  
00001B1E  4E75                    1520      Rts
00001B20                          1521  
00001B20                          1522  ;------------------- Bit Shift Direction -------------------;
00001B20                          1523  ; This checks bit 8 to see what direction the shift is going
00001B20                          1524  
00001B20                          1525  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B20                          1526  
00001B20                          1527  OP_SHIFT_DIRECTION
00001B20  4EB9 00002190           1528      Jsr     GETBIT8 ; Get the shift direction bit
00001B26                          1529      
00001B26  B03C 0000               1530      Cmp.B   #%0,D0  ; 0 is Right
00001B2A  6700 0006               1531      Beq     OP_SHIFT_RIGHT
00001B2E                          1532  
00001B2E  6000 0008               1533      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001B32                          1534  
00001B32                          1535  OP_SHIFT_RIGHT
00001B32                          1536      ; Add the character and return
00001B32  1CFC 0052               1537      Move.B  #'R',(A6)+
00001B36                          1538  
00001B36  4E75                    1539      Rts    
00001B38                          1540  
00001B38                          1541  OP_SHIFT_LEFT
00001B38                          1542      ; Add the character and return
00001B38  1CFC 004C               1543      Move.B  #'L',(A6)+
00001B3C                          1544  
00001B3C  4E75                    1545      Rts
00001B3E                          1546      
00001B3E                          1547  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001B3E                          1548  ;-------------------- Effective Address Sub Routines --------------------;
00001B3E                          1549  ; These subroutines look for the correct effective address
00001B3E                          1550  ; in each OP code.
00001B3E                          1551  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001B3E                          1552  
00001B3E                          1553  ;=============================================;
00001B3E                          1554  ;--------------- EA Move/MoveA ---------------;
00001B3E                          1555  ;=============================================;
00001B3E                          1556  EA_MOVE
00001B3E  4EB9 00001B50           1557          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001B44  1CFC 002C               1558          Move.B  #',', (A6)+             ; Add a comma
00001B48  4EB9 00001B60           1559          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001B4E                          1560          
00001B4E  4E75                    1561          RTS
00001B50                          1562                  
00001B50                          1563  EA_MOVE_SOURCE  ; Find out Move's source
00001B50  4EB9 000020D2           1564          Jsr     EA_0TO5                 ; Get the EA
00001B56                          1565          
00001B56  B03C 0004               1566          Cmp.B   #Imm_Reg, D0            ; #<data>
00001B5A  6700 004C               1567          Beq     EA_MOVE_SIZE
00001B5E                          1568          
00001B5E  4E75                    1569          Rts
00001B60                          1570          
00001B60                          1571  EA_MOVE_DEST    ; Find out Move's destination
00001B60  4EB9 0000215A           1572          Jsr     GET6TO8                 ; Get destination mode
00001B66  1A00                    1573          Move.B  D0, D5                  ; Move destination mode to D5
00001B68  4EB9 00002148           1574          Jsr     GET9TO11                ; Get destination register
00001B6E                          1575          
00001B6E                          1576          ; List of valid effective addresses
00001B6E  BA3C 0000               1577          Cmp.B   #Dn_Mode, D5            ; Dn
00001B72  6700 0482               1578          Beq     EA_DN
00001B76                          1579          
00001B76  BA3C 0001               1580          Cmp.B   #An_Mode, D5            ; An
00001B7A  6700 0486               1581          Beq     EA_AN
00001B7E                          1582          
00001B7E  BA3C 0002               1583          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001B82  6700 048A               1584          Beq     EA_AN_PNTR
00001B86                          1585          
00001B86  BA3C 0003               1586          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001B8A  6700 0496               1587          Beq     EA_AN_INC
00001B8E                          1588          
00001B8E  BA3C 0004               1589          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001B92  6700 04A6               1590          Beq     EA_AN_DEC
00001B96                          1591          
00001B96                          1592          ; Comparing registers at this point because modes are the same
00001B96  B03C 0000               1593          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001B9A  6700 04B6               1594          Beq     EA_WORD_ADDR
00001B9E                          1595          
00001B9E  B03C 0001               1596          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001BA2  6700 04F2               1597          Beq     EA_LONG_ADDR
00001BA6                          1598          
00001BA6  4E75                    1599          Rts
00001BA8                          1600          
00001BA8                          1601  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001BA8  4EB9 00002124           1602          Jsr     GET12TO13               ; Get Move size
00001BAE                          1603  
00001BAE  B03C 0001               1604          Cmp.B   #%01, D0                ; Byte
00001BB2  6700 04EE               1605          Beq     EA_IMM_BYTE
00001BB6                          1606  
00001BB6  B03C 0003               1607          Cmp.B   #%11, D0                ; Word
00001BBA  6700 04F6               1608          Beq     EA_IMM_WORD
00001BBE                          1609          
00001BBE  B03C 0002               1610          Cmp.B   #%10, D0                ; Long
00001BC2  6700 04FE               1611          Beq     EA_IMM_LONG
00001BC6                          1612          
00001BC6  4E75                    1613          Rts
00001BC8                          1614          
00001BC8                          1615  ;=================================================================;
00001BC8                          1616  ;---------------------------- EA MoveM ---------------------------;
00001BC8                          1617  ; D2 stores the counter for the number of consecutive ones in the
00001BC8                          1618  ; register list mask
00001BC8                          1619  ;
00001BC8                          1620  ; D3 stores a 1 if the register being added is the first register, 
00001BC8                          1621  ; or 0 if the register is not the first register being added
00001BC8                          1622  ;
00001BC8                          1623  ; D5 stores the register list mask
00001BC8                          1624  ;
00001BC8                          1625  ; D6 stores any expansion words
00001BC8                          1626  ;
00001BC8                          1627  ; D7 stores the loop counter
00001BC8                          1628  ;=================================================================;
00001BC8                          1629  EA_MOVEM    ; Determines the EA for MoveM
00001BC8  48E7 3F00               1630          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001BCC                          1631          
00001BCC  4282                    1632          Clr.L   D2                      ; Clear out the data registers
00001BCE  4283                    1633          Clr.L   D3
00001BD0  4285                    1634          Clr.L   D5
00001BD2  4286                    1635          Clr.L   D6
00001BD4  4287                    1636          Clr.L   D7
00001BD6                          1637          
00001BD6  5203                    1638          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001BD8  3A1B                    1639          Move.W  (A3)+, D5               ; Store the register list mask
00001BDA                          1640          
00001BDA  4EB9 000021F8           1641          Jsr     GETBIT10                ; Get the direction bit
00001BE0                          1642          
00001BE0  B03C 0000               1643          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001BE4  6700 0008               1644          Beq     EA_MOVEM_REG_TO_MEM
00001BE8                          1645          
00001BE8  4EF9 00001C04           1646          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001BEE                          1647          
00001BEE                          1648  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001BEE  4EB9 00001C20           1649          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001BF4  1CFC 002C               1650          Move.B  #',', (A6)+             ; Add a comma
00001BF8  4EB9 000020D2           1651          Jsr     EA_0TO5                 ; Get the EA
00001BFE                          1652          
00001BFE  4CDF 00FC               1653          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C02                          1654                  
00001C02  4E75                    1655          RTS
00001C04                          1656          
00001C04                          1657  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C04  3E05                    1658          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C06  4EB9 000020D2           1659          Jsr     EA_0TO5                 ; Get the EA
00001C0C  1CFC 002C               1660          Move.B  #',', (A6)+             ; Add a comma
00001C10  3A07                    1661          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C12  4287                    1662          Clr.L   D7                      ; Clear D7
00001C14  4EB9 00001C20           1663          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C1A                          1664          
00001C1A  4CDF 00FC               1665          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C1E                          1666                  
00001C1E  4E75                    1667          RTS
00001C20                          1668                  
00001C20                          1669  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C20  BE3C 0010               1670          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C24  6C00 0016               1671          Bge     EA_MOVEM_LIST_END
00001C28                          1672  
00001C28  4EB9 0000216C           1673          Jsr     GET3TO5                 ; Get the EA mode
00001C2E                          1674          
00001C2E  B03C 0004               1675          Cmp.B   #%100, D0               ; Predecrement mode
00001C32  6700 000A               1676          Beq     EA_MOVEM_PRE_DEC
00001C36                          1677          
00001C36  4EF9 00001C48           1678          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001C3C                          1679          
00001C3C                          1680  EA_MOVEM_LIST_END   ; Ends the list loop
00001C3C  4E75                    1681          Rts
00001C3E                          1682          
00001C3E                          1683  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001C3E  E35D                    1684          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001C40                          1685          
00001C40  6500 0010               1686          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C44                          1687          
00001C44  6400 002C               1688          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C48                          1689          
00001C48                          1690  EA_MOVEM_POST_INC   ; Post increment mode
00001C48  E25D                    1691          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001C4A                          1692          
00001C4A  6500 0006               1693          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C4E                          1694          
00001C4E  6400 0022               1695          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C52                          1696          
00001C52                          1697  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001C52  B63C 0001               1698          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001C56  6700 002A               1699          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001C5A                          1700          
00001C5A  B43C 0000               1701          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001C5E  6700 0032               1702          Beq     EA_MOVEM_ADD_SINGLE_REG
00001C62                          1703          
00001C62  5207                    1704          Add.B   #1, D7                  ; Increment the loop counter
00001C64  5202                    1705          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C66                          1706          
00001C66  BE3C 0010               1707          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001C6A  6700 0038               1708          Beq     EA_MOVEM_LAST_REG
00001C6E                          1709          
00001C6E  4EF8 1C20               1710          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C72                          1711          
00001C72                          1712  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001C72  B43C 0001               1713          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001C76  6E00 003A               1714          Bgt     EA_MOVEM_ADD_LAST_REG
00001C7A                          1715          
00001C7A  5207                    1716          Add.B   #1, D7                  ; Increment the loop counter
00001C7C                          1717          
00001C7C  4282                    1718          Clr.L   D2                      ; Clear the counter for consecutive ones
00001C7E                          1719          
00001C7E  4EF8 1C20               1720          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C82                          1721  
00001C82                          1722  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001C82  4EB9 00001CC6           1723          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001C88                          1724          
00001C88  4283                    1725          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001C8A                          1726          
00001C8A  5207                    1727          Add.B   #1, D7                  ; Increment the loop counter
00001C8C  5202                    1728          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C8E                          1729          
00001C8E  4EF8 1C20               1730          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C92                          1731          
00001C92                          1732  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001C92  1CFC 002F               1733          Move.B  #'/', (A6)+
00001C96                          1734          
00001C96  4EB9 00001CC6           1735          Jsr     EA_MOVEM_REG            ; Add a register
00001C9C                          1736          
00001C9C  5207                    1737          Add.B   #1, D7                  ; Increment the loop counter 
00001C9E  5202                    1738          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CA0                          1739          
00001CA0  4EF8 1C20               1740          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CA4                          1741          
00001CA4                          1742  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001CA4  B43C 0001               1743          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001CA8  6E00 0008               1744          Bgt     EA_MOVEM_ADD_LAST_REG
00001CAC                          1745          
00001CAC  5207                    1746          Add.B   #1, D7                  ; Increment the loop counter
00001CAE                          1747          
00001CAE  4EF8 1C20               1748          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CB2                          1749          
00001CB2                          1750  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001CB2  1CFC 002D               1751          Move.B  #'-', (A6)+
00001CB6                          1752          
00001CB6  5307                    1753          Sub.B   #1, D7                  ; Move back to the previous register
00001CB8                          1754          
00001CB8  4EB9 00001CC6           1755          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001CBE                          1756          
00001CBE  5407                    1757          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001CC0                          1758          
00001CC0  4282                    1759          Clr.L   D2                      ; Clear the consecutive ones counter
00001CC2                          1760          
00001CC2  4EF8 1C20               1761          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CC6                          1762          
00001CC6                          1763  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001CC6  4280                    1764          Clr.L   D0                      ; Clear D0
00001CC8  BE3C 0000               1765          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001CCC  6700 0328               1766          Beq     EA_DN
00001CD0                          1767          
00001CD0  103C 0001               1768          Move.B  #1, D0                  ; Move a 1 into D0
00001CD4  BE3C 0001               1769          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001CD8  6700 031C               1770          Beq     EA_DN
00001CDC                          1771          
00001CDC  103C 0002               1772          Move.B  #2, D0
00001CE0  BE3C 0002               1773          Cmp.B   #2, D7
00001CE4  6700 0310               1774          Beq     EA_DN
00001CE8                          1775  
00001CE8  103C 0003               1776          Move.B  #3, D0
00001CEC  BE3C 0003               1777          Cmp.B   #3, D7
00001CF0  6700 0304               1778          Beq     EA_DN
00001CF4                          1779  
00001CF4  103C 0004               1780          Move.B  #4, D0
00001CF8  BE3C 0004               1781          Cmp.B   #4, D7
00001CFC  6700 02F8               1782          Beq     EA_DN
00001D00                          1783  
00001D00  103C 0005               1784          Move.B  #5, D0
00001D04  BE3C 0005               1785          Cmp.B   #5, D7
00001D08  6700 02EC               1786          Beq     EA_DN
00001D0C                          1787  
00001D0C  103C 0006               1788          Move.B  #6, D0
00001D10  BE3C 0006               1789          Cmp.B   #6, D7
00001D14  6700 02E0               1790          Beq     EA_DN
00001D18                          1791          
00001D18  103C 0007               1792          Move.B  #7, D0
00001D1C  BE3C 0007               1793          Cmp.B   #7, D7
00001D20  6700 02D4               1794          Beq     EA_DN
00001D24                          1795          
00001D24  4280                    1796          Clr.L   D0
00001D26  BE3C 0008               1797          Cmp.B   #8, D7
00001D2A  6700 02D6               1798          Beq     EA_AN
00001D2E                          1799  
00001D2E  103C 0001               1800          Move.B  #1, D0
00001D32  BE3C 0009               1801          Cmp.B   #9, D7
00001D36  6700 02CA               1802          Beq     EA_AN
00001D3A                          1803  
00001D3A  103C 0002               1804          Move.B  #2, D0
00001D3E  BE3C 000A               1805          Cmp.B   #10, D7
00001D42  6700 02BE               1806          Beq     EA_AN
00001D46                          1807          
00001D46  103C 0003               1808          Move.B  #3, D0
00001D4A  BE3C 000B               1809          Cmp.B   #11, D7
00001D4E  6700 02B2               1810          Beq     EA_AN
00001D52                          1811          
00001D52  103C 0004               1812          Move.B  #4, D0
00001D56  BE3C 000C               1813          Cmp.B   #12, D7
00001D5A  6700 02A6               1814          Beq     EA_AN
00001D5E                          1815          
00001D5E  103C 0005               1816          Move.B  #5, D0
00001D62  BE3C 000D               1817          Cmp.B   #13, D7
00001D66  6700 029A               1818          Beq     EA_AN
00001D6A                          1819          
00001D6A  103C 0006               1820          Move.B  #6, D0
00001D6E  BE3C 000E               1821          Cmp.B   #14, D7
00001D72  6700 028E               1822          Beq     EA_AN
00001D76                          1823          
00001D76  103C 0007               1824          Move.B  #7, D0
00001D7A  BE3C 000F               1825          Cmp.B   #15, D7
00001D7E  6700 0282               1826          Beq     EA_AN
00001D82                          1827  
00001D82                          1828  ;===========================================;        
00001D82                          1829  ;--------------- EA Add/AddA ---------------;
00001D82                          1830  ;===========================================;       
00001D82                          1831  EA_ADD  ; Figures out the EA for Add        
00001D82  4EB9 0000215A           1832          Jsr     GET6TO8                 ; Isolate the Op mode
00001D88                          1833          
00001D88  B03C 0003               1834          Cmp.B   #%011, D0               ; Compare to AddA word
00001D8C  6700 0028               1835          Beq     EA_ADDA
00001D90                          1836          
00001D90  B03C 0007               1837          Cmp.B   #%111, D0               ; Compare to AddA long
00001D94  6700 0020               1838          Beq     EA_ADDA
00001D98                          1839  
00001D98  B03C 0000               1840          Cmp.B   #%000, D0               ; Compare to Add source byte
00001D9C  6700 0030               1841          Beq     EA_ADD_OPMODE_SOURCE
00001DA0                          1842          
00001DA0  B03C 0001               1843          Cmp.B   #%001, D0               ; Compare to Add source word
00001DA4  6700 0028               1844          Beq     EA_ADD_OPMODE_SOURCE
00001DA8                          1845          
00001DA8  B03C 0002               1846          Cmp.B   #%010, D0               ; Compare to Add source Long
00001DAC  6700 0020               1847          Beq     EA_ADD_OPMODE_SOURCE
00001DB0                          1848          
00001DB0  4EF9 00001DE6           1849          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001DB6                          1850          
00001DB6                          1851  EA_ADDA ; Figures out the EA for AddA
00001DB6  4EB9 00001DFE           1852          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DBC  1CFC 002C               1853          Move.B  #',', (A6)+             ; Add a comma
00001DC0  4EB9 00002148           1854          Jsr     GET9TO11                ; Get the register
00001DC6  4EB9 00002002           1855          Jsr     EA_AN                   ; Add An
00001DCC                          1856          
00001DCC  4E75                    1857          RTS
00001DCE                          1858          
00001DCE                          1859  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001DCE  4EB9 00001DFE           1860          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DD4  1CFC 002C               1861          Move.B  #',', (A6)+             ; Add a comma
00001DD8  4EB9 00002148           1862          Jsr     GET9TO11                ; Get the register
00001DDE  4EB9 00001FF6           1863          Jsr     EA_DN                   ; Add Dn
00001DE4                          1864          
00001DE4  4E75                    1865          RTS
00001DE6                          1866          
00001DE6                          1867  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001DE6  4EB9 00002148           1868          Jsr     GET9TO11                ; Get the register
00001DEC  4EB9 00001FF6           1869          Jsr     EA_DN                   ; Add Dn
00001DF2  1CFC 002C               1870          Move.B  #',', (A6)+             ; Add a comma
00001DF6  4EB9 00001DFE           1871          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001DFC                          1872          
00001DFC  4E75                    1873          RTS
00001DFE                          1874          
00001DFE                          1875  EA_ADD_ADDRESS
00001DFE  4EB9 000020D2           1876          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E04                          1877          
00001E04  B03C 0004               1878          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E08  6700 0004               1879          Beq     EA_ADD_SIZE
00001E0C                          1880  
00001E0C  4E75                    1881          Rts
00001E0E                          1882          
00001E0E                          1883  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E0E  4EB9 0000215A           1884          Jsr     GET6TO8                 ; Get Move size
00001E14                          1885  
00001E14  B03C 0000               1886          Cmp.B   #%000, D0               ; Byte
00001E18  6700 0288               1887          Beq     EA_IMM_BYTE
00001E1C                          1888  
00001E1C  B03C 0001               1889          Cmp.B   #%001, D0               ; Word
00001E20  6700 0290               1890          Beq     EA_IMM_WORD
00001E24                          1891          
00001E24  B03C 0002               1892          Cmp.B   #%010, D0               ; Long
00001E28  6700 0298               1893          Beq     EA_IMM_LONG
00001E2C                          1894          
00001E2C  B03C 0003               1895          Cmp.B   #%011, D0               ; AddA Word
00001E30  6700 0280               1896          Beq     EA_IMM_WORD
00001E34                          1897     
00001E34  B03C 0007               1898          Cmp.B   #%111, D0               ; AddA Long
00001E38  6700 0288               1899          Beq     EA_IMM_LONG
00001E3C                          1900          
00001E3C  4E75                    1901          Rts
00001E3E                          1902          
00001E3E                          1903  ;=================================================;        
00001E3E                          1904  ;-------------------- EA AddQ --------------------;
00001E3E                          1905  ;=================================================;
00001E3E                          1906  EA_ADDQ ; Figures out the EA for AddQ
00001E3E  4EB9 00001E4E           1907          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001E44  1CFC 002C               1908          Move.B  #',', (A6)+             ; Add a comma
00001E48  4EB9 00001E72           1909          Jsr     EA_ADDQ_DEST            ; Add the destination
00001E4E                          1910  
00001E4E                          1911  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001E4E  4EB9 00002148           1912          Jsr     GET9TO11                ; Isolate the count/register bits
00001E54                          1913          
00001E54  B03C 0000               1914          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001E58  6E00 000C               1915          Bgt     EA_ADDQ_IMMEDIATE
00001E5C                          1916          
00001E5C  103C 0008               1917          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001E60                          1918          
00001E60  4EF9 00001E66           1919          Jmp     EA_ADDQ_IMMEDIATE
00001E66                          1920          
00001E66                          1921  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001E66  1CFC 0023               1922          Move.B  #'#', (A6)+
00001E6A  0600 0030               1923          Add.B   #$30, D0
00001E6E  1CC0                    1924          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001E70                          1925          
00001E70  4E75                    1926          Rts
00001E72                          1927          
00001E72                          1928  EA_ADDQ_DEST    ; Determines the destination       
00001E72  4EB9 000020D2           1929          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E78  4E75                    1930          Rts     ; Blong edited, was blank
00001E7A                          1931          
00001E7A                          1932  ;=========================================================;        
00001E7A                          1933  ;---------------------- EA Sub/SubA ----------------------;
00001E7A                          1934  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E7A                          1935  ; Sub/SubA are exactly the same.
00001E7A                          1936  ;=========================================================;
00001E7A                          1937  EA_SUB
00001E7A  4EF8 1D82               1938          Jmp     EA_ADD
00001E7E                          1939  
00001E7E                          1940  ;=========================================================;        
00001E7E                          1941  ;---------------------- EA Cmp/CmpA ----------------------;
00001E7E                          1942  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E7E                          1943  ; Cmp/CmpA are exactly the same.
00001E7E                          1944  ;=========================================================;
00001E7E                          1945  EA_CMP       
00001E7E  4EF8 1D82               1946          Jmp     EA_ADD
00001E82                          1947          
00001E82                          1948  ;=========================================================;        
00001E82                          1949  ;------------------------ EA Lea -------------------------;
00001E82                          1950  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001E82                          1951  ; are exactly the same.
00001E82                          1952  ;=========================================================;
00001E82                          1953  EA_LEA
00001E82  4EF8 1D82               1954          Jmp     EA_ADD
00001E86                          1955          
00001E86                          1956  ;=========================================================;        
00001E86                          1957  ;------------------------ EA And -------------------------;
00001E86                          1958  ; Jumps straight to EA_ADD because the EA for Add and And
00001E86                          1959  ; are exactly the same.
00001E86                          1960  ;=========================================================;
00001E86                          1961  EA_AND
00001E86  4EF8 1D82               1962          Jmp     EA_ADD
00001E8A                          1963          
00001E8A                          1964  ;=========================================================;        
00001E8A                          1965  ;------------------------ EA Eor -------------------------;
00001E8A                          1966  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001E8A                          1967  ; are exactly the same.
00001E8A                          1968  ;=========================================================;
00001E8A                          1969  EA_EOR
00001E8A  4EF8 1D82               1970          Jmp     EA_ADD
00001E8E                          1971          
00001E8E                          1972  ;=========================================================;        
00001E8E                          1973  ;------------------------ EA Neg -------------------------;
00001E8E                          1974  ;=========================================================;
00001E8E                          1975  EA_NEG
00001E8E  4EB9 000020D2           1976          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E94                          1977          
00001E94  4E75                    1978          RTS
00001E96                          1979          
00001E96                          1980  ;=========================================================;        
00001E96                          1981  ;------------------------ EA Not -------------------------;
00001E96                          1982  ; Jumps straight to EA_NEG because Neg and Not have the
00001E96                          1983  ; exact same EAs. 
00001E96                          1984  ;=========================================================;
00001E96                          1985  EA_NOT
00001E96  4EF8 1E8E               1986          Jmp     EA_NEG 
00001E9A                          1987          
00001E9A                          1988  ;=========================================================;        
00001E9A                          1989  ;------------------------ EA Jsr -------------------------;
00001E9A                          1990  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001E9A                          1991  ; exact same EAs. 
00001E9A                          1992  ;=========================================================;
00001E9A                          1993  EA_Jsr
00001E9A  4EF8 1E8E               1994          Jmp     EA_NEG 
00001E9E                          1995  
00001E9E                          1996  ;=========================================================;
00001E9E                          1997  ;--------------------- EA Bit Shift ----------------------;
00001E9E                          1998  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001E9E                          1999  ; are combined because the EA for each code is exactly the
00001E9E                          2000  ; same.
00001E9E                          2001  ;=========================================================;
00001E9E                          2002  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001E9E  4EB9 0000220A           2003          Jsr     GET6TO7
00001EA4                          2004          
00001EA4  B03C 0003               2005          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001EA8  6600 0012               2006          Bne     EA_SHIFT_REGISTER
00001EAC                          2007          
00001EAC  4EB9 00001EB4           2008          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001EB2                          2009          
00001EB2  4E75                    2010          RTS
00001EB4                          2011                  
00001EB4                          2012  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001EB4  4EB9 000020D2           2013          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EBA                          2014          
00001EBA  4E75                    2015          Rts
00001EBC                          2016          
00001EBC                          2017  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001EBC  4EB9 000021D8           2018          Jsr     GETBIT5
00001EC2                          2019          
00001EC2  B03C 0000               2020          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001EC6  6700 0008               2021          Beq     EA_SHIFT_CHECK_8
00001ECA                          2022          
00001ECA  4EF9 00001EF8           2023          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001ED0                          2024          
00001ED0                          2025  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001ED0  4EB9 00002148           2026          Jsr     GET9TO11                ; Isolate the count/register bits
00001ED6                          2027          
00001ED6  B03C 0000               2028          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001EDA  6E00 000C               2029          Bgt     EA_SHIFT_IMMEDIATE
00001EDE                          2030          
00001EDE  103C 0008               2031          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001EE2                          2032                  
00001EE2  4EF9 00001EE8           2033          Jmp     EA_SHIFT_IMMEDIATE
00001EE8                          2034          
00001EE8                          2035  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001EE8  1CFC 0023               2036          Move.B  #'#', (A6)+
00001EEC  0600 0030               2037          Add.B   #$30, D0
00001EF0  1CC0                    2038          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001EF2                          2039  
00001EF2  4EF9 00001F0A           2040          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001EF8                          2041          
00001EF8                          2042  EA_SHIFT_DN ; Adds a data register before the comma
00001EF8  4EB9 00002148           2043          Jsr     GET9TO11                ; Isolate the data register bits
00001EFE                          2044          
00001EFE  4EB9 00001FF6           2045          Jsr     EA_DN                   ; Add the data register to the string
00001F04                          2046          
00001F04  4EF9 00001F0A           2047          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F0A                          2048          
00001F0A                          2049  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F0A  1CFC 002C               2050          Move.B  #',', (A6)+
00001F0E                          2051          
00001F0E  4EB9 0000217E           2052          Jsr     GET0TO2                 ; Get the register number
00001F14                          2053          
00001F14  4EB9 00001FF6           2054          Jsr     EA_DN                   ; Add the register
00001F1A                          2055          
00001F1A  4E75                    2056          RTS
00001F1C                          2057  
00001F1C                          2058  ;============================================;        
00001F1C                          2059  ;--------------- EA Immediate ---------------;
00001F1C                          2060  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F1C                          2061  ;============================================;
00001F1C                          2062  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F1C  4EB9 00001F2E           2063          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F22  1CFC 002C               2064          Move.B  #',', (A6)+             ; Add a comma
00001F26  4EB9 00001F4C           2065          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001F2C                          2066          
00001F2C  4E75                    2067          RTS
00001F2E                          2068          
00001F2E                          2069  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001F2E  4EB9 0000220A           2070          Jsr     GET6TO7                 ; Isolate the size bits
00001F34                          2071                  
00001F34  B03C 0001               2072          Cmp.B   #%01, D0                ; Immediate word
00001F38  6700 0178               2073          Beq     EA_IMM_WORD
00001F3C                          2074          
00001F3C  B03C 0002               2075          Cmp.B   #%10, D0                ; Immediate long
00001F40  6700 0180               2076          Beq     EA_IMM_LONG
00001F44                          2077        
00001F44  4EF9 000020A2           2078          Jmp     EA_IMM_BYTE
00001F4A                          2079  
00001F4A  4E75                    2080          Rts
00001F4C                          2081          
00001F4C                          2082  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001F4C  4EB9 000020D2           2083          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F52                          2084          
00001F52  4E75                    2085          Rts
00001F54                          2086        
00001F54                          2087  ;=================================================;  
00001F54                          2088  ;-------------------- EA Muls --------------------;
00001F54                          2089  ;=================================================;
00001F54                          2090  EA_MULS ; Determines the EA for Muls
00001F54  4EB9 00001F6C           2091          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001F5A  1CFC 002C               2092          Move.B  #',', (A6)+             ; Add a comma
00001F5E  4EB9 00002148           2093          Jsr     GET9TO11                ; Get the register
00001F64  4EB9 00001FF6           2094          Jsr     EA_DN                   ; Add Dn
00001F6A                          2095          
00001F6A  4E75                    2096          RTS
00001F6C                          2097          
00001F6C                          2098  EA_MULS_ADDRESS ; Determines the EA
00001F6C  4EB9 000020D2           2099          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F72                          2100          
00001F72  B03C 0004               2101          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001F76  6700 013A               2102          Beq     EA_IMM_WORD
00001F7A                          2103          
00001F7A  4E75                    2104          Rts
00001F7C                          2105          
00001F7C                          2106  ;=================================================;  
00001F7C                          2107  ;-------------------- EA DIVS --------------------;
00001F7C                          2108  ; Jumps straight to EA_DIVS because the EA for
00001F7C                          2109  ; both OP codes is exactly the same.
00001F7C                          2110  ;=================================================;
00001F7C                          2111  EA_DIVS
00001F7C  4EF8 1F54               2112          Jmp     EA_MULS
00001F80                          2113          
00001F80                          2114  ;=================================================;        
00001F80                          2115  ;-------------------- EA BTST --------------------;
00001F80                          2116  ;=================================================;
00001F80                          2117  EA_BTST ; Determines the EA for Btst
00001F80  4EB9 00002190           2118          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001F86                          2119          
00001F86  B03C 0001               2120          Cmp.B   #%1, D0                 ; 1 is a data register
00001F8A  6700 0008               2121          Beq     EA_BTST_DN
00001F8E                          2122          
00001F8E  4EF9 00001FA8           2123          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
00001F94                          2124          
00001F94                          2125  EA_BTST_DN  ; Gets the register for the bit number
00001F94  4EB9 00002148           2126          Jsr     GET9TO11                ; Get the register
00001F9A  4EB9 00001FF6           2127          Jsr     EA_DN                   ; Add the register to the string
00001FA0                          2128          
00001FA0  4EB9 00001FB8           2129          Jsr     EA_BTST_ADDRESS         ; Add the EA
00001FA6                          2130          
00001FA6  4E75                    2131          RTS
00001FA8                          2132  
00001FA8                          2133  EA_BTST_IMM ; Gets the immediate data for the bit number
00001FA8  524B                    2134          AddA.W  #1, A3                  ; Move the pointer forward by a byte to get the next byte
00001FAA  4EB9 000020A2           2135          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00001FB0                          2136          
00001FB0  4EB9 00001FB8           2137          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
00001FB6                          2138          
00001FB6  4E75                    2139          RTS
00001FB8                          2140  
00001FB8                          2141  EA_BTST_ADDRESS ; Get the EA
00001FB8  1CFC 002C               2142          Move.B  #',', (A6)+
00001FBC                          2143  
00001FBC  4EB9 000020D2           2144          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
00001FC2                          2145          
00001FC2  B03C 0004               2146          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
00001FC6  6700 00DA               2147          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
00001FCA                          2148          
00001FCA  4E75                    2149          Rts
00001FCC                          2150          
00001FCC                          2151  ;==================================================;        
00001FCC                          2152  ;------------------- EA Branch --------------------;
00001FCC                          2153  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00001FCC                          2154  ;==================================================;
00001FCC                          2155  EA_BRANCH  ; Determines the EA for Branch codes
00001FCC  4EB9 000021EA           2156          Jsr     GET0TO7                 ; Get the 8 displacement bits
00001FD2                          2157          
00001FD2  2C0B                    2158          Move.L  A3, D6                  ; Move address after the Bra word to D6
00001FD4                          2159          
00001FD4  B03C 0000               2160          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
00001FD8  6700 0008               2161          Beq     EA_BRANCH_16_BIT
00001FDC                          2162          
00001FDC  4EF9 00001FEA           2163          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
00001FE2                          2164  
00001FE2                          2165  EA_BRANCH_16_BIT   ; Gets the next word
00001FE2  301B                    2166          Move.W  (A3)+, D0               ; Stores the word in D0
00001FE4                          2167  
00001FE4  4EF9 00001FEA           2168          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
00001FEA                          2169          
00001FEA                          2170  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
00001FEA  DC40                    2171          Add.W   D0, D6                  ; Add the displacement to D6
00001FEC                          2172      
00001FEC  1CFC 0024               2173          Move.B  #'$', (A6)+             ; Add '$' to the string
00001FF0                          2174          
00001FF0  4EB8 1290               2175          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
00001FF4                          2176  
00001FF4  4E75                    2177          RTS
00001FF6                          2178                         
00001FF6                          2179  ;==========================================;        
00001FF6                          2180  ;---------- General EA functions ----------;
00001FF6                          2181  ;==========================================;
00001FF6                          2182  EA_DN   ; Adds Dn EA to string
00001FF6  1CFC 0044               2183          Move.B  #'D', (A6)+             
00001FFA  0600 0030               2184          Add.B   #$30, D0        
00001FFE  1CC0                    2185          Move.B  D0, (A6)+               
00002000                          2186                  
00002000  4E75                    2187          Rts
00002002                          2188  
00002002                          2189  EA_AN   ; Adds An EA to string
00002002  1CFC 0041               2190          Move.B  #'A', (A6)+
00002006  0600 0030               2191          Add.B   #$30, D0    
0000200A  1CC0                    2192          Move.B  D0, (A6)+               
0000200C                          2193                  
0000200C  4E75                    2194          Rts
0000200E                          2195  
0000200E                          2196  EA_AN_PNTR  ; Adds (An) EA to string
0000200E  1CFC 0028               2197          Move.B  #'(', (A6)+
00002012  1CFC 0041               2198          Move.B  #'A', (A6)+
00002016  0600 0030               2199          Add.B   #$30, D0
0000201A  1CC0                    2200          Move.B  D0, (A6)+
0000201C  1CFC 0029               2201          Move.B  #')', (A6)+
00002020                          2202                  
00002020  4E75                    2203          Rts
00002022                          2204          
00002022                          2205  EA_AN_INC   ; Adds (An)+ EA to string
00002022  1CFC 0028               2206          Move.B  #'(', (A6)+
00002026  1CFC 0041               2207          Move.B  #'A', (A6)+
0000202A  0600 0030               2208          Add.B   #$30, D0
0000202E  1CC0                    2209          Move.B  D0, (A6)+
00002030  1CFC 0029               2210          Move.B  #')', (A6)+
00002034  1CFC 002B               2211          Move.B  #'+', (A6)+
00002038                          2212                  
00002038  4E75                    2213          Rts 
0000203A                          2214          
0000203A                          2215  EA_AN_DEC   ; Adds -(An) EA to string
0000203A  1CFC 002D               2216          Move.B  #'-', (A6)+
0000203E  1CFC 0028               2217          Move.B  #'(', (A6)+
00002042  1CFC 0041               2218          Move.B  #'A', (A6)+
00002046  0600 0030               2219          Add.B   #$30, D0
0000204A  1CC0                    2220          Move.B  D0, (A6)+
0000204C  1CFC 0029               2221          Move.B  #')', (A6)+
00002050                          2222                  
00002050  4E75                    2223          Rts 
00002052                          2224  
00002052                          2225  EA_WORD_ADDR    ; Adds $Word to string
00002052  3C1B                    2226          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
00002054                          2227          
00002054  1CFC 0024               2228          Move.B  #'$', (A6)+
00002058                          2229          
00002058  BC7C 8000               2230          Cmp.W   #$8000, D6          ; Word address is less than 8000
0000205C  6500 000C               2231          Bcs     EA_SIGN_EXT_16
00002060                          2232          
00002060  BC7C 8000               2233          Cmp.W   #$8000, D6          ; Word address is greater than 8000
00002064  6400 001A               2234          Bcc     EA_SIGN_EXT_32
00002068                          2235          
00002068  4E75                    2236          Rts
0000206A                          2237                  
0000206A                          2238  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
0000206A  1CFC 0030               2239          Move.B  #'0', (A6)+
0000206E  1CFC 0030               2240          Move.B  #'0', (A6)+
00002072  1CFC 0030               2241          Move.B  #'0', (A6)+
00002076  1CFC 0030               2242          Move.B  #'0', (A6)+
0000207A                          2243          
0000207A  4EB8 12B0               2244          Jsr     hex_to_ASCII_W       
0000207E                          2245          
0000207E  4E75                    2246          Rts
00002080                          2247  
00002080                          2248  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
00002080  1CFC 0046               2249          Move.B  #'F', (A6)+
00002084  1CFC 0046               2250          Move.B  #'F', (A6)+
00002088  1CFC 0046               2251          Move.B  #'F', (A6)+
0000208C  1CFC 0046               2252          Move.B  #'F', (A6)+
00002090                          2253          
00002090  4EB8 12B0               2254          Jsr     hex_to_ASCII_W   
00002094                          2255          
00002094  4E75                    2256          Rts
00002096                          2257                  
00002096                          2258  EA_LONG_ADDR    ; Adds $Long to string
00002096  2C1B                    2259          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
00002098                          2260          
00002098  1CFC 0024               2261          Move.B  #'$', (A6)+
0000209C                          2262          
0000209C  4EB8 1290               2263          Jsr     hex_to_ASCII_L
000020A0                          2264  
000020A0  4E75                    2265          Rts
000020A2                          2266                  
000020A2                          2267  
000020A2                          2268  EA_IMM_BYTE ; Finds the immediate byte data
000020A2  3C1B                    2269          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
000020A4                          2270          
000020A4  1CFC 0023               2271          Move.B  #'#', (A6)+         
000020A8  1CFC 0024               2272          Move.B  #'$', (A6)+         
000020AC                          2273          
000020AC  4EB8 12D0               2274          Jsr     hex_to_ASCII_B    ; Add the byte to the string
000020B0                          2275          
000020B0  4E75                    2276          Rts
000020B2                          2277                  
000020B2                          2278  EA_IMM_WORD ; Finds the immediate word data
000020B2  3C1B                    2279          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
000020B4                          2280          
000020B4  1CFC 0023               2281          Move.B  #'#', (A6)+         
000020B8  1CFC 0024               2282          Move.B  #'$', (A6)+         
000020BC                          2283          
000020BC  4EB8 12B0               2284          Jsr     hex_to_ASCII_W    ; Add the word to the string
000020C0                          2285          
000020C0  4E75                    2286          Rts
000020C2                          2287          
000020C2                          2288  EA_IMM_LONG ; Finds the immediate long data
000020C2  2C1B                    2289          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
000020C4                          2290          
000020C4  1CFC 0023               2291          Move.B  #'#', (A6)+
000020C8  1CFC 0024               2292          Move.B  #'$', (A6)+
000020CC                          2293          
000020CC  4EB8 1290               2294          Jsr     hex_to_ASCII_L    ; Add the long to the string
000020D0                          2295          
000020D0  4E75                    2296          Rts
000020D2                          2297          
000020D2                          2298  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
000020D2  4EB9 0000216C           2299          Jsr     GET3TO5                 ; Get source mode
000020D8  1A00                    2300          Move.B  D0, D5                  ; Move source mode to D5
000020DA  4EB9 0000217E           2301          Jsr     Get0TO2                 ; Get source register
000020E0                          2302          
000020E0                          2303          ; List of valid effective addresses
000020E0  BA3C 0000               2304          Cmp.B   #Dn_Mode, D5            ; Dn
000020E4  6700 FF10               2305          Beq     EA_DN
000020E8                          2306          
000020E8  BA3C 0001               2307          Cmp.B   #An_Mode, D5            ; An
000020EC  6700 FF14               2308          Beq     EA_AN
000020F0                          2309          
000020F0  BA3C 0002               2310          Cmp.B   #An_Pntr_Mode, D5       ; (An)
000020F4  6700 FF18               2311          Beq     EA_AN_PNTR
000020F8                          2312          
000020F8  BA3C 0003               2313          Cmp.B   #An_Inc_Mode, D5        ; (An)+
000020FC  6700 FF24               2314          Beq     EA_AN_INC
00002100                          2315          
00002100  BA3C 0004               2316          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00002104  6700 FF34               2317          Beq     EA_AN_DEC
00002108                          2318          
00002108                          2319          ; Comparing registers at this point because modes are the same
00002108  B03C 0000               2320          Cmp.B   #Word_Reg, D0           ; (xxx).W
0000210C  6700 FF44               2321          Beq     EA_WORD_ADDR
00002110                          2322          
00002110  B03C 0001               2323          Cmp.B   #Long_Reg, D0           ; (xxx).L
00002114  6780                    2324          Beq     EA_LONG_ADDR
00002116                          2325          
00002116  4E75                    2326          Rts
00002118                          2327      
00002118                          2328  
00002118                          2329  ;---------------- Bit Chopping Sub Routines ----------------;
00002118                          2330  ; These Sub Routines Chop a WORD size piece of data from
00002118                          2331  ; Data register 4 into a smaller piece, leaving just the
00002118                          2332  ; Piece in register 0 while leaving the original piece
00002118                          2333  ; of data intact.
00002118                          2334  
00002118                          2335  ; REGISTERS USED: D0, D1, D4 (const input)
00002118                          2336  
00002118                          2337  GET12TO15   ;1001 0000 0000 0000 -> 1001
00002118  4280                    2338                  CLR.L   D0      
0000211A  3004                    2339                  Move.W  D4, D0      
0000211C                          2340                  
0000211C  123C 000C               2341                  Move.B  #12, D1     
00002120  E268                    2342                  LSR.W       D1, D0      
00002122                          2343                  
00002122  4E75                    2344                  RTS
00002124                          2345                  
00002124                          2346  GET12TO13
00002124  4280                    2347          CLR.L   D0
00002126  3004                    2348          Move.W  D4, D0
00002128                          2349          
00002128  123C 0002               2350          Move.B  #2, D1
0000212C  E368                    2351          LSL     D1, D0
0000212E                          2352          
0000212E  123C 000E               2353          Move.B  #14, D1
00002132  E268                    2354          LSR     D1, D0
00002134                          2355          
00002134  4E75                    2356          RTS             
00002136                          2357  
00002136                          2358  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
00002136  4280                    2359                  CLR.L   D0      ; Clear out D0
00002138  3004                    2360                  Move.W  D4, D0      ; Move a copy of the bit string to D0
0000213A                          2361                  
0000213A  123C 0004               2362                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
0000213E  E368                    2363                  LSL.W   D1, D0      ; Move the string all the way to the left
00002140                          2364                  
00002140  123C 000C               2365                  Move.B  #12, D1     ; Change the amount of bits shifted
00002144  E268                    2366                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
00002146                          2367                  
00002146  4E75                    2368                  RTS         ; Return from the subroutine
00002148                          2369                      
00002148                          2370  GET9TO11    ; 0000 1010 0000 0000 -> 101    
00002148  4280                    2371                  CLR.L   D0      ; Clear out D0
0000214A  3004                    2372                  Move.W  D4, D0      ; Move a copy of the bit string to D0
0000214C                          2373                  
0000214C  123C 0004               2374                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002150  E368                    2375                  LSL.W   D1, D0      ; Move the string all the way to the left
00002152                          2376                  
00002152  123C 000D               2377                  Move.B  #13, D1     ; Change the amount of bits shifted
00002156  E268                    2378                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
00002158                          2379                  
00002158  4E75                    2380                  RTS         ; Return from the subroutine
0000215A                          2381                  
0000215A                          2382  GET6TO8     ; 0000 0001 1000 0000 -> 110
0000215A  4280                    2383                  CLR.L   D0
0000215C  3004                    2384                  Move.W  D4, D0
0000215E                          2385                  
0000215E  123C 0007               2386                  Move.B  #7, D1
00002162  E368                    2387                  LSL.W   D1, D0
00002164                          2388                  
00002164  123C 000D               2389                  Move.B  #13, D1
00002168  E268                    2390                  LSR.W       D1, D0
0000216A                          2391                  
0000216A  4E75                    2392                  RTS
0000216C                          2393                  
0000216C                          2394  GET3TO5     ; 0000 0000 0011 1000 -> 111
0000216C  4280                    2395                  CLR.L   D0
0000216E  3004                    2396                  Move.W  D4, D0
00002170                          2397                  
00002170  123C 000A               2398                  Move.B  #10, D1
00002174  E368                    2399                  LSL.W   D1, D0
00002176                          2400                  
00002176  123C 000D               2401                  Move.B  #13, D1
0000217A  E268                    2402                  LSR.W       D1, D0
0000217C                          2403                  
0000217C  4E75                    2404                  RTS
0000217E                          2405  GET0TO2     ; 0000 0000 0000 0011 -> 011
0000217E  4280                    2406                  CLR.L   D0
00002180  3004                    2407                  Move.W  D4, D0
00002182                          2408                  
00002182  123C 000D               2409                  Move.B  #13, D1
00002186  E368                    2410                  LSL.W   D1, D0
00002188                          2411                  
00002188  123C 000D               2412                  Move.B  #13, D1
0000218C  E268                    2413                  LSR.W       D1, D0
0000218E                          2414                  
0000218E  4E75                    2415                  RTS
00002190                          2416  GETBIT8     ; 0000 0001 0000 0000 -> 1
00002190  4280                    2417                  CLR.L   D0
00002192  3004                    2418                  Move.W  D4, D0
00002194                          2419                  
00002194  123C 0007               2420                  Move.B  #7, D1
00002198  E368                    2421                  LSL.W   D1, D0
0000219A                          2422                  
0000219A  123C 000F               2423                  Move.B  #15, D1
0000219E  E268                    2424                  LSR.W       D1, D0
000021A0                          2425                  
000021A0  4E75                    2426                  RTS
000021A2                          2427                  
000021A2                          2428  GET9AND10    ; 0000 0110 0000 0000 -> 11
000021A2  4280                    2429                  CLR.L   D0
000021A4  3004                    2430                  Move.W  D4, D0
000021A6                          2431                  
000021A6  123C 0005               2432                  Move.B  #5, D1
000021AA  E368                    2433                  LSL.W   D1, D0
000021AC                          2434                  
000021AC  123C 000E               2435                  Move.B  #14, D1
000021B0  E268                    2436                  LSR.W   D1, D0
000021B2                          2437                  
000021B2  4E75                    2438                  RTS             
000021B4                          2439                  
000021B4                          2440  GET6AND7    ; 0000 0000 1100 0000 -> 11
000021B4  4280                    2441                  CLR.L   D0
000021B6  3004                    2442                  Move.W  D4, D0
000021B8                          2443                  
000021B8  123C 0008               2444                  Move.B  #8, D1
000021BC  E368                    2445                  LSL.W   D1, D0
000021BE                          2446                  
000021BE  123C 000E               2447                  Move.B  #14, D1
000021C2  E268                    2448                  LSR.W   D1, D0
000021C4                          2449                  
000021C4  4E75                    2450                  RTS
000021C6                          2451                  
000021C6                          2452  GET3AND4    ; 0000 0000 0001 1000 -> 11
000021C6  4280                    2453                  CLR.L   D0
000021C8  3004                    2454                  Move.W  D4, D0
000021CA                          2455                  
000021CA  123C 000B               2456                  Move.B  #11, D1
000021CE  E368                    2457                  LSL.W   D1, D0
000021D0                          2458                  
000021D0  123C 000E               2459                  Move.B  #14, D1
000021D4  E268                    2460                  LSR.W   D1, D0
000021D6                          2461                  
000021D6  4E75                    2462                  RTS
000021D8                          2463                  
000021D8                          2464  GETBIT5
000021D8  4280                    2465          Clr.L   D0
000021DA  3004                    2466          Move.W  D4, D0
000021DC                          2467          
000021DC  123C 000A               2468          Move.B  #10, D1
000021E0  E368                    2469          Lsl     D1, D0
000021E2                          2470          
000021E2  123C 000F               2471          Move.B  #15, D1
000021E6  E268                    2472          Lsr     D1, D0
000021E8                          2473          
000021E8  4E75                    2474          Rts
000021EA                          2475  
000021EA                          2476  GET0TO7
000021EA  4280                    2477          Clr.L   D0
000021EC  3004                    2478          Move.W  D4, D0
000021EE                          2479          
000021EE  123C 0008               2480          Move.B  #8, D1
000021F2  E368                    2481          Lsl     D1, D0
000021F4                          2482          
000021F4  E268                    2483          Lsr     D1, D0
000021F6                          2484          
000021F6  4E75                    2485          Rts
000021F8                          2486          
000021F8                          2487  GETBIT10
000021F8  4280                    2488          Clr.L   D0
000021FA  3004                    2489          Move.W  D4, D0
000021FC                          2490          
000021FC  123C 0005               2491          Move.B  #5, D1
00002200  E368                    2492          Lsl     D1, D0
00002202                          2493          
00002202  123C 000F               2494          Move.B  #15, D1
00002206  E268                    2495          Lsr     D1, D0
00002208                          2496          
00002208  4E75                    2497          Rts
0000220A                          2498          
0000220A                          2499  GET6TO7
0000220A  4280                    2500          Clr.L   D0
0000220C  3004                    2501          Move.W  D4, D0
0000220E                          2502          
0000220E  123C 0008               2503          Move.B  #8, D1
00002212  E368                    2504          Lsl     D1, D0
00002214                          2505          
00002214  123C 000E               2506          Move.B  #14, D1
00002218  E268                    2507          Lsr     D1, D0
0000221A                          2508          
0000221A  4E75                    2509          Rts
0000221C                          2510  
0000221C                          2511  GET3TO8    ; 0000 0000 1100 0000 -> 11
0000221C  4280                    2512                  CLR.L   D0
0000221E  3004                    2513                  Move.W  D4, D0
00002220                          2514                  
00002220  123C 0007               2515                  Move.B  #7, D1
00002224  E368                    2516                  LSL.W   D1, D0
00002226                          2517                  
00002226  123C 000A               2518                  Move.B  #10, D1
0000222A  E268                    2519                  LSR.W   D1, D0
0000222C                          2520                  
0000222C  4E75                    2521                  RTS
0000222E                          2522  
0000222E                          2523  GET6TO11    ; 0000 0000 1100 0000 -> 11
0000222E  4280                    2524                  CLR.L   D0
00002230  3004                    2525                  Move.W  D4, D0
00002232                          2526                  
00002232  123C 0004               2527                  Move.B  #4, D1
00002236  E368                    2528                  LSL.W   D1, D0
00002238                          2529                  
00002238  123C 000A               2530                  Move.B  #10, D1
0000223C  E268                    2531                  LSR.W   D1, D0
0000223E                          2532                  
0000223E  4E75                    2533                  RTS        
00002240                          2534                  
00002240                          2535             
00002240                          2536  ;-----------Constants/Messages-------------------------------------------------
00002240= 09 2D 2D 2D 2D 2D ...   2537  intro_stuff     DC.B    HT,'------------------------------------------------------',CR,LF,0
0000227A                          2538  
0000227A= 09 20 57 65 6C 63 ...   2539  intro_msg       DC.B    HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000022B2= 09 20 43 72 65 61 ...   2540                  DC.B    HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
000022EB                          2541         
000022EB= 50 6C 65 61 73 65 ...   2542  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
00002324= 50 6C 65 61 73 65 ...   2543  end_address1    DC.B    'Please enter the ending address from $',0
0000234B= 20 74 6F 20 24 30 ...   2544  end_address2    DC.B    ' to $00FFFFFE: ',0
0000235B= 54 68 61 6E 6B 20 ...   2545  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
0000238D= 57 6F 75 6C 64 20 ...   2546  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000023BD= 48 69 74 20 65 6E ...   2547  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
000023EB                          2548  
000023EB= 09 41 64 64 72 65 ...   2549  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
00002421= 09 59 6F 75 20 6E ...   2550  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
0000244D= 09 50 6C 65 61 73 ...   2551  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
00002485                          2552  
00002486                          2553  start_input     DS.L    2               ; Allocates space for start address
0000248E                          2554  end_input       DS.L    2               ; Allocates space for end address
00002496                          2555  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
0000249E                          2556  hit_enter       DS.L    2               ; User input to hit enter
000024A6                          2557  line_count      DS.L    1               ; Holds the display line count  
000024AA                          2558  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
000025EA                          2559  valid_data      DS.L    80              ; Instructions that we converted
0000272A                          2560                  
0000272A                          2561                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            14F2
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           244D
ASK_INPUT           2496
ASK_USER            238D
BADADDR_INPUT       23EB
BAD_BUFF            1134
BEGIN               0
BIT_SHIFT           1532
BIT_SHIFT_MEM       1544
BIT_SHIFT_REG       1566
BRANCH_CONDITIONALS  1470
CHECK_10_LINES      118A
CHECK_INPUT         1244
CHK_BOUND           1336
CMP_EOR             1588
CONVERT_HEX         12F0
CR                  D
DISASSEMBLE         10DE
DISPLAY_DATA        114E
DN_MODE             0
DONE                1222
DONE_CONVERTING     1312
EA_0TO5             20D2
EA_ADD              1D82
EA_ADDA             1DB6
EA_ADDQ             1E3E
EA_ADDQ_CHECK_8     1E4E
EA_ADDQ_DEST        1E72
EA_ADDQ_IMMEDIATE   1E66
EA_ADD_ADDRESS      1DFE
EA_ADD_OPMODE_DEST  1DE6
EA_ADD_OPMODE_SOURCE  1DCE
EA_ADD_SIZE         1E0E
EA_AN               2002
EA_AND              1E86
EA_AN_DEC           203A
EA_AN_INC           2022
EA_AN_PNTR          200E
EA_BIT_SHIFT        1E9E
EA_BRANCH           1FCC
EA_BRANCH_16_BIT    1FE2
EA_BRANCH_ADD_DIS   1FEA
EA_BTST             1F80
EA_BTST_ADDRESS     1FB8
EA_BTST_DN          1F94
EA_BTST_IMM         1FA8
EA_CMP              1E7E
EA_DIVS             1F7C
EA_DN               1FF6
EA_EOR              1E8A
EA_IMMEDIATE        1F1C
EA_IMMEDIATE_DEST   1F4C
EA_IMMEDIATE_SIZE   1F2E
EA_IMM_BYTE         20A2
EA_IMM_LONG         20C2
EA_IMM_WORD         20B2
EA_JSR              1E9A
EA_LEA              1E82
EA_LONG_ADDR        2096
EA_MOVE             1B3E
EA_MOVEM            1BC8
EA_MOVEM_ADD_LAST_REG  1CB2
EA_MOVEM_ADD_SINGLE_REG  1C92
EA_MOVEM_CARRY_CLEAR  1C72
EA_MOVEM_CARRY_SET  1C52
EA_MOVEM_FIRST_REG  1C82
EA_MOVEM_LAST_REG   1CA4
EA_MOVEM_LIST_END   1C3C
EA_MOVEM_LIST_LOOP  1C20
EA_MOVEM_MEM_TO_REG  1C04
EA_MOVEM_POST_INC   1C48
EA_MOVEM_PRE_DEC    1C3E
EA_MOVEM_REG        1CC6
EA_MOVEM_REG_TO_MEM  1BEE
EA_MOVE_DEST        1B60
EA_MOVE_SIZE        1BA8
EA_MOVE_SOURCE      1B50
EA_MULS             1F54
EA_MULS_ADDRESS     1F6C
EA_NEG              1E8E
EA_NOT              1E96
EA_SHIFT_CHECK_8    1ED0
EA_SHIFT_COMMA      1F0A
EA_SHIFT_DN         1EF8
EA_SHIFT_IMMEDIATE  1EE8
EA_SHIFT_MEMORY     1EB4
EA_SHIFT_REGISTER   1EBC
EA_SIGN_EXT_16      206A
EA_SIGN_EXT_32      2080
EA_SUB              1E7A
EA_WORD_ADDR        2052
END                 FFFFFE
ENDING              235B
END_ADDRESS1        2324
END_ADDRESS2        234B
END_ERROR           131E
END_INPUT           248E
GET0TO2             217E
GET0TO7             21EA
GET12TO13           2124
GET12TO15           2118
GET3AND4            21C6
GET3TO5             216C
GET3TO8             221C
GET6AND7            21B4
GET6TO11            222E
GET6TO7             220A
GET6TO8             215A
GET8TO11            2136
GET9AND10           21A2
GET9TO11            2148
GETBIT10            21F8
GETBIT5             21D8
GETBIT8             2190
GOOD_BUFF           1144
HEX_ASCII_LOOPB     12DA
HEX_ASCII_LOOPL     129A
HEX_ASCII_LOOPW     12BA
HEX_TO_ASCII_B      12D0
HEX_TO_ASCII_L      1290
HEX_TO_ASCII_W      12B0
HIT_ENTER           249E
HIT_ENTER_MSG       23BD
HT                  9
ILLEGAL             1158
ILLEGAL_DATA        24AA
IMMEDIATE_BTST      13D8
IMM_MODE            7
IMM_REG             4
INTRO_MSG           227A
INTRO_STUFF         2240
INVALID             1288
IS_LETTER           127A
IS_NUMBER           1272
JSR_RTS             1456
LF                  A
LINE_COUNT          24A6
LOAD_BAD_INPUT      1328
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1AB6
MAIN_LOOP           1124
MAKE_LETTER         1308
MAKE_NUMBER         12FC
ODD_ERR             134A
ODD_INPUT           2421
OP_ADD              16A0
OP_ADDQ             15F6
OP_ADD_ADDR         16CA
OP_ADD_ADDRESS_VERSION  1ACA
OP_AND              198E
OP_AS_MEM           19C8
OP_AS_REG           19AA
OP_BRANCH           1822
OP_BRA_CC           1864
OP_BRA_CS           187A
OP_BRA_EQ           18A6
OP_BRA_GE           1914
OP_BRA_GT           1940
OP_BRA_HIGH         1838
OP_BRA_LE           1956
OP_BRA_LOW          184E
OP_BRA_LT           192A
OP_BRA_MI           18FE
OP_BRA_NE           1890
OP_BRA_PL           18E8
OP_BRA_VC           18BC
OP_BRA_VS           18D2
OP_BTST             16DE
OP_CHECK_ADDRESS_VERSION  1AC0
OP_CHECK_DATA_SIZE  1AD0
OP_CHECK_DATA_SIZE_ADDR  1AF0
OP_CMP              1A4C
OP_CMPI             1754
OP_CMP_ADDR         1A76
OP_CODE_TREE        135C
OP_DIVS             1632
OP_EOR              1A8A
OP_EORI             1734
OP_JSR              180C
OP_LEA              1774
OP_LS_MEM           19FE
OP_LS_REG           19E0
OP_MOVE             15AA
OP_MOVEM            17C2
OP_MOVEM_DATA       17E6
OP_MOVE_DATA        15DC
OP_MULS             196C
OP_NEG              178A
OP_NOT              17A6
OP_ORI              16F8
OP_RO_MEM           1A34
OP_RO_REG           1A16
OP_RTS              17F8
OP_SET_BAD_BUFFER   1AA6
OP_SET_DATA_BYTE    1B02
OP_SET_DATA_LONG    1B16
OP_SET_DATA_WORD    1B0C
OP_SHIFT_DIRECTION  1B20
OP_SHIFT_LEFT       1B38
OP_SHIFT_RIGHT      1B32
OP_SUB              1662
OP_SUBI             1714
OP_SUB_ADDR         168C
OP_TAB              1AAC
PROMPT_END          107A
PROMPT_FOR_DATA     119C
PROMPT_START        1024
PROMPT_TO_RERUN     11BA
RERUN_ERR_MSG       1214
RETURN              128C
SINGLE_OPERATOR_CODES  141E
START               1000
START_ADDRESS       22EB
START_ERROR         1314
START_INPUT         2486
VALID_DATA          25EA
VALID_END           10BE
VALID_START         1058
VERIFIED            1282
VERIFY_INPUT        1232
WORD_MODE           7
WORD_REG            0
