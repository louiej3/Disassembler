00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 12/2/2014 12:52:39 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 00002248             30                  LEA     intro_stuff, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 00002282             33                  LEA     intro_msg, A1       ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 00002248             36                  LEA     intro_stuff, A1     ; Load introduction
0000101E  103C 000D                 37                  MOVE.B  #13, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024                            39                  
00001024                            40  
00001024                            41  *-----------Prompt For Starting Address---------------------                  
00001024  43F9 000022F3             42  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
0000102A  103C 000E                 43                  MOVE.B  #14,D0              ; Load task code for display
0000102E  4E4F                      44                  TRAP    #15                 ; Display prompt message
00001030                            45                  
00001030  43F9 0000248E             46                  LEA     start_input,A1      ; Load address to store user's input
00001036  103C 0002                 47                  MOVE.B  #2,D0               ; Load task code for user input
0000103A  4E4F                      48                  TRAP    #15                 ; Ask for user input
0000103C  4EB9 00001232             49                  JSR     verify_input        ; Verifies user input string
00001042  B83C 0001                 50                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001046  6700 0010                 51                  BEQ     valid_start         ; Go to valid start if equal 
0000104A                            52                  
0000104A  43F9 000023F3             53                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
00001050  103C 000E                 54                  MOVE.B  #14,D0              ; Load task code for display
00001054  4E4F                      55                  TRAP    #15                 ; Display bad input message
00001056  60CC                      56                  BRA     prompt_start        ; Go back beginning, asking for start address
00001058                            57  
00001058  4EB9 00001336             58  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000105E  B67C FFFF                 59                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
00001062  67C0                      60                  BEQ     prompt_start        ; Go back and ask for correct input
00001064  7C00                      61                  MOVE.L  #begin,D6           ; Store minimum address in D6
00001066  B686                      62                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001068  6D00 02AA                 63                  BLT     start_error         ; Then, start address is too low
0000106C  2C3C 00FFFFFE             64                  MOVE.L  #end,D6             ; Store max end address for comparison
00001072  B686                      65                  CMP.L   D6,D3               ; If start address is lower than minimum address
00001074  6E00 029E                 66                  BGT     start_error         ; Then, start address is too high
00001078  2643                      67                  MOVEA.L D3,A3               ; Load starting address                 
0000107A                            68  
0000107A                            69  *-----------Prompt for Ending Address-----------------------            
0000107A  43F9 0000232C             70  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
00001080  103C 000E                 71                  MOVE.B  #14,D0              ; Load task code for display
00001084  4E4F                      72                  TRAP    #15                 ; Display prompt message
00001086  43F9 0000248E             73                  LEA     start_input,A1      ; Load starting address
0000108C  4E4F                      74                  TRAP    #15                 ; Display starting address
0000108E  43F9 00002353             75                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
00001094  4E4F                      76                  TRAP    #15                 ; Display prompt message
00001096  43F9 00002496             77                  LEA     end_input,A1        ; Ask for ending address
0000109C  103C 0002                 78                  MOVE.B  #2,D0               ; Load task code for input
000010A0  4E4F                      79                  TRAP    #15                 ; Prompt for input
000010A2  4EB9 00001232             80                  JSR     verify_input        ; Verifies user input string
000010A8  B83C 0001                 81                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010AC  6700 0010                 82                  BEQ     valid_end           ; Now validate the ending address
000010B0  43F9 000023F3             83                  LEA     badAddr_input,A1        ; Else, bad input
000010B6  103C 000E                 84                  MOVE.B  #14,D0              ; Load task code for display
000010BA  4E4F                      85                  TRAP    #15                 ; Display bad input message
000010BC  60BC                      86                  BRA     prompt_end          ; Restart process
000010BE                            87  
000010BE  4EB9 00001336             88  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
000010C4  B67C FFFF                 89                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
000010C8  67B0                      90                  BEQ     prompt_end          ; Go back and ask for correct input
000010CA  2C3C 00FFFFFE             91                  MOVE.L  #end,D6             ; Move max address to compare with input
000010D0  B686                      92                  CMP.L   D6,D3               ; Is input higher than max
000010D2  6E00 024A                 93                  BGT     end_error           ; Input address is too high
000010D6  B68B                      94                  CMP.L   A3,D3               ; Is input at or above minimum address
000010D8  6D00 0244                 95                  BLT     end_error           ; Input address is too low
000010DC  2843                      96                  MOVEA.L D3,A4               ; Load ending address
000010DE                            97                                 
000010DE                            98  ;-------------- disassemble ---------------------------------------------------
000010DE                            99  ; -- Reads the data from the specified memory locations
000010DE                           100  ; -- Passes the data over to OP-code to verify the instruction
000010DE                           101  ; -- Decodes the word data from the specified memory location until the end
000010DE                           102  ; -- Checks for illegal data and valid data with the bad buffer bit
000010DE                           103  ;------------------------------------------------------------------------------
000010DE  4283                     104  disassemble     CLR.L   D3                  ; Clear for IO usage
000010E0  4284                     105                  CLR.L   D4                  ; Clear for OP Code usage              
000010E2  B7CC                     106                  CMP.L   A4,A3               ; At the end address?
000010E4  6E00 00D4                107                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
000010E8                           108                  
000010E8  4EB9 0000118A            109                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
000010EE  2C0B                     110                  MOVE.L  A3,D6               ; Store current address
000010F0                           111                  
000010F0  4DF9 000024B2            112                  LEA     illegal_data,A6     ; Load illegal data's address
000010F6  4EB9 00001290            113                  JSR     hex_to_ASCII_L      ; Store address to memory for display
000010FC  204E                     114                  MOVEA.L A6,A0               ; Store current location of illegal data
000010FE                           115                  
000010FE  4BF9 000025F2            116                  LEA     valid_data,A5       ; Store current address to memory
00001104                           117                  
00001104  4DF9 000025F2            118                  LEA     valid_data,A6       ; Store current address to memory
0000110A  4EB9 00001290            119                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
00001110  1CFC 0009                120                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001114                           121                  
00001114  381B                     122                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001116  4EB9 0000135C            123                  JSR     OP_CODE_TREE        ; Go to OP code jump table
0000111C                           124                  
0000111C  BE3C 0001                125                  CMP.B   #1,D7               ; Bad buffer set?
00001120  6700 0036                126                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001124                           127  main_loop
00001124                           128                  ; Store new line in memory
00001124  1CFC 000A                129                  MOVE.B  #LF,(A6)+
00001128  1CFC 000D                130                  MOVE.B  #CR,(A6)+
0000112C  BE3C 0001                131                  CMP.B   #1,D7               ; Bad buffer set?
00001130  6600 0012                132                  BNE     good_buff           ; Good Buffer, go prep for display
00001134                           133                  
00001134  4287                     134  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001136  1CFC 0000                135                  MOVE.B  #00,(A6)+           ; Add null terminator
0000113A  43F9 000024B2            136                  LEA     illegal_data,A1     ; Load the illegal data for display
00001140  6000 000C                137                  BRA     display_data        ; Go to display data
00001144                           138                  
00001144  1CFC 0000                139  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001148  43F9 000025F2            140                  LEA     valid_data,A1       ; Load the valid data for display
0000114E                           141                  
0000114E  4280                     142  display_data    CLR.L   D0                  ; Clear for TASK TRAP
00001150  103C 000E                143                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001154  4E4F                     144                  TRAP    #15                 ; to in memory.
00001156  6086                     145                  BRA     disassemble         ; Done disassembling the word, next word                
00001158                           146                                                 
00001158                           147  ILLEGAL         ; word data from memory is not a required instruction
00001158  4BF9 000024B2            148                  LEA     illegal_data,A5     ; Store current address to memory
0000115E  2C48                     149                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
00001160  1CFC 0009                150                  MOVE.B  #HT,(A6)+           ; Store TAB 
00001164  1CFC 0044                151                  MOVE.B  #'D',(A6)+          ; Store DATA
00001168  1CFC 0041                152                  MOVE.B  #'A',(A6)+
0000116C  1CFC 0054                153                  MOVE.B  #'T',(A6)+
00001170  1CFC 0041                154                  MOVE.B  #'A',(A6)+
00001174  4EB9 00001AB4            155                  JSR     OP_TAB              ; Set up third collumn
0000117A  1CFC 0024                156                  MOVE.B  #'$',(A6)+
0000117E                           157                  
0000117E                           158                  ; Store 4 hex digits that represent the word into memory
0000117E  4286                     159                  CLR.L   D6
00001180  3C04                     160                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
00001182  4EB9 000012B0            161                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
00001188  609A                     162                  BRA     main_loop           ; Store info to memory as string              
0000118A                           163  
0000118A                           164  ;------------check_10_lines----------------------------------------------------
0000118A                           165  ; -- Prompt user to hit enter when there are 10 lines of data
0000118A                           166  ; -- Then reset the line count and go back to disassemble more data
0000118A                           167  ;------------------------------------------------------------------------------
0000118A                           168  check_10_lines
0000118A  45F9 000024AE            169                  LEA     line_count,A2       ; Assign A2 pointer for line count
00001190  5212                     170                  ADD.B   #1,(A2)             ; Increment counter
00001192  0C12 0014                171                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
00001196  6700 0004                172                  BEQ     prompt_for_data     ; At 31
0000119A  4E75                     173                  RTS                         ; Return to disassemble
0000119C                           174  
0000119C  43F9 000023C5            175  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011A2  103C 000E                176                  MOVE.B  #14,D0              ; Display message
000011A6  4E4F                     177                  TRAP    #15
000011A8  43F9 000024A6            178                  LEA     hit_enter,A1        ; Take user input
000011AE  103C 0002                179                  MOVE.B  #2,D0               
000011B2  4E4F                     180                  TRAP    #15
000011B4  14BC 0000                181                  MOVE.B  #0,(A2)             ; Reset counter
000011B8  4E75                     182                  RTS                         ; Return to disassemble
000011BA                           183  
000011BA                           184  ;------------prompt_to_rerun----------------------------------------------------
000011BA                           185  ; -- Prompt user to rerun or end program
000011BA                           186  ;------------------------------------------------------------------------------
000011BA  43F9 00002395            187  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011C0  103C 000E                188                  MOVE.B  #14,D0
000011C4  4E4F                     189                  TRAP    #15
000011C6  43F9 0000249E            190                  LEA     ask_input,A1        ; Take user input
000011CC  103C 0002                191                  MOVE.B  #2,D0
000011D0  4E4F                     192                  TRAP    #15
000011D2  45F9 000024AE            193                  LEA     line_count,A2       ; Load line count to reset
000011D8  14BC 0000                194                  MOVE.B  #0,(A2)             ; Reset the line_count
000011DC  B23C 0001                195                  CMP.B   #1,D1               ; User input must be the length of 1
000011E0  6E00 0032                196                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
000011E4  6D00 002E                197                  BLT     rerun_err_msg       ; until the user inputs correctly.
000011E8  4240                     198                  CLR     D0                  ; Clear D0 for comparison
000011EA  1039 0000249E            199                  MOVE.B  ask_input,D0        ; Load user input for comparison
000011F0  B03C 004E                200                  CMP.B   #'N',D0             ; User input is N
000011F4  6700 002C                201                  BEQ     done                ; End of program if N
000011F8  B03C 006E                202                  CMP.B   #'n',D0             ; User input is n
000011FC  6700 0024                203                  BEQ     done                ; End of program if n
00001200  B03C 0059                204                  CMP.B   #'Y',D0             ; User input is Y
00001204  6700 FE1E                205                  BEQ     prompt_start        ; Run the program again
00001208  B03C 0079                206                  CMP.B   #'y',D0             ; User input is y
0000120C  6700 FE16                207                  BEQ     prompt_start        ; Run the program again
00001210  6000 0002                208                  BRA     rerun_err_msg       ; Bad input, prompt user
00001214                           209                  
00001214  43F9 00002455            210  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
0000121A  103C 000E                211                  MOVE.B  #14,D0
0000121E  4E4F                     212                  TRAP    #15
00001220  6098                     213                  BRA     prompt_to_rerun     ; Prompt user for rerun           
00001222                           214                  
00001222                           215      
00001222                           216  ;------------End-of-Program----------------------------------------------------                
00001222  43F9 00002363            217  done            LEA     ending,A1           ; Load ending message
00001228  103C 000D                218                  MOVE.B  #13,D0              ; Load task code for display
0000122C  4E4F                     219                  TRAP    #15                 ; Display ending message
0000122E  4E72 2700                220                  STOP    #$00002700          ; End of program
00001232                           221                  
00001232                           222  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
00001232  4283                     223  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001234  4285                     224                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001236  B205                     225                  CMP.B   D5,D1               ; Check input length, if lower than one
00001238  6700 004E                226                  BEQ     invalid             ; Its an invalid input
0000123C  0C41 0008                227                  CMPI    #$8,D1              ; Check input length, if higher than 8
00001240  6E00 0046                228                  BGT     invalid             ; Its an invalid input
00001244                           229                  
00001244  4282                     230  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001246  1419                     231                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001248  B405                     232                  CMP.B   D5,D2               ; Check to see if next char is null(0)
0000124A  6700 0040                233                  BEQ     return              ; Character is null, end of input
0000124E                           234                  
0000124E  B43C 0046                235                  CMP.B   #70,D2              ; Invalid character if decimal value
00001252  6E00 0034                236                  BGT     invalid             ; is higher than 70.
00001256  B43C 0040                237                  CMP.B   #64,D2              ; Is a letter if decimal value is 
0000125A  6E00 001E                238                  BGT     is_letter           ; between 65 - 70.
0000125E                           239                  
0000125E  B43C 0039                240                  CMP.B   #57,D2              ; Invalid character if decimal value is
00001262  6E00 0024                241                  BGT     invalid             ; between 58 - 64
00001266  B43C 002F                242                  CMP.B   #47,D2              ; Is a number if decimal value is 
0000126A  6E00 0006                243                  BGT     is_number           ; between 48 - 57.
0000126E  6000 0018                244                  BRA     invalid             ; Decimal values below 48 are invalid 
00001272                           245                               
00001272  0402 0030                246  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
00001276  6000 000A                247                  BRA     verified            ; Put character into a register
0000127A                           248                               
0000127A  0402 0037                249  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
0000127E  6000 0002                250                  BRA     verified            ; Put character into a register
00001282                           251                 
00001282  E983                     252  verified        ASL.L   #4,D3               ; Shift hex bit left one
00001284  D602                     253                  ADD.B   D2,D3               ; Add to verified register
00001286  60BC                     254                  BRA     check_input         ; Check the rest of the input                       
00001288                           255                  
00001288  7800                     256  invalid         MOVEQ   #0,D4               ; Invalid address
0000128A  4E75                     257                  RTS                         ; Return to start/end prompt
0000128C                           258                  
0000128C  7801                     259  return          MOVEQ   #1,D4               ; Valid address
0000128E  4E75                     260                  RTS                         ; Return to start/end prompt
00001290                           261                  
00001290                           262  ;----------------------------------------------------------
00001290                           263  ; Convert Hexidecimal to ASCII (Stores into Memory)
00001290                           264  ;
00001290                           265  ; -- At the moment, takes the Illegal data and stores 
00001290                           266  ;    it into memory so that it can be printed later
00001290                           267  ;----------------------------------------------------------
00001290  4281                     268  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
00001292  4282                     269                  CLR.L   D2                      ; Used for shifting left
00001294  4283                     270                  CLR.L   D3                      ; Counter
00001296  123C 001C                271                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
0000129A                           272  hex_ASCII_loopL
0000129A  B63C 0008                273                  CMP.B   #8,D3                   ; Done converting?
0000129E  6700 0072                274                  BEQ     done_converting         ; If equal to 8, done
000012A2  2006                     275                  MOVE.L  D6,D0                   ; Do calculations in D0
000012A4  E5A8                     276                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012A6  E2A8                     277                  LSR.L   D1,D0                   ; Isolate number
000012A8  4EB9 000012F0            278                  JSR     convert_hex
000012AE  60EA                     279                  BRA     hex_ASCII_loopL
000012B0                           280                  
000012B0  4281                     281  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012B2  4282                     282                  CLR.L   D2                      ; Used for shifting left
000012B4  4283                     283                  CLR.L   D3                      ; Counter
000012B6  123C 000C                284                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012BA                           285  hex_ASCII_loopW
000012BA  B63C 0004                286                  CMP.B   #4,D3                   ; Done converting?
000012BE  6700 0052                287                  BEQ     done_converting         ; If equal to 4, done
000012C2  2006                     288                  MOVE.L  D6,D0                   ; Do calculations in D0
000012C4  E568                     289                  LSL.W   D2,D0                   ; Eliminate stuff to the left
000012C6  E268                     290                  LSR.W   D1,D0                   ; Isolate number
000012C8  4EB9 000012F0            291                  JSR     convert_hex
000012CE  60EA                     292                  BRA     hex_ASCII_loopW
000012D0                           293  
000012D0  4281                     294  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
000012D2  4282                     295                  CLR.L   D2                      ; Used for shifting left
000012D4  4283                     296                  CLR.L   D3                      ; Counter
000012D6  123C 0004                297                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
000012DA                           298  hex_ASCII_loopB
000012DA  B63C 0002                299                  CMP.B   #2,D3                   ; Done converting?
000012DE  6700 0032                300                  BEQ     done_converting         ; If equal to 2, done
000012E2  2006                     301                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E4  E528                     302                  LSL.B   D2,D0                   ; Eliminate stuff to the left
000012E6  E228                     303                  LSR.B   D1,D0                   ; Isolate number
000012E8  4EB9 000012F0            304                  JSR     convert_hex
000012EE  60EA                     305                  BRA     hex_ASCII_loopB                  
000012F0                           306  
000012F0  B03C 000A                307  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
000012F4  6D00 0006                308                  BLT     make_number             ; Make it a number, if lower than 10
000012F8  6C00 000E                309                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
000012FC                           310                       
000012FC  0600 0030                311  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
00001300  1CC0                     312                  MOVE.B  D0,(A6)+                ; Store in memory
00001302  5203                     313                  ADD.B   #1,D3                   ; Add to counter
00001304  5802                     314                  ADD.B   #4,D2                   ; Shift left by one digit
00001306  4E75                     315                  RTS                             ; Check next number
00001308                           316                  
00001308  0600 0037                317  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
0000130C  1CC0                     318                  MOVE.B  D0,(A6)+                ; Store to memory
0000130E  5203                     319                  ADD.B   #1,D3                   ; Add to counter
00001310  5802                     320                  ADD.B   #4,D2                   ; Shift left by one digit                 
00001312  4E75                     321  done_converting RTS                             ; Check next number              
00001314                           322  
00001314                           323  ;-----------Error Messages ----------------------------------------------------
00001314  4EB9 00001328            324  start_error     JSR     load_bad_input      ; Print bad input error message
0000131A  4EF8 1024                325                  JMP     prompt_start        ; Return to prompt for start address
0000131E                           326                  
0000131E  4EB9 00001328            327  end_error       JSR     load_bad_input      ; Print bad input error message
00001324  4EF8 107A                328                  JMP     prompt_end          ; Return to prompt for end address
00001328                           329  
00001328  43F9 000023F3            330  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000132E  103C 000D                331                  MOVE.B  #13,D0              ; Load task code for display
00001332  4E4F                     332                  TRAP    #15                 ; Display bad input message
00001334  4E75                     333                  RTS                         ; Return to (start/end)_error
00001336                           334  
00001336  4282                     335  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001338  3403                     336                  MOVE.W  D3,D2               ; Put address in D2 for calulation
0000133A  7202                     337                  MOVE.L  #2,D1               ; Load 2 into D1 for division
0000133C  84C1                     338                  DIVU    D1,D2               ; Divide address by 2
0000133E  4842                     339                  SWAP    D2                  ; Swap contents of D2 to get remainder
00001340  B43C 0001                340                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001344  6700 0004                341                  BEQ     odd_err             ; Go to print out odd bound error message
00001348  4E75                     342                  RTS                         ; Return to valid_(start/end)
0000134A                           343                  
0000134A  43F9 00002429            344  odd_err         LEA     odd_input,A1        ; Load odd input message
00001350  103C 000E                345                  MOVE.B  #14,D0              ; Load task code for display
00001354  4E4F                     346                  TRAP    #15                 ; Display odd input message
00001356  4685                     347                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001358  2605                     348                  MOVE.L  D5,D3               ; Load -1 to returned data register
0000135A  4E75                     349                  RTS                         ; Return to valid_(start/end)
0000135C                           350  
0000135C                           351  OP_CODE_TREE    ; Parses the Op-Code to find what it is
0000135C                           352          
0000135C  B8BC 00004E75            353          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
00001362  6700 049C                354          Beq     OP_RTS
00001366                           355  
00001366  4EB9 00002120            356          Jsr     GET12TO15
0000136C                           357          
0000136C  B03C 0000                358          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
00001370  6700 0066                359          Beq     IMMEDIATE_BTST
00001374                           360          
00001374  B03C 0001                361          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
00001378  6700 0238                362          Beq     OP_MOVE
0000137C                           363          
0000137C  B03C 0003                364          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
00001380  6700 0230                365          Beq     OP_MOVE
00001384                           366  
00001384  B03C 0002                367          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
00001388  6700 0228                368          Beq     OP_MOVE
0000138C                           369          
0000138C  B03C 0004                370          Cmp.B     #%0100, D0       ; not enough info, Single OPs
00001390  6700 008C                371          Beq     SINGLE_OPERATOR_CODES
00001394                           372      
00001394  B03C 0006                373          Cmp.B     #%0110, D0       ; Beqnch conditionals
00001398  6700 00DE                374          Beq     BRANCH_CONDITIONALS
0000139C                           375          
0000139C  B03C 000C                376          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013A0  6700 0158                377          Beq     AND_MULS
000013A4                           378          
000013A4  B03C 000E                379          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013A8  6700 0190                380          Beq     BIT_SHIFT
000013AC                           381          
000013AC  B03C 0005                382          Cmp.B     #%0101, D0       ; Add Quick
000013B0  6700 024C                383          Beq     OP_ADDQ
000013B4                           384          
000013B4  B03C 0008                385          Cmp.B     #%1000, D0       ; Signed Divide
000013B8  6700 0280                386          Beq     OP_DIVS
000013BC                           387          
000013BC  B03C 0009                388          Cmp.B     #%1001, D0       ; Sub & SubA
000013C0  6700 02A8                389          Beq     OP_SUB
000013C4                           390          
000013C4  B03C 000B                391          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
000013C8  6700 01C6                392          Beq     CMP_EOR
000013CC                           393          
000013CC  B03C 000D                394          Cmp.B     #%1101, D0       ; Add & AddA
000013D0  6700 02D6                395          Beq     OP_ADD
000013D4                           396          
000013D4  6000 06D8                397          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
000013D8                           398          
000013D8                           399  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
000013D8                           400          
000013D8  4EB9 00002162            401          Jsr     GET6TO8         ; Change out test bits
000013DE                           402          
000013DE  B03C 0004                403          Cmp.B     #%100, D0          ; Bit test
000013E2  6700 0302                404          Beq     OP_BTST
000013E6                           405          
000013E6  4EB9 00002236            406          Jsr     GET6TO11
000013EC                           407          
000013EC  B03C 0020                408          Cmp.B   #%100000,D0     ;BTST
000013F0  6700 02F4                409          Beq     OP_BTST
000013F4                           410          
000013F4  4EB9 00002150            411          Jsr     GET9TO11        ; Change out test bits
000013FA                           412          
000013FA  B03C 0000                413          Cmp.B     #%000, D0        ; Or I
000013FE  6700 0300                414          Beq     OP_ORI
00001402                           415          
00001402  B03C 0002                416          Cmp.B     #%010, D0        ; Subtract I
00001406  6700 0314                417          Beq     OP_SUBI
0000140A                           418          
0000140A  B03C 0005                419          Cmp.B     #%101, D0        ; Exclusive or, I
0000140E  6700 032C                420          Beq     OP_EORI
00001412                           421          
00001412  B03C 0006                422          Cmp.B     #%110, D0        ; Compare I
00001416  6700 0344                423          Beq     OP_CMPI
0000141A                           424          
0000141A  6000 0692                425          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
0000141E                           426          
0000141E                           427  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
0000141E                           428  
0000141E  4EB9 00002198            429          Jsr     GETBIT8        ; Change out test bits
00001424                           430          
00001424  B03C 0001                431          Cmp.B     #%1, D0      ; Load effetive address
00001428  6700 0352                432          Beq     OP_LEA
0000142C                           433                  
0000142C  4EB9 00002150            434          Jsr     GET9TO11       ; Change out test bits        
00001432                           435  
00001432  B03C 0002                436          Cmp.B     #%010, D0    ; Negate
00001436  6700 035A                437          Beq     OP_NEG
0000143A                           438         
0000143A  B03C 0003                439          Cmp.B     #%011, D0    ; Not
0000143E  6700 036E                440          Beq     OP_NOT
00001442                           441          
00001442  B03C 0004                442          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001446  6700 0382                443          Beq     OP_MOVEM
0000144A                           444          
0000144A  B03C 0006                445          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
0000144E  6700 037A                446          Beq     OP_MOVEM
00001452                           447          
00001452  B03C 0007                448          Cmp.B     #%111, D0    ; JSR
00001456  6700 03BC                449          Beq     OP_JSR
0000145A                           450          
0000145A  6000 0652                451          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
0000145E                           452  
0000145E                           453  JSR_RTS     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
0000145E                           454  
0000145E  4EB9 00002162            455          Jsr     GET6TO8        ; Change out test bits        
00001464                           456  
00001464  B03C 0001                457          Cmp.B     #%001, D0    ; Return from subroutine
00001468  6700 0396                458          Beq     OP_RTS
0000146C                           459          
0000146C  B03C 0002                460          Cmp.B     #%010, D0    ; Jump to Subroutine
00001470  6700 03A2                461          Beq     OP_JSR
00001474                           462          
00001474  6000 0638                463          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
00001478                           464  
00001478                           465  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
00001478                           466  
00001478  4EB9 0000213E            467          Jsr     GET8TO11    ; Change out test bits        
0000147E                           468  
0000147E  B03C 0000                469          Cmp.B     #%0000, D0   ; Branch
00001482  6700 03A6                470          Beq     OP_BRANCH      
00001486                           471          
00001486  B03C 0002                472          Cmp.B     #%0010, D0   ; High
0000148A  6700 03B4                473          Beq     OP_BRA_HIGH
0000148E                           474          
0000148E  B03C 0003                475          Cmp.B     #%0011, D0   ; Low/same
00001492  6700 03C2                476          Beq     OP_BRA_LOW
00001496                           477          
00001496  B03C 0004                478          Cmp.B     #%0100, D0   ; Carry Clear
0000149A  6700 03D0                479          Beq     OP_BRA_CC
0000149E                           480          
0000149E  B03C 0005                481          Cmp.B     #%0101, D0   ; Carry Set
000014A2  6700 03DE                482          Beq     OP_BRA_CS
000014A6                           483          
000014A6  B03C 0006                484          Cmp.B     #%0110, D0   ; Not Equal
000014AA  6700 03EC                485          Beq     OP_BRA_NE
000014AE                           486          
000014AE  B03C 0007                487          Cmp.B     #%0111, D0   ; Equal
000014B2  6700 03FA                488          Beq     OP_BRA_EQ
000014B6                           489          
000014B6  B03C 0008                490          Cmp.B     #%1000, D0   ; Overflow Clear
000014BA  6700 0408                491          Beq     OP_BRA_VC
000014BE                           492          
000014BE  B03C 0009                493          Cmp.B     #%1001, D0   ; Overflow Set
000014C2  6700 0416                494          Beq     OP_BRA_VS
000014C6                           495          
000014C6  B03C 000A                496          Cmp.B     #%1010, D0   ; Plus
000014CA  6700 0424                497          Beq     OP_BRA_PL
000014CE                           498          
000014CE  B03C 000B                499          Cmp.B     #%1011, D0   ; Minus
000014D2  6700 0432                500          Beq     OP_BRA_MI
000014D6                           501          
000014D6  B03C 000C                502          Cmp.B     #%1100, D0   ; Greater than or Equal
000014DA  6700 0440                503          Beq     OP_BRA_GE
000014DE                           504          
000014DE  B03C 000D                505          Cmp.B     #%1101, D0   ; Less Than
000014E2  6700 044E                506          Beq     OP_BRA_LT
000014E6                           507          
000014E6  B03C 000E                508          Cmp.B     #%1110, D0   ; Greater Than
000014EA  6700 045C                509          Beq     OP_BRA_GT
000014EE                           510          
000014EE  B03C 000F                511          Cmp.B     #%1111, D0   ; Less than or Equal
000014F2  6700 046A                512          Beq     OP_BRA_LE
000014F6                           513          
000014F6  6000 05B6                514          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
000014FA                           515  
000014FA                           516  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
000014FA                           517  
000014FA  4EB9 00002224            518          Jsr     Get3TO8
00001500                           519          
00001500  B03C 0021                520          Cmp.B     #%100001, D0   ; ABCD
00001504  6700 05A8                521          Beq     OP_SET_BAD_BUFFER        
00001508  B03C 0020                522          Cmp.B     #%100000,D0    ; ABCD
0000150C  6700 05A0                523          Beq     OP_SET_BAD_BUFFER        
00001510  B03C 0028                524          Cmp.B     #%101000,D0    ; EXG
00001514  6700 0598                525          Beq     OP_SET_BAD_BUFFER
00001518  B03C 0029                526          Cmp.B     #%101001,D0    ; EXG
0000151C  6700 0590                527          Beq     OP_SET_BAD_BUFFER
00001520  B03C 0031                528          Cmp.B     #%110001,D0    ; EXG
00001524  6700 FC32                529          Beq     ILLEGAL        
00001528                           530  
00001528  4EB9 00002162            531          Jsr     GET6TO8        ; Change out test bits        
0000152E                           532  
0000152E  B03C 0007                533          Cmp.B     #%111, D0    ; Multiply signed
00001532  6700 0440                534          Beq     OP_MULS
00001536                           535          
00001536  6000 045E                536          Bra     OP_AND      ; Probably AND, check more in OP_AND
0000153A                           537          
0000153A                           538  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
0000153A                           539          
0000153A                           540          ; Determine if the shift is Register or Memory shifting
0000153A                           541          
0000153A  4EB9 000021BC            542          Jsr     GET6AND7
00001540                           543          
00001540  B03C 0003                544          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
00001544  6700 0006                545          Beq     BIT_SHIFT_MEM
00001548                           546  
00001548  6000 0024                547          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
0000154C                           548  
0000154C                           549  BIT_SHIFT_MEM
0000154C                           550          
0000154C  4EB9 000021AA            551          Jsr     GET9AND10         ; Change out test bits
00001552                           552          
00001552  B03C 0000                553          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001556  6700 0478                554          Beq     OP_AS_MEM
0000155A                           555          
0000155A  B03C 0001                556          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
0000155E  6700 04A6                557          Beq     OP_LS_MEM
00001562                           558          
00001562  B03C 0003                559          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001566  6700 04D4                560          Beq     OP_RO_MEM
0000156A                           561          
0000156A  6000 0542                562          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
0000156E                           563  
0000156E                           564  BIT_SHIFT_REG
0000156E                           565          
0000156E  4EB9 000021CE            566          Jsr     GET3AND4        ; Change out test bits
00001574                           567          
00001574  B03C 0000                568          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001578  6700 0438                569          Beq     OP_AS_REG
0000157C                           570          
0000157C  B03C 0001                571          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001580  6700 0466                572          Beq     OP_LS_REG
00001584                           573          
00001584  B03C 0003                574          Cmp.B     #%11, D0        ; Rotate (Left or Right)
00001588  6700 0494                575          Beq     OP_RO_REG
0000158C                           576          
0000158C  6000 0520                577          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
00001590                           578  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
00001590                           579          
00001590  4EB9 00002162            580          Jsr     GET6TO8         ; Change out test bits
00001596                           581          
00001596  B03C 0004                582          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
0000159A  6700 04F6                583          Beq     OP_EOR
0000159E                           584          
0000159E  B03C 0005                585          Cmp.B     #%101,D0
000015A2  6700 04EE                586          Beq     OP_EOR
000015A6                           587          
000015A6  B03C 0006                588          Cmp.B     #%110,D0
000015AA  6700 04E6                589          Beq     OP_EOR
000015AE                           590          
000015AE                           591          
000015AE  6000 04A4                592          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015B2                           593  
000015B2                           594  ;---------------------OP_CODE Functions---------------------;
000015B2                           595  ; These Functions have all determined what Op-code or group
000015B2                           596  ; of op-codes I have. The next goal is to Add to the string
000015B2                           597  ; and call the accompying EA function to get the rest of the
000015B2                           598  ; String
000015B2                           599  
000015B2                           600  ; REGISTERS USED: D0, D4 (const), A6
000015B2                           601  
000015B2                           602  ;-----------------------  MOVE  -----------------------------;
000015B2                           603  OP_MOVE
000015B2                           604      ; start string
000015B2                           605      
000015B2  1CFC 004D                606          Move.B  #'M', (A6)+
000015B6  1CFC 004F                607          Move.B  #'O', (A6)+
000015BA  1CFC 0056                608          Move.B  #'V', (A6)+
000015BE  1CFC 0045                609          Move.B  #'E', (A6)+
000015C2                           610      
000015C2                           611      ; is it an address move?
000015C2  4EB9 00002162            612          Jsr     GET6TO8     ; Get the mode
000015C8  4EB9 00001AC8            613          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
000015CE                           614          
000015CE                           615      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
000015CE                           616      ; But move does not use the Op-mode bits, so i'll do it manually
000015CE                           617      
000015CE  4EB9 00002120            618          Jsr     GET12TO15
000015D4                           619  
000015D4                           620          ; Jump to a sub routine to get the data, so it returns back correctly
000015D4  4EB9 000015E4            621          Jsr     OP_MOVE_DATA
000015DA                           622          
000015DA                           623          ; Put in tabs
000015DA  4EB9 00001AB4            624          Jsr     OP_TAB
000015E0                           625          
000015E0                           626          ; Hand the function off to John
000015E0  6000 0564                627          BRA     EA_MOVE        
000015E4                           628  
000015E4                           629  OP_MOVE_DATA
000015E4                           630          
000015E4  B07C 0001                631          Cmp     #%0001, D0
000015E8  6700 0520                632          Beq     OP_SET_DATA_BYTE
000015EC                           633          
000015EC  B07C 0002                634          Cmp     #%0010, D0
000015F0  6700 052C                635          Beq     OP_SET_DATA_LONG
000015F4                           636          
000015F4  B07C 0003                637          Cmp     #%0011, D0
000015F8  6700 051A                638          Beq     OP_SET_DATA_WORD
000015FC                           639          
000015FC  4E75                     640          Rts
000015FE                           641  
000015FE                           642  ;-----------------------  ADDQ  -----------------------------;
000015FE                           643          
000015FE                           644  OP_ADDQ
000015FE                           645      ; Check fringe cases
000015FE  4EB9 00002198            646          Jsr     GETBIT8
00001604  B03C 0001                647          Cmp.B   #%1,D0
00001608  6700 04A4                648          Beq     OP_SET_BAD_BUFFER        
0000160C  4EB9 000021BC            649          Jsr     GET6AND7
00001612  B03C 0003                650          Cmp.B   #%11,D0
00001616  6700 0496                651          Beq     OP_SET_BAD_BUFFER       ; Blong edited, was Bne
0000161A                           652  
0000161A                           653      ; start string
0000161A                           654      
0000161A  1CFC 0041                655          Move.B  #'A', (A6)+
0000161E  1CFC 0044                656          Move.B  #'D', (A6)+
00001622  1CFC 0044                657          Move.B  #'D', (A6)+
00001626  1CFC 0051                658          Move.B  #'Q', (A6)+
0000162A                           659          
0000162A                           660      ; Check data type        
0000162A  4EB9 00001AD8            661          Jsr     OP_CHECK_DATA_SIZE
00001630                           662          
00001630                           663      ; Put in tabs
00001630  4EB9 00001AB4            664          Jsr     OP_TAB
00001636                           665          
00001636                           666      ; Hand the function off to John / Blong edited, was EA_IMMEDIATE
00001636  6000 080E                667          BRA     EA_ADDQ
0000163A                           668  
0000163A                           669      
0000163A                           670  ;------------------  DIVIDE SINGED  -------------------------;
0000163A                           671      
0000163A                           672  OP_DIVS
0000163A                           673      ; One last check to make sure I have the right stuff
0000163A                           674      
0000163A  4EB9 00002162            675          Jsr     GET6TO8
00001640  B07C 0007                676          Cmp     #%111,D0
00001644  6600 0468                677          Bne     OP_SET_BAD_BUFFER
00001648                           678          
00001648                           679      ; start string
00001648                           680      
00001648  1CFC 0044                681          Move.B  #'D', (A6)+
0000164C  1CFC 0049                682          Move.B  #'I', (A6)+
00001650  1CFC 0056                683          Move.B  #'V', (A6)+
00001654  1CFC 0053                684          Move.B  #'S', (A6)+
00001658  1CFC 002E                685          Move.B  #'.', (A6)+
0000165C  1CFC 0057                686          Move.B  #'W', (A6)+
00001660                           687          
00001660                           688      ; Put in tabs
00001660  4EB9 00001AB4            689          Jsr     OP_TAB    
00001666                           690      
00001666                           691      ; Handoff to John
00001666                           692          
00001666  6000 091E                693          BRA     EA_DIVS
0000166A                           694  
0000166A                           695      
0000166A                           696  ;-----------------------  SUB  ------------------------------;    
0000166A                           697      
0000166A                           698  OP_SUB
0000166A                           699      ; start string
0000166A                           700      
0000166A  1CFC 0053                701          Move.B  #'S', (A6)+
0000166E  1CFC 0055                702          Move.B  #'U', (A6)+
00001672  1CFC 0042                703          Move.B  #'B', (A6)+
00001676                           704  
00001676                           705  
00001676                           706       ; Check for address version
00001676                           707          
00001676  4EB9 000021BC            708          Jsr     GET6AND7
0000167C  B03C 0003                709          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001680                           710          
00001680  6700 0012                711          Beq     OP_SUB_ADDR
00001684                           712  
00001684                           713          ; Don't need to worry about ADDA in V1
00001684                           714          ; Check data size
00001684  4EB9 00001AD8            715          Jsr     OP_CHECK_DATA_SIZE
0000168A                           716          
0000168A                           717          ; Put in tabs
0000168A  4EB9 00001AB4            718          Jsr     OP_TAB
00001690                           719          
00001690  6000 07F2                720          BRA     EA_SUB 
00001694                           721          
00001694                           722  OP_SUB_ADDR
00001694                           723          
00001694  1CFC 0041                724          Move.B  #'A',(A6)+ ; add to the string
00001698                           725          
00001698                           726          ; Find data size
00001698                           727          
00001698  4EB9 00001AF8            728          Jsr     OP_CHECK_DATA_SIZE_ADDR
0000169E                           729          
0000169E                           730          ; Put in tabs
0000169E  4EB9 00001AB4            731          Jsr     OP_TAB
000016A4                           732          
000016A4                           733          ; Handoff
000016A4  6000 07DE                734          BRA     EA_SUB
000016A8                           735          
000016A8                           736  ;-----------------------  ADD  ------------------------------;
000016A8                           737  
000016A8                           738  OP_ADD
000016A8                           739      ; start string
000016A8                           740      
000016A8  1CFC 0041                741          Move.B  #'A', (A6)+
000016AC  1CFC 0044                742          Move.B  #'D', (A6)+
000016B0  1CFC 0044                743          Move.B  #'D', (A6)+
000016B4                           744  
000016B4                           745      ; Check for address version
000016B4                           746          
000016B4  4EB9 000021BC            747          Jsr     GET6AND7
000016BA  B03C 0003                748          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016BE                           749          
000016BE  6700 0012                750          Beq     OP_ADD_ADDR
000016C2                           751          
000016C2                           752          ; Don't need to worry about ADDA in V1
000016C2                           753          ; Check data size
000016C2  4EB9 00001AD8            754          Jsr     OP_CHECK_DATA_SIZE
000016C8                           755          
000016C8                           756          ; Put in tabs
000016C8  4EB9 00001AB4            757          Jsr     OP_TAB
000016CE                           758          
000016CE  6000 06BA                759          BRA     EA_ADD
000016D2                           760          
000016D2                           761  OP_ADD_ADDR
000016D2                           762          
000016D2  1CFC 0041                763          Move.B  #'A',(A6)+ ; add to the string
000016D6                           764          
000016D6                           765          ; Find data size
000016D6                           766          
000016D6  4EB9 00001AF8            767          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016DC                           768          
000016DC                           769          ; Put in tabs
000016DC  4EB9 00001AB4            770          Jsr     OP_TAB
000016E2                           771          
000016E2                           772          ; Handoff
000016E2  6000 06DA                773          BRA     EA_ADDA
000016E6                           774  
000016E6                           775  ;------------------------  BTST -----------------------------;
000016E6                           776  
000016E6                           777  OP_BTST
000016E6                           778      ; start string
000016E6                           779      
000016E6  1CFC 0042                780          Move.B  #'B', (A6)+
000016EA  1CFC 0054                781          Move.B  #'T', (A6)+
000016EE  1CFC 0053                782          Move.B  #'S', (A6)+
000016F2  1CFC 0054                783          Move.B  #'T', (A6)+
000016F6                           784          
000016F6                           785      ; Btst has data sizes, but they are implicit based on mode
000016F6                           786          
000016F6                           787      ; Put in tabs
000016F6  4EB9 00001AB4            788          Jsr     OP_TAB
000016FC                           789          
000016FC                           790      ; Hand the function off to John
000016FC  6000 088C                791          BRA     EA_BTST
00001700                           792  
00001700                           793  
00001700                           794  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
00001700                           795  
00001700                           796  ;------------------------  ORI  -----------------------------;
00001700                           797      
00001700                           798  OP_ORI
00001700                           799      ; start string
00001700                           800      
00001700  1CFC 004F                801          Move.B  #'O', (A6)+
00001704  1CFC 0052                802          Move.B  #'R', (A6)+
00001708  1CFC 0049                803          Move.B  #'I', (A6)+
0000170C                           804          
0000170C                           805      ; Check data type        
0000170C  4EB9 00001AD8            806          Jsr     OP_CHECK_DATA_SIZE
00001712                           807          
00001712                           808      ; Put in tabs
00001712  4EB9 00001AB4            809          Jsr     OP_TAB
00001718                           810          
00001718                           811      ; Hand the function off to John
00001718  6000 080C                812          BRA     EA_IMMEDIATE
0000171C                           813  
0000171C                           814  ;-----------------------  SUBI  -----------------------------;
0000171C                           815  
0000171C                           816  OP_SUBI
0000171C                           817      ; start string
0000171C                           818      
0000171C  1CFC 0053                819          Move.B  #'S', (A6)+
00001720  1CFC 0055                820          Move.B  #'U', (A6)+
00001724  1CFC 0042                821          Move.B  #'B', (A6)+
00001728  1CFC 0049                822          Move.B  #'I', (A6)+
0000172C                           823          
0000172C                           824      ; Check data type        
0000172C  4EB9 00001AD8            825          Jsr     OP_CHECK_DATA_SIZE
00001732                           826          
00001732                           827      ; Put in tabs
00001732  4EB9 00001AB4            828          Jsr     OP_TAB
00001738                           829          
00001738                           830      ; Hand the function off to John
00001738  6000 07EC                831          BRA     EA_IMMEDIATE  
0000173C                           832          
0000173C                           833  ;-----------------------  EORI  -----------------------------;        
0000173C                           834          
0000173C                           835  OP_EORI
0000173C                           836      ; start string
0000173C                           837      
0000173C  1CFC 0045                838          Move.B  #'E', (A6)+
00001740  1CFC 004F                839          Move.B  #'O', (A6)+
00001744  1CFC 0052                840          Move.B  #'R', (A6)+
00001748  1CFC 0049                841          Move.B  #'I', (A6)+
0000174C                           842          
0000174C                           843      ; Check data type        
0000174C  4EB9 00001AD8            844          Jsr     OP_CHECK_DATA_SIZE
00001752                           845          
00001752                           846      ; Put in tabs
00001752  4EB9 00001AB4            847          Jsr     OP_TAB
00001758                           848          
00001758                           849      ; Hand the function off to John
00001758  6000 07CC                850          BRA     EA_IMMEDIATE  
0000175C                           851          
0000175C                           852  ;-----------------------  CMPI  -----------------------------;        
0000175C                           853          
0000175C                           854  OP_CMPI
0000175C                           855      ; start string
0000175C                           856      
0000175C  1CFC 0043                857          Move.B  #'C', (A6)+
00001760  1CFC 004D                858          Move.B  #'M', (A6)+
00001764  1CFC 0050                859          Move.B  #'P', (A6)+
00001768  1CFC 0049                860          Move.B  #'I', (A6)+
0000176C                           861          
0000176C                           862      ; Check data type        
0000176C  4EB9 00001AD8            863          Jsr     OP_CHECK_DATA_SIZE
00001772                           864          
00001772                           865      ; Put in tabs
00001772  4EB9 00001AB4            866          Jsr     OP_TAB
00001778                           867          
00001778                           868      ; Hand the function off to John
00001778  6000 07AC                869          BRA     EA_IMMEDIATE  
0000177C                           870          
0000177C                           871  ;-----------------------  LEA  ------------------------------;
0000177C                           872  
0000177C                           873  OP_LEA
0000177C                           874      ; start string
0000177C                           875      
0000177C  1CFC 004C                876          Move.B  #'L', (A6)+
00001780  1CFC 0045                877          Move.B  #'E', (A6)+
00001784  1CFC 0041                878          Move.B  #'A', (A6)+
00001788                           879          
00001788                           880      ; No data size for LEA
00001788                           881          
00001788                           882      ; Put in tabs
00001788  4EB9 00001AB4            883          Jsr     OP_TAB
0000178E                           884          
0000178E                           885      ; Hand the function off to John
0000178E  6000 06FC                886          BRA     EA_LEA  
00001792                           887  
00001792                           888  ;-----------------------  NEG  ------------------------------;
00001792                           889  
00001792                           890  OP_NEG
00001792                           891      ; start string
00001792                           892      
00001792  1CFC 004E                893          Move.B  #'N', (A6)+
00001796  1CFC 0045                894          Move.B  #'E', (A6)+
0000179A  1CFC 0047                895          Move.B  #'G', (A6)+
0000179E                           896          
0000179E                           897      ; Data size
0000179E  4EB9 00001AD8            898          Jsr     OP_CHECK_DATA_SIZE
000017A4                           899          
000017A4                           900      ; Put in tabs
000017A4  4EB9 00001AB4            901          Jsr     OP_TAB
000017AA                           902          
000017AA                           903      ; Hand the function off to John
000017AA  6000 06EC                904          BRA     EA_NEG  
000017AE                           905  
000017AE                           906      
000017AE                           907  ;-----------------------  NOT  ------------------------------;    
000017AE                           908      
000017AE                           909  OP_NOT
000017AE                           910      ; start string
000017AE                           911      
000017AE  1CFC 004E                912          Move.B  #'N', (A6)+
000017B2  1CFC 004F                913          Move.B  #'O', (A6)+
000017B6  1CFC 0054                914          Move.B  #'T', (A6)+
000017BA                           915          
000017BA                           916      ; Data size
000017BA  4EB9 00001AD8            917          Jsr     OP_CHECK_DATA_SIZE
000017C0                           918          
000017C0                           919      ; Put in tabs
000017C0  4EB9 00001AB4            920          Jsr     OP_TAB
000017C6                           921          
000017C6                           922      ; Hand the function off to John
000017C6  6000 06D8                923          BRA     EA_NOT
000017CA                           924  
000017CA                           925  ;-------------------  MOVE MULITPLE  ------------------------;
000017CA                           926          
000017CA                           927  OP_MOVEM
000017CA                           928      ; start string
000017CA                           929      
000017CA  1CFC 004D                930          Move.B  #'M', (A6)+
000017CE  1CFC 004F                931          Move.B  #'O', (A6)+
000017D2  1CFC 0056                932          Move.B  #'V', (A6)+
000017D6  1CFC 0045                933          Move.B  #'E', (A6)+
000017DA  1CFC 004D                934          Move.B  #'M', (A6)+        
000017DE                           935  
000017DE                           936      ; Data size has to be checked manually
000017DE  4EB9 000017EE            937          Jsr     OP_MOVEM_DATA
000017E4                           938          
000017E4                           939      ; Put in tabs
000017E4  4EB9 00001AB4            940          Jsr     OP_TAB
000017EA                           941          
000017EA                           942      ; Hand the function off to John
000017EA  6000 03E4                943          BRA     EA_MOVEM
000017EE                           944          
000017EE                           945  OP_MOVEM_DATA
000017EE                           946      ; get the size bit
000017EE  4EB9 000021BC            947          Jsr     GET6AND7
000017F4                           948          
000017F4  B03C 0002                949          Cmp.B   #%10,D0
000017F8  6700 031A                950          Beq     OP_SET_DATA_WORD
000017FC                           951          
000017FC  6000 0320                952          Bra     OP_SET_DATA_LONG   
00001800                           953  
00001800                           954  OP_RTS
00001800                           955      ; start string
00001800                           956      
00001800  1CFC 0052                957          Move.B  #'R', (A6)+
00001804  1CFC 0054                958          Move.B  #'T', (A6)+
00001808  1CFC 0053                959          Move.B  #'S', (A6)+
0000180C                           960  
0000180C                           961      ; Put in tabs
0000180C  4EB9 00001AB4            962          Jsr     OP_TAB
00001812                           963  
00001812                           964      ; Handoff to Blong
00001812                           965      
00001812  4E75                     966          Rts
00001814                           967          
00001814                           968  ;-----------------------  JSR  ------------------------------;        
00001814                           969          
00001814                           970  OP_JSR
00001814                           971      ; start string
00001814                           972      
00001814  1CFC 004A                973          Move.B  #'J', (A6)+
00001818  1CFC 0053                974          Move.B  #'S', (A6)+
0000181C  1CFC 0052                975          Move.B  #'R', (A6)+
00001820                           976          
00001820                           977      ; No data size
00001820                           978          
00001820                           979      ; Put in tabs
00001820  4EB9 00001AB4            980          Jsr     OP_TAB
00001826                           981          
00001826                           982      ; Hand the function off to John
00001826  6000 067C                983          BRA     EA_JSR
0000182A                           984  
0000182A                           985  ;------------------  BRANCH CONDITIONALS  ------------------------;
0000182A                           986  
0000182A                           987  OP_BRANCH
0000182A                           988      ; start string
0000182A                           989      
0000182A  1CFC 0042                990          Move.B  #'B', (A6)+
0000182E  1CFC 0052                991          Move.B  #'R', (A6)+
00001832  1CFC 0041                992          Move.B  #'A', (A6)+
00001836                           993  
00001836                           994      ; Put in tabs
00001836  4EB9 00001AB4            995          Jsr     OP_TAB
0000183C                           996  
0000183C                           997      ; Handoff to John
0000183C                           998      
0000183C  6000 0796                999          BRA     EA_BRANCH
00001840                          1000      
00001840                          1001  OP_BRA_HIGH
00001840                          1002      ; start string
00001840                          1003      
00001840  1CFC 0042               1004          Move.B  #'B', (A6)+
00001844  1CFC 0048               1005          Move.B  #'H', (A6)+
00001848  1CFC 0049               1006          Move.B  #'I', (A6)+
0000184C                          1007  
0000184C                          1008      ; Put in tabs
0000184C  4EB9 00001AB4           1009          Jsr     OP_TAB
00001852                          1010  
00001852                          1011      ; Handoff to John
00001852                          1012      
00001852  6000 0780               1013          BRA     EA_BRANCH
00001856                          1014      
00001856                          1015  OP_BRA_LOW
00001856                          1016      ; start string
00001856                          1017      
00001856  1CFC 0042               1018          Move.B  #'B', (A6)+
0000185A  1CFC 004C               1019          Move.B  #'L', (A6)+
0000185E  1CFC 0053               1020          Move.B  #'S', (A6)+
00001862                          1021  
00001862                          1022      ; Put in tabs
00001862  4EB9 00001AB4           1023          Jsr     OP_TAB
00001868                          1024  
00001868                          1025      ; Handoff to John
00001868                          1026      
00001868  6000 076A               1027          BRA     EA_BRANCH
0000186C                          1028      
0000186C                          1029  OP_BRA_CC
0000186C                          1030      ; start string
0000186C                          1031      
0000186C  1CFC 0042               1032          Move.B  #'B', (A6)+
00001870  1CFC 0043               1033          Move.B  #'C', (A6)+
00001874  1CFC 0043               1034          Move.B  #'C', (A6)+
00001878                          1035  
00001878                          1036      ; Put in tabs
00001878  4EB9 00001AB4           1037          Jsr     OP_TAB
0000187E                          1038  
0000187E                          1039      ; Handoff to John
0000187E                          1040      
0000187E  6000 0754               1041          BRA     EA_BRANCH
00001882                          1042  
00001882                          1043  OP_BRA_CS
00001882                          1044      ; start string
00001882                          1045      
00001882  1CFC 0042               1046          Move.B  #'B', (A6)+
00001886  1CFC 0043               1047          Move.B  #'C', (A6)+
0000188A  1CFC 0053               1048          Move.B  #'S', (A6)+
0000188E                          1049  
0000188E                          1050      ; Put in tabs
0000188E  4EB9 00001AB4           1051          Jsr     OP_TAB
00001894                          1052  
00001894                          1053      ; Handoff to John
00001894                          1054      
00001894  6000 073E               1055          BRA     EA_BRANCH
00001898                          1056  
00001898                          1057  OP_BRA_NE
00001898                          1058      ; start string
00001898                          1059      
00001898  1CFC 0042               1060          Move.B  #'B', (A6)+
0000189C  1CFC 004E               1061          Move.B  #'N', (A6)+
000018A0  1CFC 0045               1062          Move.B  #'E', (A6)+
000018A4                          1063  
000018A4                          1064      ; Put in tabs
000018A4  4EB9 00001AB4           1065          Jsr     OP_TAB
000018AA                          1066  
000018AA                          1067      ; Handoff to John
000018AA                          1068      
000018AA  6000 0728               1069          BRA     EA_BRANCH
000018AE                          1070  
000018AE                          1071  OP_BRA_EQ
000018AE                          1072      ; start string
000018AE                          1073      
000018AE  1CFC 0042               1074          Move.B  #'B', (A6)+
000018B2  1CFC 0045               1075          Move.B  #'E', (A6)+
000018B6  1CFC 0051               1076          Move.B  #'Q', (A6)+
000018BA                          1077  
000018BA                          1078      ; Put in tabs
000018BA  4EB9 00001AB4           1079          Jsr     OP_TAB
000018C0                          1080  
000018C0                          1081      ; Handoff to John
000018C0                          1082      
000018C0  6000 0712               1083          BRA     EA_BRANCH
000018C4                          1084  
000018C4                          1085  OP_BRA_VC
000018C4                          1086      ; start string
000018C4                          1087      
000018C4  1CFC 0042               1088          Move.B  #'B', (A6)+
000018C8  1CFC 0056               1089          Move.B  #'V', (A6)+
000018CC  1CFC 0043               1090          Move.B  #'C', (A6)+
000018D0                          1091  
000018D0                          1092      ; Put in tabs
000018D0  4EB9 00001AB4           1093          Jsr     OP_TAB
000018D6                          1094  
000018D6                          1095      ; Handoff to John
000018D6                          1096      
000018D6  6000 06FC               1097          BRA     EA_BRANCH
000018DA                          1098  
000018DA                          1099  OP_BRA_VS
000018DA                          1100      ; start string
000018DA                          1101      
000018DA  1CFC 0042               1102          Move.B  #'B', (A6)+
000018DE  1CFC 0056               1103          Move.B  #'V', (A6)+
000018E2  1CFC 0053               1104          Move.B  #'S', (A6)+
000018E6                          1105  
000018E6                          1106      ; Put in tabs
000018E6  4EB9 00001AB4           1107          Jsr     OP_TAB
000018EC                          1108  
000018EC                          1109      ; Handoff to John
000018EC                          1110      
000018EC  6000 06E6               1111          BRA     EA_BRANCH
000018F0                          1112  
000018F0                          1113  OP_BRA_PL
000018F0                          1114      ; start string
000018F0                          1115      
000018F0  1CFC 0042               1116          Move.B  #'B', (A6)+
000018F4  1CFC 0050               1117          Move.B  #'P', (A6)+
000018F8  1CFC 004C               1118          Move.B  #'L', (A6)+
000018FC                          1119  
000018FC                          1120      ; Put in tabs
000018FC  4EB9 00001AB4           1121          Jsr     OP_TAB
00001902                          1122  
00001902                          1123      ; Handoff to John
00001902                          1124      
00001902  6000 06D0               1125          BRA     EA_BRANCH
00001906                          1126  
00001906                          1127  OP_BRA_MI
00001906                          1128      ; start string
00001906                          1129      
00001906  1CFC 0042               1130          Move.B  #'B', (A6)+
0000190A  1CFC 004D               1131          Move.B  #'M', (A6)+
0000190E  1CFC 0049               1132          Move.B  #'I', (A6)+
00001912                          1133  
00001912                          1134      ; Put in tabs
00001912  4EB9 00001AB4           1135          Jsr     OP_TAB
00001918                          1136  
00001918                          1137      ; Handoff to John
00001918                          1138      
00001918  6000 06BA               1139          BRA     EA_BRANCH
0000191C                          1140  
0000191C                          1141  OP_BRA_GE
0000191C                          1142      ; start string
0000191C                          1143      
0000191C  1CFC 0042               1144          Move.B  #'B', (A6)+
00001920  1CFC 0047               1145          Move.B  #'G', (A6)+
00001924  1CFC 0045               1146          Move.B  #'E', (A6)+
00001928                          1147  
00001928                          1148      ; Put in tabs
00001928  4EB9 00001AB4           1149          Jsr     OP_TAB
0000192E                          1150  
0000192E                          1151      ; Handoff to John
0000192E                          1152      
0000192E  6000 06A4               1153          BRA     EA_BRANCH
00001932                          1154  
00001932                          1155  OP_BRA_LT
00001932                          1156      ; start string
00001932                          1157      
00001932  1CFC 0042               1158          Move.B  #'B', (A6)+
00001936  1CFC 004C               1159          Move.B  #'L', (A6)+
0000193A  1CFC 0054               1160          Move.B  #'T', (A6)+
0000193E                          1161  
0000193E                          1162      ; Put in tabs
0000193E  4EB9 00001AB4           1163          Jsr     OP_TAB
00001944                          1164  
00001944                          1165      ; Handoff to John
00001944                          1166      
00001944  6000 068E               1167          BRA     EA_BRANCH
00001948                          1168  
00001948                          1169  OP_BRA_GT
00001948                          1170      ; start string
00001948                          1171      
00001948  1CFC 0042               1172          Move.B  #'B', (A6)+
0000194C  1CFC 0047               1173          Move.B  #'G', (A6)+
00001950  1CFC 0054               1174          Move.B  #'T', (A6)+
00001954                          1175  
00001954                          1176      ; Put in tabs
00001954  4EB9 00001AB4           1177          Jsr     OP_TAB
0000195A                          1178  
0000195A                          1179      ; Handoff to John
0000195A                          1180      
0000195A  6000 0678               1181          BRA     EA_BRANCH
0000195E                          1182  
0000195E                          1183  OP_BRA_LE
0000195E                          1184      ; start string
0000195E                          1185      
0000195E  1CFC 0042               1186          Move.B  #'B', (A6)+
00001962  1CFC 004C               1187          Move.B  #'L', (A6)+
00001966  1CFC 0045               1188          Move.B  #'E', (A6)+
0000196A                          1189  
0000196A                          1190      ; Put in tabs
0000196A  4EB9 00001AB4           1191          Jsr     OP_TAB
00001970                          1192  
00001970                          1193      ; Handoff to John
00001970                          1194      
00001970  6000 0662               1195          BRA     EA_BRANCH
00001974                          1196  
00001974                          1197  ;------------------  Multiply Singed ----------------------;    
00001974                          1198  
00001974                          1199  OP_MULS
00001974                          1200      ; MULS only has one format, and that data size of word, so I don't need
00001974                          1201      ; a very intelligent system
00001974                          1202      
00001974  1CFC 004D               1203          Move.B  #'M', (A6)+
00001978  1CFC 0055               1204          Move.B  #'U', (A6)+
0000197C  1CFC 004C               1205          Move.B  #'L', (A6)+
00001980  1CFC 0053               1206          Move.B  #'S', (A6)+
00001984  1CFC 002E               1207          Move.B  #'.', (A6)+
00001988  1CFC 0057               1208          Move.B  #'W', (A6)+
0000198C                          1209  
0000198C                          1210      ; Put in tabs
0000198C  4EB9 00001AB4           1211          Jsr     OP_TAB       
00001992                          1212      
00001992                          1213      ; Give to john
00001992                          1214      
00001992  6000 05CA               1215          BRA     EA_MULS
00001996                          1216  
00001996                          1217      
00001996                          1218  ;-----------------------  AND  ------------------------------;    
00001996                          1219      
00001996                          1220  OP_AND
00001996                          1221      ; start string
00001996                          1222      
00001996  1CFC 0041               1223          Move.B  #'A', (A6)+
0000199A  1CFC 004E               1224          Move.B  #'N', (A6)+
0000199E  1CFC 0044               1225          Move.B  #'D', (A6)+
000019A2                          1226  
000019A2                          1227      ; No Address Version
000019A2                          1228          
000019A2                          1229      ; Check data size
000019A2  4EB9 00001AD8           1230          Jsr     OP_CHECK_DATA_SIZE
000019A8                          1231          
000019A8                          1232      ; Put in tabs
000019A8  4EB9 00001AB4           1233          Jsr     OP_TAB
000019AE                          1234          
000019AE  6000 04E0               1235      BRA     EA_AND
000019B2                          1236  
000019B2                          1237      
000019B2                          1238  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
000019B2                          1239          
000019B2                          1240  OP_AS_REG
000019B2                          1241      ; start string
000019B2                          1242      
000019B2  1CFC 0041               1243          Move.B  #'A', (A6)+
000019B6  1CFC 0053               1244          Move.B  #'S', (A6)+
000019BA                          1245          
000019BA                          1246      ; Determine Left or right shift
000019BA                          1247      
000019BA  4EB9 00001B28           1248          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019C0                          1249          
000019C0                          1250      ; Determine data size
000019C0                          1251      
000019C0  4EB9 00001AD8           1252          Jsr     OP_CHECK_DATA_SIZE
000019C6                          1253         
000019C6                          1254      ; Tab out function
000019C6                          1255      
000019C6  4EB9 00001AB4           1256          Jsr     OP_TAB
000019CC                          1257         
000019CC                          1258      ; Handoff function
000019CC  6000 04DA               1259          BRA     EA_BIT_SHIFT
000019D0                          1260          
000019D0                          1261  OP_AS_MEM
000019D0                          1262      
000019D0                          1263      ; start string
000019D0                          1264      
000019D0  1CFC 0041               1265          Move.B  #'A', (A6)+
000019D4  1CFC 0053               1266          Move.B  #'S', (A6)+
000019D8                          1267          
000019D8                          1268      ; Determine Left or right shift
000019D8                          1269      
000019D8  4EB9 00001B28           1270          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019DE                          1271         
000019DE                          1272      ; Tab out function
000019DE                          1273      
000019DE  4EB9 00001AB4           1274          Jsr     OP_TAB
000019E4                          1275         
000019E4                          1276      ; Handoff function
000019E4  6000 04C2               1277          BRA     EA_BIT_SHIFT
000019E8                          1278  
000019E8                          1279  
000019E8                          1280  ;-------------------  LOGICAL SHIFT  ------------------------;
000019E8                          1281  
000019E8                          1282  OP_LS_REG
000019E8                          1283      ; start string
000019E8                          1284      
000019E8  1CFC 004C               1285          Move.B  #'L', (A6)+
000019EC  1CFC 0053               1286          Move.B  #'S', (A6)+
000019F0                          1287          
000019F0                          1288      ; Determine Left or right shift
000019F0                          1289      
000019F0  4EB9 00001B28           1290          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
000019F6                          1291          
000019F6                          1292      ; Determine data size
000019F6                          1293      
000019F6  4EB9 00001AD8           1294          Jsr     OP_CHECK_DATA_SIZE
000019FC                          1295         
000019FC                          1296      ; Tab out function
000019FC                          1297      
000019FC  4EB9 00001AB4           1298          Jsr     OP_TAB
00001A02                          1299         
00001A02                          1300      ; Handoff function
00001A02  6000 04A4               1301          BRA     EA_BIT_SHIFT
00001A06                          1302  
00001A06                          1303      
00001A06                          1304  OP_LS_MEM    
00001A06                          1305  
00001A06                          1306      ; start string
00001A06                          1307      
00001A06  1CFC 004C               1308          Move.B  #'L', (A6)+
00001A0A  1CFC 0053               1309          Move.B  #'S', (A6)+
00001A0E                          1310          
00001A0E                          1311      ; Determine Left or right shift
00001A0E                          1312      
00001A0E  4EB9 00001B28           1313          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A14                          1314         
00001A14                          1315      ; Tab out function
00001A14                          1316      
00001A14  4EB9 00001AB4           1317          Jsr     OP_TAB
00001A1A                          1318         
00001A1A                          1319      ; Handoff function
00001A1A  6000 048C               1320          BRA     EA_BIT_SHIFT
00001A1E                          1321  
00001A1E                          1322  
00001A1E                          1323  ;----------------------  ROTATE  ----------------------------;
00001A1E                          1324  
00001A1E                          1325  OP_RO_REG
00001A1E                          1326      ; start string
00001A1E                          1327      
00001A1E  1CFC 0052               1328          Move.B  #'R', (A6)+
00001A22  1CFC 004F               1329          Move.B  #'O', (A6)+
00001A26                          1330          
00001A26                          1331      ; Determine Left or right shift
00001A26                          1332      
00001A26  4EB9 00001B28           1333          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A2C                          1334          
00001A2C                          1335      ; Determine data size
00001A2C                          1336      
00001A2C  4EB9 00001AD8           1337          Jsr     OP_CHECK_DATA_SIZE
00001A32                          1338         
00001A32                          1339      ; Tab out function
00001A32                          1340      
00001A32  4EB9 00001AB4           1341          Jsr     OP_TAB
00001A38                          1342         
00001A38                          1343      ; Handoff function
00001A38  6000 046E               1344          BRA     EA_BIT_SHIFT
00001A3C                          1345  
00001A3C                          1346      
00001A3C                          1347  OP_RO_MEM
00001A3C                          1348  
00001A3C                          1349      ; start string
00001A3C                          1350      
00001A3C  1CFC 0052               1351          Move.B  #'R', (A6)+
00001A40  1CFC 004F               1352          Move.B  #'O', (A6)+
00001A44                          1353          
00001A44                          1354      ; Determine Left or right shift
00001A44                          1355      
00001A44  4EB9 00001B28           1356          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A4A                          1357         
00001A4A                          1358      ; Tab out function
00001A4A                          1359      
00001A4A  4EB9 00001AB4           1360          Jsr     OP_TAB
00001A50                          1361         
00001A50                          1362      ; Handoff function
00001A50  6000 0456               1363          BRA     EA_BIT_SHIFT
00001A54                          1364  
00001A54                          1365  
00001A54                          1366  ;-----------------------  CMP  ------------------------------;
00001A54                          1367  
00001A54                          1368  OP_Cmp
00001A54                          1369      ; start string
00001A54                          1370      
00001A54  1CFC 0043               1371          Move.B  #'C', (A6)+
00001A58  1CFC 004D               1372          Move.B  #'M', (A6)+
00001A5C  1CFC 0050               1373          Move.B  #'P', (A6)+
00001A60                          1374  
00001A60                          1375      ; Check for address version
00001A60                          1376          
00001A60  4EB9 000021BC           1377          Jsr     GET6AND7
00001A66  B03C 0003               1378          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001A6A                          1379          
00001A6A  6700 0012               1380          Beq     OP_CMP_ADDR
00001A6E                          1381          
00001A6E                          1382      ; Check which of the two versions is it?
00001A6E                          1383  
00001A6E  4EB9 00001AD8           1384          Jsr     OP_CHECK_DATA_SIZE
00001A74                          1385          
00001A74                          1386      ; Put in tabs
00001A74  4EB9 00001AB4           1387          Jsr     OP_TAB
00001A7A                          1388  
00001A7A                          1389      ; Handoff
00001A7A  6000 040C               1390          BRA     EA_CMP
00001A7E                          1391          
00001A7E                          1392  OP_CMP_ADDR
00001A7E                          1393          
00001A7E  1CFC 0041               1394          Move.B  #'A',(A6)+ ; add to the string
00001A82                          1395      
00001A82                          1396      ; Find data size
00001A82                          1397          
00001A82  4EB9 00001AF8           1398          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001A88                          1399          
00001A88                          1400      ; Put in tabs
00001A88  4EB9 00001AB4           1401          Jsr     OP_TAB
00001A8E                          1402  
00001A8E                          1403      ; Handoff
00001A8E  6000 03F8               1404          BRA     EA_CMP
00001A92                          1405      
00001A92                          1406  ;-----------------------  EOR  ------------------------------;
00001A92                          1407  
00001A92                          1408  OP_EOR
00001A92                          1409      ; start string
00001A92                          1410      
00001A92  1CFC 0045               1411          Move.B  #'E', (A6)+
00001A96  1CFC 004F               1412          Move.B  #'O', (A6)+
00001A9A  1CFC 0052               1413          Move.B  #'R', (A6)+
00001A9E                          1414  
00001A9E                          1415      ; No Address Version
00001A9E                          1416          
00001A9E                          1417      ; Check data size
00001A9E  4EB9 00001AD8           1418          Jsr     OP_CHECK_DATA_SIZE
00001AA4                          1419          
00001AA4                          1420      ; Put in tabs
00001AA4  4EB9 00001AB4           1421          Jsr     OP_TAB
00001AAA                          1422          
00001AAA  6000 03E8               1423      BRA     EA_EOR
00001AAE                          1424  
00001AAE                          1425  ;---------------- Misc Op-Code Sub Routines ----------------;
00001AAE                          1426  ; Set Bad Buffer
00001AAE                          1427  ; Sub Routine that sets the Bad buffer bit and returns
00001AAE                          1428  ;
00001AAE                          1429  ; REGISTERS USED: D7
00001AAE                          1430  
00001AAE                          1431  OP_SET_BAD_BUFFER
00001AAE  1E3C 0001               1432      Move.B  #%1, D7
00001AB2  4E75                    1433      Rts
00001AB4                          1434  
00001AB4                          1435  ;-------------------------- Tab ----------------------------;
00001AB4                          1436  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001AB4                          1437  ; taking into account the current size of the string
00001AB4                          1438  
00001AB4                          1439  ; REGISTERS USED: A6, A5(const), D0
00001AB4                          1440  
00001AB4                          1441  OP_TAB
00001AB4  220D                    1442      Move.L      A5,D1   ; Move the start of string to a Dn
00001AB6  928E                    1443      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001AB8  0681 00000014           1444      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001ABE                          1445      
00001ABE                          1446      ; Loop till you have enough spaces
00001ABE                          1447  LOOP_TAB
00001ABE  1CFC 0020               1448      Move.B      #' ',(A6)+  ; Add a space to the string
00001AC2  5301                    1449      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001AC4  66F8                    1450      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001AC6                          1451      
00001AC6  4E75                    1452      Rts
00001AC8                          1453  
00001AC8                          1454  ;--------------------- Address Version ---------------------;
00001AC8                          1455  ; This Sub Routine Checks if the Src address is an An and
00001AC8                          1456  ; Adds an A to the sring if it is, to represent that it is
00001AC8                          1457  ; Is the Address version of the Op-code. This function assumes
00001AC8                          1458  ; That D0 will have the mode for the Destination in it.
00001AC8                          1459  
00001AC8                          1460  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001AC8                          1461  ;                 A6 (Add string input)
00001AC8                          1462  
00001AC8                          1463  OP_CHECK_ADDRESS_VERSION
00001AC8                          1464  
00001AC8  B03C 0001               1465      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001ACC  6700 0004               1466      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001AD0                          1467      
00001AD0  4E75                    1468      Rts     ; Otherwise go back without changing anything
00001AD2                          1469  
00001AD2                          1470  OP_ADD_ADDRESS_VERSION
00001AD2  1CFC 0041               1471      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001AD6                          1472      
00001AD6  4E75                    1473      Rts     ; Finish up and go back
00001AD8                          1474      
00001AD8                          1475  ;--------------------- Data Size Check ---------------------;
00001AD8                          1476  ; A set of sub routines to check the size of the data and add it
00001AD8                          1477  ; To the string.
00001AD8                          1478  
00001AD8                          1479  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001AD8                          1480  ;                 A6(adds letters)    
00001AD8                          1481  OP_CHECK_DATA_SIZE
00001AD8  4EB9 000021BC           1482      Jsr     GET6AND7
00001ADE                          1483      
00001ADE  B03C 0000               1484      Cmp.B    #%00, D0    ; Byte Size
00001AE2  6700 0026               1485      Beq     OP_SET_DATA_BYTE
00001AE6                          1486      
00001AE6  B03C 0001               1487      Cmp.B    #%01, D0    ; Word Size
00001AEA  6700 0028               1488      Beq     OP_SET_DATA_WORD
00001AEE                          1489      
00001AEE  B03C 0002               1490      Cmp.B    #%10, D0    ; Long Size
00001AF2  6700 002A               1491      Beq     OP_SET_DATA_LONG
00001AF6                          1492      
00001AF6                          1493      ; If it was not one of those three types, it is not a legal operation
00001AF6  60B6                    1494      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001AF8                          1495  
00001AF8                          1496  OP_CHECK_DATA_SIZE_ADDR
00001AF8  4EB9 00002198           1497      Jsr     GETBIT8
00001AFE                          1498      
00001AFE  B03C 0000               1499      Cmp.B   #%0, D0     ; Word Size
00001B02  6700 0010               1500      Beq     OP_SET_DATA_WORD
00001B06                          1501                          ; Otherwise its Long Size
00001B06  6000 0016               1502      Bra     OP_SET_DATA_LONG
00001B0A                          1503  
00001B0A                          1504  OP_SET_DATA_BYTE
00001B0A                          1505  
00001B0A  1CFC 002E               1506      Move.B  #'.',(A6)+  ; Add Letters
00001B0E  1CFC 0042               1507      Move.B  #'B',(A6)+
00001B12                          1508      
00001B12  4E75                    1509      Rts
00001B14                          1510  
00001B14                          1511  OP_SET_DATA_WORD
00001B14                          1512  
00001B14  1CFC 002E               1513      Move.B  #'.',(A6)+  ; Add Letters
00001B18  1CFC 0057               1514      Move.B  #'W',(A6)+
00001B1C                          1515  
00001B1C  4E75                    1516      Rts
00001B1E                          1517  
00001B1E                          1518  OP_SET_DATA_LONG
00001B1E                          1519  
00001B1E  1CFC 002E               1520      Move.B  #'.',(A6)+  ; Add Letters
00001B22  1CFC 004C               1521      Move.B  #'L',(A6)+
00001B26                          1522  
00001B26  4E75                    1523      Rts
00001B28                          1524  
00001B28                          1525  ;------------------- Bit Shift Direction -------------------;
00001B28                          1526  ; This checks bit 8 to see what direction the shift is going
00001B28                          1527  
00001B28                          1528  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B28                          1529  
00001B28                          1530  OP_SHIFT_DIRECTION
00001B28  4EB9 00002198           1531      Jsr     GETBIT8 ; Get the shift direction bit
00001B2E                          1532      
00001B2E  B03C 0000               1533      Cmp.B   #%0,D0  ; 0 is Right
00001B32  6700 0006               1534      Beq     OP_SHIFT_RIGHT
00001B36                          1535  
00001B36  6000 0008               1536      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001B3A                          1537  
00001B3A                          1538  OP_SHIFT_RIGHT
00001B3A                          1539      ; Add the character and return
00001B3A  1CFC 0052               1540      Move.B  #'R',(A6)+
00001B3E                          1541  
00001B3E  4E75                    1542      Rts    
00001B40                          1543  
00001B40                          1544  OP_SHIFT_LEFT
00001B40                          1545      ; Add the character and return
00001B40  1CFC 004C               1546      Move.B  #'L',(A6)+
00001B44                          1547  
00001B44  4E75                    1548      Rts
00001B46                          1549      
00001B46                          1550  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001B46                          1551  ;-------------------- Effective Address Sub Routines --------------------;
00001B46                          1552  ; These subroutines look for the correct effective address
00001B46                          1553  ; in each OP code.
00001B46                          1554  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001B46                          1555  
00001B46                          1556  ;=============================================;
00001B46                          1557  ;--------------- EA Move/MoveA ---------------;
00001B46                          1558  ;=============================================;
00001B46                          1559  EA_MOVE
00001B46  4EB9 00001B58           1560          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001B4C  1CFC 002C               1561          Move.B  #',', (A6)+             ; Add a comma
00001B50  4EB9 00001B68           1562          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001B56                          1563          
00001B56  4E75                    1564          RTS
00001B58                          1565                  
00001B58                          1566  EA_MOVE_SOURCE  ; Find out Move's source
00001B58  4EB9 000020DA           1567          Jsr     EA_0TO5                 ; Get the EA
00001B5E                          1568          
00001B5E  B03C 0004               1569          Cmp.B   #Imm_Reg, D0            ; #<data>
00001B62  6700 004C               1570          Beq     EA_MOVE_SIZE
00001B66                          1571          
00001B66  4E75                    1572          Rts
00001B68                          1573          
00001B68                          1574  EA_MOVE_DEST    ; Find out Move's destination
00001B68  4EB9 00002162           1575          Jsr     GET6TO8                 ; Get destination mode
00001B6E  1A00                    1576          Move.B  D0, D5                  ; Move destination mode to D5
00001B70  4EB9 00002150           1577          Jsr     GET9TO11                ; Get destination register
00001B76                          1578          
00001B76                          1579          ; List of valid effective addresses
00001B76  BA3C 0000               1580          Cmp.B   #Dn_Mode, D5            ; Dn
00001B7A  6700 0482               1581          Beq     EA_DN
00001B7E                          1582          
00001B7E  BA3C 0001               1583          Cmp.B   #An_Mode, D5            ; An
00001B82  6700 0486               1584          Beq     EA_AN
00001B86                          1585          
00001B86  BA3C 0002               1586          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001B8A  6700 048A               1587          Beq     EA_AN_PNTR
00001B8E                          1588          
00001B8E  BA3C 0003               1589          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001B92  6700 0496               1590          Beq     EA_AN_INC
00001B96                          1591          
00001B96  BA3C 0004               1592          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001B9A  6700 04A6               1593          Beq     EA_AN_DEC
00001B9E                          1594          
00001B9E                          1595          ; Comparing registers at this point because modes are the same
00001B9E  B03C 0000               1596          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001BA2  6700 04B6               1597          Beq     EA_WORD_ADDR
00001BA6                          1598          
00001BA6  B03C 0001               1599          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001BAA  6700 04F2               1600          Beq     EA_LONG_ADDR
00001BAE                          1601          
00001BAE  4E75                    1602          Rts
00001BB0                          1603          
00001BB0                          1604  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001BB0  4EB9 0000212C           1605          Jsr     GET12TO13               ; Get Move size
00001BB6                          1606  
00001BB6  B03C 0001               1607          Cmp.B   #%01, D0                ; Byte
00001BBA  6700 04EE               1608          Beq     EA_IMM_BYTE
00001BBE                          1609  
00001BBE  B03C 0003               1610          Cmp.B   #%11, D0                ; Word
00001BC2  6700 04F6               1611          Beq     EA_IMM_WORD
00001BC6                          1612          
00001BC6  B03C 0002               1613          Cmp.B   #%10, D0                ; Long
00001BCA  6700 04FE               1614          Beq     EA_IMM_LONG
00001BCE                          1615          
00001BCE  4E75                    1616          Rts
00001BD0                          1617          
00001BD0                          1618  ;=================================================================;
00001BD0                          1619  ;---------------------------- EA MoveM ---------------------------;
00001BD0                          1620  ; D2 stores the counter for the number of consecutive ones in the
00001BD0                          1621  ; register list mask
00001BD0                          1622  ;
00001BD0                          1623  ; D3 stores a 1 if the register being added is the first register, 
00001BD0                          1624  ; or 0 if the register is not the first register being added
00001BD0                          1625  ;
00001BD0                          1626  ; D5 stores the register list mask
00001BD0                          1627  ;
00001BD0                          1628  ; D6 stores any expansion words
00001BD0                          1629  ;
00001BD0                          1630  ; D7 stores the loop counter
00001BD0                          1631  ;=================================================================;
00001BD0                          1632  EA_MOVEM    ; Determines the EA for MoveM
00001BD0  48E7 3F00               1633          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001BD4                          1634          
00001BD4  4282                    1635          Clr.L   D2                      ; Clear out the data registers
00001BD6  4283                    1636          Clr.L   D3
00001BD8  4285                    1637          Clr.L   D5
00001BDA  4286                    1638          Clr.L   D6
00001BDC  4287                    1639          Clr.L   D7
00001BDE                          1640          
00001BDE  5203                    1641          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001BE0  3A1B                    1642          Move.W  (A3)+, D5               ; Store the register list mask
00001BE2                          1643          
00001BE2  4EB9 00002200           1644          Jsr     GETBIT10                ; Get the direction bit
00001BE8                          1645          
00001BE8  B03C 0000               1646          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001BEC  6700 0008               1647          Beq     EA_MOVEM_REG_TO_MEM
00001BF0                          1648          
00001BF0  4EF9 00001C0C           1649          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001BF6                          1650          
00001BF6                          1651  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001BF6  4EB9 00001C28           1652          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001BFC  1CFC 002C               1653          Move.B  #',', (A6)+             ; Add a comma
00001C00  4EB9 000020DA           1654          Jsr     EA_0TO5                 ; Get the EA
00001C06                          1655          
00001C06  4CDF 00FC               1656          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C0A                          1657                  
00001C0A  4E75                    1658          RTS
00001C0C                          1659          
00001C0C                          1660  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C0C  3E05                    1661          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C0E  4EB9 000020DA           1662          Jsr     EA_0TO5                 ; Get the EA
00001C14  1CFC 002C               1663          Move.B  #',', (A6)+             ; Add a comma
00001C18  3A07                    1664          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C1A  4287                    1665          Clr.L   D7                      ; Clear D7
00001C1C  4EB9 00001C28           1666          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C22                          1667          
00001C22  4CDF 00FC               1668          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C26                          1669                  
00001C26  4E75                    1670          RTS
00001C28                          1671                  
00001C28                          1672  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C28  BE3C 0010               1673          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C2C  6C00 0016               1674          Bge     EA_MOVEM_LIST_END
00001C30                          1675  
00001C30  4EB9 00002174           1676          Jsr     GET3TO5                 ; Get the EA mode
00001C36                          1677          
00001C36  B03C 0004               1678          Cmp.B   #%100, D0               ; Predecrement mode
00001C3A  6700 000A               1679          Beq     EA_MOVEM_PRE_DEC
00001C3E                          1680          
00001C3E  4EF9 00001C50           1681          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001C44                          1682          
00001C44                          1683  EA_MOVEM_LIST_END   ; Ends the list loop
00001C44  4E75                    1684          Rts
00001C46                          1685          
00001C46                          1686  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001C46  E35D                    1687          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001C48                          1688          
00001C48  6500 0010               1689          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C4C                          1690          
00001C4C  6400 002C               1691          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C50                          1692          
00001C50                          1693  EA_MOVEM_POST_INC   ; Post increment mode
00001C50  E25D                    1694          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001C52                          1695          
00001C52  6500 0006               1696          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C56                          1697          
00001C56  6400 0022               1698          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001C5A                          1699          
00001C5A                          1700  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001C5A  B63C 0001               1701          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001C5E  6700 002A               1702          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001C62                          1703          
00001C62  B43C 0000               1704          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001C66  6700 0032               1705          Beq     EA_MOVEM_ADD_SINGLE_REG
00001C6A                          1706          
00001C6A  5207                    1707          Add.B   #1, D7                  ; Increment the loop counter
00001C6C  5202                    1708          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C6E                          1709          
00001C6E  BE3C 0010               1710          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001C72  6700 0038               1711          Beq     EA_MOVEM_LAST_REG
00001C76                          1712          
00001C76  4EF8 1C28               1713          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C7A                          1714          
00001C7A                          1715  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001C7A  B43C 0001               1716          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001C7E  6E00 003A               1717          Bgt     EA_MOVEM_ADD_LAST_REG
00001C82                          1718          
00001C82  5207                    1719          Add.B   #1, D7                  ; Increment the loop counter
00001C84                          1720          
00001C84  4282                    1721          Clr.L   D2                      ; Clear the counter for consecutive ones
00001C86                          1722          
00001C86  4EF8 1C28               1723          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C8A                          1724  
00001C8A                          1725  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001C8A  4EB9 00001CCE           1726          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001C90                          1727          
00001C90  4283                    1728          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001C92                          1729          
00001C92  5207                    1730          Add.B   #1, D7                  ; Increment the loop counter
00001C94  5202                    1731          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001C96                          1732          
00001C96  4EF8 1C28               1733          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001C9A                          1734          
00001C9A                          1735  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001C9A  1CFC 002F               1736          Move.B  #'/', (A6)+
00001C9E                          1737          
00001C9E  4EB9 00001CCE           1738          Jsr     EA_MOVEM_REG            ; Add a register
00001CA4                          1739          
00001CA4  5207                    1740          Add.B   #1, D7                  ; Increment the loop counter 
00001CA6  5202                    1741          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CA8                          1742          
00001CA8  4EF8 1C28               1743          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CAC                          1744          
00001CAC                          1745  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001CAC  B43C 0001               1746          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001CB0  6E00 0008               1747          Bgt     EA_MOVEM_ADD_LAST_REG
00001CB4                          1748          
00001CB4  5207                    1749          Add.B   #1, D7                  ; Increment the loop counter
00001CB6                          1750          
00001CB6  4EF8 1C28               1751          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CBA                          1752          
00001CBA                          1753  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001CBA  1CFC 002D               1754          Move.B  #'-', (A6)+
00001CBE                          1755          
00001CBE  5307                    1756          Sub.B   #1, D7                  ; Move back to the previous register
00001CC0                          1757          
00001CC0  4EB9 00001CCE           1758          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001CC6                          1759          
00001CC6  5407                    1760          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001CC8                          1761          
00001CC8  4282                    1762          Clr.L   D2                      ; Clear the consecutive ones counter
00001CCA                          1763          
00001CCA  4EF8 1C28               1764          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CCE                          1765          
00001CCE                          1766  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001CCE  4280                    1767          Clr.L   D0                      ; Clear D0
00001CD0  BE3C 0000               1768          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001CD4  6700 0328               1769          Beq     EA_DN
00001CD8                          1770          
00001CD8  103C 0001               1771          Move.B  #1, D0                  ; Move a 1 into D0
00001CDC  BE3C 0001               1772          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001CE0  6700 031C               1773          Beq     EA_DN
00001CE4                          1774          
00001CE4  103C 0002               1775          Move.B  #2, D0
00001CE8  BE3C 0002               1776          Cmp.B   #2, D7
00001CEC  6700 0310               1777          Beq     EA_DN
00001CF0                          1778  
00001CF0  103C 0003               1779          Move.B  #3, D0
00001CF4  BE3C 0003               1780          Cmp.B   #3, D7
00001CF8  6700 0304               1781          Beq     EA_DN
00001CFC                          1782  
00001CFC  103C 0004               1783          Move.B  #4, D0
00001D00  BE3C 0004               1784          Cmp.B   #4, D7
00001D04  6700 02F8               1785          Beq     EA_DN
00001D08                          1786  
00001D08  103C 0005               1787          Move.B  #5, D0
00001D0C  BE3C 0005               1788          Cmp.B   #5, D7
00001D10  6700 02EC               1789          Beq     EA_DN
00001D14                          1790  
00001D14  103C 0006               1791          Move.B  #6, D0
00001D18  BE3C 0006               1792          Cmp.B   #6, D7
00001D1C  6700 02E0               1793          Beq     EA_DN
00001D20                          1794          
00001D20  103C 0007               1795          Move.B  #7, D0
00001D24  BE3C 0007               1796          Cmp.B   #7, D7
00001D28  6700 02D4               1797          Beq     EA_DN
00001D2C                          1798          
00001D2C  4280                    1799          Clr.L   D0
00001D2E  BE3C 0008               1800          Cmp.B   #8, D7
00001D32  6700 02D6               1801          Beq     EA_AN
00001D36                          1802  
00001D36  103C 0001               1803          Move.B  #1, D0
00001D3A  BE3C 0009               1804          Cmp.B   #9, D7
00001D3E  6700 02CA               1805          Beq     EA_AN
00001D42                          1806  
00001D42  103C 0002               1807          Move.B  #2, D0
00001D46  BE3C 000A               1808          Cmp.B   #10, D7
00001D4A  6700 02BE               1809          Beq     EA_AN
00001D4E                          1810          
00001D4E  103C 0003               1811          Move.B  #3, D0
00001D52  BE3C 000B               1812          Cmp.B   #11, D7
00001D56  6700 02B2               1813          Beq     EA_AN
00001D5A                          1814          
00001D5A  103C 0004               1815          Move.B  #4, D0
00001D5E  BE3C 000C               1816          Cmp.B   #12, D7
00001D62  6700 02A6               1817          Beq     EA_AN
00001D66                          1818          
00001D66  103C 0005               1819          Move.B  #5, D0
00001D6A  BE3C 000D               1820          Cmp.B   #13, D7
00001D6E  6700 029A               1821          Beq     EA_AN
00001D72                          1822          
00001D72  103C 0006               1823          Move.B  #6, D0
00001D76  BE3C 000E               1824          Cmp.B   #14, D7
00001D7A  6700 028E               1825          Beq     EA_AN
00001D7E                          1826          
00001D7E  103C 0007               1827          Move.B  #7, D0
00001D82  BE3C 000F               1828          Cmp.B   #15, D7
00001D86  6700 0282               1829          Beq     EA_AN
00001D8A                          1830  
00001D8A                          1831  ;===========================================;        
00001D8A                          1832  ;--------------- EA Add/AddA ---------------;
00001D8A                          1833  ;===========================================;       
00001D8A                          1834  EA_ADD  ; Figures out the EA for Add        
00001D8A  4EB9 00002162           1835          Jsr     GET6TO8                 ; Isolate the Op mode
00001D90                          1836          
00001D90  B03C 0003               1837          Cmp.B   #%011, D0               ; Compare to AddA word
00001D94  6700 0028               1838          Beq     EA_ADDA
00001D98                          1839          
00001D98  B03C 0007               1840          Cmp.B   #%111, D0               ; Compare to AddA long
00001D9C  6700 0020               1841          Beq     EA_ADDA
00001DA0                          1842  
00001DA0  B03C 0000               1843          Cmp.B   #%000, D0               ; Compare to Add source byte
00001DA4  6700 0030               1844          Beq     EA_ADD_OPMODE_SOURCE
00001DA8                          1845          
00001DA8  B03C 0001               1846          Cmp.B   #%001, D0               ; Compare to Add source word
00001DAC  6700 0028               1847          Beq     EA_ADD_OPMODE_SOURCE
00001DB0                          1848          
00001DB0  B03C 0002               1849          Cmp.B   #%010, D0               ; Compare to Add source Long
00001DB4  6700 0020               1850          Beq     EA_ADD_OPMODE_SOURCE
00001DB8                          1851          
00001DB8  4EF9 00001DEE           1852          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001DBE                          1853          
00001DBE                          1854  EA_ADDA ; Figures out the EA for AddA
00001DBE  4EB9 00001E06           1855          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DC4  1CFC 002C               1856          Move.B  #',', (A6)+             ; Add a comma
00001DC8  4EB9 00002150           1857          Jsr     GET9TO11                ; Get the register
00001DCE  4EB9 0000200A           1858          Jsr     EA_AN                   ; Add An
00001DD4                          1859          
00001DD4  4E75                    1860          RTS
00001DD6                          1861          
00001DD6                          1862  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001DD6  4EB9 00001E06           1863          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001DDC  1CFC 002C               1864          Move.B  #',', (A6)+             ; Add a comma
00001DE0  4EB9 00002150           1865          Jsr     GET9TO11                ; Get the register
00001DE6  4EB9 00001FFE           1866          Jsr     EA_DN                   ; Add Dn
00001DEC                          1867          
00001DEC  4E75                    1868          RTS
00001DEE                          1869          
00001DEE                          1870  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001DEE  4EB9 00002150           1871          Jsr     GET9TO11                ; Get the register
00001DF4  4EB9 00001FFE           1872          Jsr     EA_DN                   ; Add Dn
00001DFA  1CFC 002C               1873          Move.B  #',', (A6)+             ; Add a comma
00001DFE  4EB9 00001E06           1874          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001E04                          1875          
00001E04  4E75                    1876          RTS
00001E06                          1877          
00001E06                          1878  EA_ADD_ADDRESS
00001E06  4EB9 000020DA           1879          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E0C                          1880          
00001E0C  B03C 0004               1881          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E10  6700 0004               1882          Beq     EA_ADD_SIZE
00001E14                          1883  
00001E14  4E75                    1884          Rts
00001E16                          1885          
00001E16                          1886  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E16  4EB9 00002162           1887          Jsr     GET6TO8                 ; Get Move size
00001E1C                          1888  
00001E1C  B03C 0000               1889          Cmp.B   #%000, D0               ; Byte
00001E20  6700 0288               1890          Beq     EA_IMM_BYTE
00001E24                          1891  
00001E24  B03C 0001               1892          Cmp.B   #%001, D0               ; Word
00001E28  6700 0290               1893          Beq     EA_IMM_WORD
00001E2C                          1894          
00001E2C  B03C 0002               1895          Cmp.B   #%010, D0               ; Long
00001E30  6700 0298               1896          Beq     EA_IMM_LONG
00001E34                          1897          
00001E34  B03C 0003               1898          Cmp.B   #%011, D0               ; AddA Word
00001E38  6700 0280               1899          Beq     EA_IMM_WORD
00001E3C                          1900     
00001E3C  B03C 0007               1901          Cmp.B   #%111, D0               ; AddA Long
00001E40  6700 0288               1902          Beq     EA_IMM_LONG
00001E44                          1903          
00001E44  4E75                    1904          Rts
00001E46                          1905          
00001E46                          1906  ;=================================================;        
00001E46                          1907  ;-------------------- EA AddQ --------------------;
00001E46                          1908  ;=================================================;
00001E46                          1909  EA_ADDQ ; Figures out the EA for AddQ
00001E46  4EB9 00001E58           1910          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001E4C  1CFC 002C               1911          Move.B  #',', (A6)+             ; Add a comma
00001E50  4EB9 00001E7C           1912          Jsr     EA_ADDQ_DEST            ; Add the destination
00001E56                          1913          
00001E56  4E75                    1914          Rts
00001E58                          1915  
00001E58                          1916  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001E58  4EB9 00002150           1917          Jsr     GET9TO11                ; Isolate the count/register bits
00001E5E                          1918          
00001E5E  B03C 0000               1919          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001E62  6E00 000C               1920          Bgt     EA_ADDQ_IMMEDIATE
00001E66                          1921          
00001E66  103C 0008               1922          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001E6A                          1923          
00001E6A  4EF9 00001E70           1924          Jmp     EA_ADDQ_IMMEDIATE
00001E70                          1925          
00001E70                          1926  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001E70  1CFC 0023               1927          Move.B  #'#', (A6)+
00001E74  0600 0030               1928          Add.B   #$30, D0
00001E78  1CC0                    1929          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001E7A                          1930          
00001E7A  4E75                    1931          Rts
00001E7C                          1932          
00001E7C                          1933  EA_ADDQ_DEST    ; Determines the destination       
00001E7C  4EB9 000020DA           1934          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E82                          1935          
00001E82  4E75                    1936          Rts     
00001E84                          1937          
00001E84                          1938  ;=========================================================;        
00001E84                          1939  ;---------------------- EA Sub/SubA ----------------------;
00001E84                          1940  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E84                          1941  ; Sub/SubA are exactly the same.
00001E84                          1942  ;=========================================================;
00001E84                          1943  EA_SUB
00001E84  4EF8 1D8A               1944          Jmp     EA_ADD
00001E88                          1945  
00001E88                          1946  ;=========================================================;        
00001E88                          1947  ;---------------------- EA Cmp/CmpA ----------------------;
00001E88                          1948  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001E88                          1949  ; Cmp/CmpA are exactly the same.
00001E88                          1950  ;=========================================================;
00001E88                          1951  EA_CMP       
00001E88  4EF8 1D8A               1952          Jmp     EA_ADD
00001E8C                          1953          
00001E8C                          1954  ;=========================================================;        
00001E8C                          1955  ;------------------------ EA Lea -------------------------;
00001E8C                          1956  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001E8C                          1957  ; are exactly the same.
00001E8C                          1958  ;=========================================================;
00001E8C                          1959  EA_LEA
00001E8C  4EF8 1D8A               1960          Jmp     EA_ADD
00001E90                          1961          
00001E90                          1962  ;=========================================================;        
00001E90                          1963  ;------------------------ EA And -------------------------;
00001E90                          1964  ; Jumps straight to EA_ADD because the EA for Add and And
00001E90                          1965  ; are exactly the same.
00001E90                          1966  ;=========================================================;
00001E90                          1967  EA_AND
00001E90  4EF8 1D8A               1968          Jmp     EA_ADD
00001E94                          1969          
00001E94                          1970  ;=========================================================;        
00001E94                          1971  ;------------------------ EA Eor -------------------------;
00001E94                          1972  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001E94                          1973  ; are exactly the same.
00001E94                          1974  ;=========================================================;
00001E94                          1975  EA_EOR
00001E94  4EF8 1D8A               1976          Jmp     EA_ADD
00001E98                          1977          
00001E98                          1978  ;=========================================================;        
00001E98                          1979  ;------------------------ EA Neg -------------------------;
00001E98                          1980  ;=========================================================;
00001E98                          1981  EA_NEG
00001E98  4EB9 000020DA           1982          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E9E                          1983          
00001E9E  4E75                    1984          RTS
00001EA0                          1985          
00001EA0                          1986  ;=========================================================;        
00001EA0                          1987  ;------------------------ EA Not -------------------------;
00001EA0                          1988  ; Jumps straight to EA_NEG because Neg and Not have the
00001EA0                          1989  ; exact same EAs. 
00001EA0                          1990  ;=========================================================;
00001EA0                          1991  EA_NOT
00001EA0  4EF8 1E98               1992          Jmp     EA_NEG 
00001EA4                          1993          
00001EA4                          1994  ;=========================================================;        
00001EA4                          1995  ;------------------------ EA Jsr -------------------------;
00001EA4                          1996  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001EA4                          1997  ; exact same EAs. 
00001EA4                          1998  ;=========================================================;
00001EA4                          1999  EA_Jsr
00001EA4  4EF8 1E98               2000          Jmp     EA_NEG 
00001EA8                          2001  
00001EA8                          2002  ;=========================================================;
00001EA8                          2003  ;--------------------- EA Bit Shift ----------------------;
00001EA8                          2004  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001EA8                          2005  ; are combined because the EA for each code is exactly the
00001EA8                          2006  ; same.
00001EA8                          2007  ;=========================================================;
00001EA8                          2008  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001EA8  4EB9 00002212           2009          Jsr     GET6TO7
00001EAE                          2010          
00001EAE  B03C 0003               2011          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001EB2  6600 0012               2012          Bne     EA_SHIFT_REGISTER
00001EB6                          2013          
00001EB6  4EB9 00001EBE           2014          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001EBC                          2015          
00001EBC  4E75                    2016          RTS
00001EBE                          2017                  
00001EBE                          2018  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001EBE  4EB9 000020DA           2019          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EC4                          2020          
00001EC4  4E75                    2021          Rts
00001EC6                          2022          
00001EC6                          2023  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001EC6  4EB9 000021E0           2024          Jsr     GETBIT5
00001ECC                          2025          
00001ECC  B03C 0000               2026          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001ED0  6700 0008               2027          Beq     EA_SHIFT_CHECK_8
00001ED4                          2028          
00001ED4  4EF9 00001F02           2029          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001EDA                          2030          
00001EDA                          2031  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001EDA  4EB9 00002150           2032          Jsr     GET9TO11                ; Isolate the count/register bits
00001EE0                          2033          
00001EE0  B03C 0000               2034          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001EE4  6E00 000C               2035          Bgt     EA_SHIFT_IMMEDIATE
00001EE8                          2036          
00001EE8  103C 0008               2037          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001EEC                          2038                  
00001EEC  4EF9 00001EF2           2039          Jmp     EA_SHIFT_IMMEDIATE
00001EF2                          2040          
00001EF2                          2041  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001EF2  1CFC 0023               2042          Move.B  #'#', (A6)+
00001EF6  0600 0030               2043          Add.B   #$30, D0
00001EFA  1CC0                    2044          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001EFC                          2045  
00001EFC  4EF9 00001F14           2046          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001F02                          2047          
00001F02                          2048  EA_SHIFT_DN ; Adds a data register before the comma
00001F02  4EB9 00002150           2049          Jsr     GET9TO11                ; Isolate the data register bits
00001F08                          2050          
00001F08  4EB9 00001FFE           2051          Jsr     EA_DN                   ; Add the data register to the string
00001F0E                          2052          
00001F0E  4EF9 00001F14           2053          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F14                          2054          
00001F14                          2055  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F14  1CFC 002C               2056          Move.B  #',', (A6)+
00001F18                          2057          
00001F18  4EB9 00002186           2058          Jsr     GET0TO2                 ; Get the register number
00001F1E                          2059          
00001F1E  4EB9 00001FFE           2060          Jsr     EA_DN                   ; Add the register
00001F24                          2061          
00001F24  4E75                    2062          RTS
00001F26                          2063  
00001F26                          2064  ;============================================;        
00001F26                          2065  ;--------------- EA Immediate ---------------;
00001F26                          2066  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F26                          2067  ;============================================;
00001F26                          2068  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F26  4EB9 00001F38           2069          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F2C  1CFC 002C               2070          Move.B  #',', (A6)+             ; Add a comma
00001F30  4EB9 00001F56           2071          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001F36                          2072          
00001F36  4E75                    2073          RTS
00001F38                          2074          
00001F38                          2075  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001F38  4EB9 00002212           2076          Jsr     GET6TO7                 ; Isolate the size bits
00001F3E                          2077                  
00001F3E  B03C 0001               2078          Cmp.B   #%01, D0                ; Immediate word
00001F42  6700 0176               2079          Beq     EA_IMM_WORD
00001F46                          2080          
00001F46  B03C 0002               2081          Cmp.B   #%10, D0                ; Immediate long
00001F4A  6700 017E               2082          Beq     EA_IMM_LONG
00001F4E                          2083        
00001F4E  4EF9 000020AA           2084          Jmp     EA_IMM_BYTE
00001F54                          2085  
00001F54  4E75                    2086          Rts
00001F56                          2087          
00001F56                          2088  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001F56  4EB9 000020DA           2089          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F5C                          2090          
00001F5C  4E75                    2091          Rts
00001F5E                          2092        
00001F5E                          2093  ;=================================================;  
00001F5E                          2094  ;-------------------- EA Muls --------------------;
00001F5E                          2095  ;=================================================;
00001F5E                          2096  EA_MULS ; Determines the EA for Muls
00001F5E  4EB9 00001F76           2097          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001F64  1CFC 002C               2098          Move.B  #',', (A6)+             ; Add a comma
00001F68  4EB9 00002150           2099          Jsr     GET9TO11                ; Get the register
00001F6E  4EB9 00001FFE           2100          Jsr     EA_DN                   ; Add Dn
00001F74                          2101          
00001F74  4E75                    2102          RTS
00001F76                          2103          
00001F76                          2104  EA_MULS_ADDRESS ; Determines the EA
00001F76  4EB9 000020DA           2105          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F7C                          2106          
00001F7C  B03C 0004               2107          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001F80  6700 0138               2108          Beq     EA_IMM_WORD
00001F84                          2109          
00001F84  4E75                    2110          Rts
00001F86                          2111          
00001F86                          2112  ;=================================================;  
00001F86                          2113  ;-------------------- EA DIVS --------------------;
00001F86                          2114  ; Jumps straight to EA_DIVS because the EA for
00001F86                          2115  ; both OP codes is exactly the same.
00001F86                          2116  ;=================================================;
00001F86                          2117  EA_DIVS
00001F86  4EF8 1F5E               2118          Jmp     EA_MULS
00001F8A                          2119          
00001F8A                          2120  ;=================================================;        
00001F8A                          2121  ;-------------------- EA BTST --------------------;
00001F8A                          2122  ;=================================================;
00001F8A                          2123  EA_BTST ; Determines the EA for Btst
00001F8A  4EB9 00002198           2124          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001F90                          2125          
00001F90  B03C 0001               2126          Cmp.B   #%1, D0                 ; 1 is a data register
00001F94  6700 0008               2127          Beq     EA_BTST_DN
00001F98                          2128          
00001F98  4EF9 00001FB2           2129          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
00001F9E                          2130          
00001F9E                          2131  EA_BTST_DN  ; Gets the register for the bit number
00001F9E  4EB9 00002150           2132          Jsr     GET9TO11                ; Get the register
00001FA4  4EB9 00001FFE           2133          Jsr     EA_DN                   ; Add the register to the string
00001FAA                          2134          
00001FAA  4EB9 00001FC0           2135          Jsr     EA_BTST_ADDRESS         ; Add the EA
00001FB0                          2136          
00001FB0  4E75                    2137          RTS
00001FB2                          2138  
00001FB2                          2139  EA_BTST_IMM ; Gets the immediate data for the bit number
00001FB2  4EB9 000020AA           2140          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00001FB8                          2141          
00001FB8  4EB9 00001FC0           2142          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
00001FBE                          2143          
00001FBE  4E75                    2144          RTS
00001FC0                          2145  
00001FC0                          2146  EA_BTST_ADDRESS ; Get the EA
00001FC0  1CFC 002C               2147          Move.B  #',', (A6)+
00001FC4                          2148  
00001FC4  4EB9 000020DA           2149          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
00001FCA                          2150          
00001FCA  B03C 0004               2151          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
00001FCE  6700 00DA               2152          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
00001FD2                          2153          
00001FD2  4E75                    2154          Rts
00001FD4                          2155          
00001FD4                          2156  ;==================================================;        
00001FD4                          2157  ;------------------- EA Branch --------------------;
00001FD4                          2158  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00001FD4                          2159  ;==================================================;
00001FD4                          2160  EA_BRANCH  ; Determines the EA for Branch codes
00001FD4  4EB9 000021F2           2161          Jsr     GET0TO7                 ; Get the 8 displacement bits
00001FDA                          2162          
00001FDA  2C0B                    2163          Move.L  A3, D6                  ; Move address after the Bra word to D6
00001FDC                          2164          
00001FDC  B03C 0000               2165          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
00001FE0  6700 0008               2166          Beq     EA_BRANCH_16_BIT
00001FE4                          2167          
00001FE4  4EF9 00001FF2           2168          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
00001FEA                          2169  
00001FEA                          2170  EA_BRANCH_16_BIT   ; Gets the next word
00001FEA  301B                    2171          Move.W  (A3)+, D0               ; Stores the word in D0
00001FEC                          2172  
00001FEC  4EF9 00001FF2           2173          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
00001FF2                          2174          
00001FF2                          2175  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
00001FF2  DC40                    2176          Add.W   D0, D6                  ; Add the displacement to D6
00001FF4                          2177      
00001FF4  1CFC 0024               2178          Move.B  #'$', (A6)+             ; Add '$' to the string
00001FF8                          2179          
00001FF8  4EB8 1290               2180          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
00001FFC                          2181  
00001FFC  4E75                    2182          RTS
00001FFE                          2183                         
00001FFE                          2184  ;==========================================;        
00001FFE                          2185  ;---------- General EA functions ----------;
00001FFE                          2186  ;==========================================;
00001FFE                          2187  EA_DN   ; Adds Dn EA to string
00001FFE  1CFC 0044               2188          Move.B  #'D', (A6)+             
00002002  0600 0030               2189          Add.B   #$30, D0        
00002006  1CC0                    2190          Move.B  D0, (A6)+               
00002008                          2191                  
00002008  4E75                    2192          Rts
0000200A                          2193  
0000200A                          2194  EA_AN   ; Adds An EA to string
0000200A  1CFC 0041               2195          Move.B  #'A', (A6)+
0000200E  0600 0030               2196          Add.B   #$30, D0    
00002012  1CC0                    2197          Move.B  D0, (A6)+               
00002014                          2198                  
00002014  4E75                    2199          Rts
00002016                          2200  
00002016                          2201  EA_AN_PNTR  ; Adds (An) EA to string
00002016  1CFC 0028               2202          Move.B  #'(', (A6)+
0000201A  1CFC 0041               2203          Move.B  #'A', (A6)+
0000201E  0600 0030               2204          Add.B   #$30, D0
00002022  1CC0                    2205          Move.B  D0, (A6)+
00002024  1CFC 0029               2206          Move.B  #')', (A6)+
00002028                          2207                  
00002028  4E75                    2208          Rts
0000202A                          2209          
0000202A                          2210  EA_AN_INC   ; Adds (An)+ EA to string
0000202A  1CFC 0028               2211          Move.B  #'(', (A6)+
0000202E  1CFC 0041               2212          Move.B  #'A', (A6)+
00002032  0600 0030               2213          Add.B   #$30, D0
00002036  1CC0                    2214          Move.B  D0, (A6)+
00002038  1CFC 0029               2215          Move.B  #')', (A6)+
0000203C  1CFC 002B               2216          Move.B  #'+', (A6)+
00002040                          2217                  
00002040  4E75                    2218          Rts 
00002042                          2219          
00002042                          2220  EA_AN_DEC   ; Adds -(An) EA to string
00002042  1CFC 002D               2221          Move.B  #'-', (A6)+
00002046  1CFC 0028               2222          Move.B  #'(', (A6)+
0000204A  1CFC 0041               2223          Move.B  #'A', (A6)+
0000204E  0600 0030               2224          Add.B   #$30, D0
00002052  1CC0                    2225          Move.B  D0, (A6)+
00002054  1CFC 0029               2226          Move.B  #')', (A6)+
00002058                          2227                  
00002058  4E75                    2228          Rts 
0000205A                          2229  
0000205A                          2230  EA_WORD_ADDR    ; Adds $Word to string
0000205A  3C1B                    2231          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
0000205C                          2232          
0000205C  1CFC 0024               2233          Move.B  #'$', (A6)+
00002060                          2234          
00002060  BC7C 8000               2235          Cmp.W   #$8000, D6          ; Word address is less than 8000
00002064  6500 000C               2236          Bcs     EA_SIGN_EXT_16
00002068                          2237          
00002068  BC7C 8000               2238          Cmp.W   #$8000, D6          ; Word address is greater than 8000
0000206C  6400 001A               2239          Bcc     EA_SIGN_EXT_32
00002070                          2240          
00002070  4E75                    2241          Rts
00002072                          2242                  
00002072                          2243  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
00002072  1CFC 0030               2244          Move.B  #'0', (A6)+
00002076  1CFC 0030               2245          Move.B  #'0', (A6)+
0000207A  1CFC 0030               2246          Move.B  #'0', (A6)+
0000207E  1CFC 0030               2247          Move.B  #'0', (A6)+
00002082                          2248          
00002082  4EB8 12B0               2249          Jsr     hex_to_ASCII_W       
00002086                          2250          
00002086  4E75                    2251          Rts
00002088                          2252  
00002088                          2253  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
00002088  1CFC 0046               2254          Move.B  #'F', (A6)+
0000208C  1CFC 0046               2255          Move.B  #'F', (A6)+
00002090  1CFC 0046               2256          Move.B  #'F', (A6)+
00002094  1CFC 0046               2257          Move.B  #'F', (A6)+
00002098                          2258          
00002098  4EB8 12B0               2259          Jsr     hex_to_ASCII_W   
0000209C                          2260          
0000209C  4E75                    2261          Rts
0000209E                          2262                  
0000209E                          2263  EA_LONG_ADDR    ; Adds $Long to string
0000209E  2C1B                    2264          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
000020A0                          2265          
000020A0  1CFC 0024               2266          Move.B  #'$', (A6)+
000020A4                          2267          
000020A4  4EB8 1290               2268          Jsr     hex_to_ASCII_L
000020A8                          2269  
000020A8  4E75                    2270          Rts
000020AA                          2271                  
000020AA                          2272  
000020AA                          2273  EA_IMM_BYTE ; Finds the immediate byte data
000020AA  3C1B                    2274          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
000020AC                          2275          
000020AC  1CFC 0023               2276          Move.B  #'#', (A6)+         
000020B0  1CFC 0024               2277          Move.B  #'$', (A6)+         
000020B4                          2278          
000020B4  4EB8 12D0               2279          Jsr     hex_to_ASCII_B    ; Add the byte to the string
000020B8                          2280          
000020B8  4E75                    2281          Rts
000020BA                          2282                  
000020BA                          2283  EA_IMM_WORD ; Finds the immediate word data
000020BA  3C1B                    2284          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
000020BC                          2285          
000020BC  1CFC 0023               2286          Move.B  #'#', (A6)+         
000020C0  1CFC 0024               2287          Move.B  #'$', (A6)+         
000020C4                          2288          
000020C4  4EB8 12B0               2289          Jsr     hex_to_ASCII_W    ; Add the word to the string
000020C8                          2290          
000020C8  4E75                    2291          Rts
000020CA                          2292          
000020CA                          2293  EA_IMM_LONG ; Finds the immediate long data
000020CA  2C1B                    2294          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
000020CC                          2295          
000020CC  1CFC 0023               2296          Move.B  #'#', (A6)+
000020D0  1CFC 0024               2297          Move.B  #'$', (A6)+
000020D4                          2298          
000020D4  4EB8 1290               2299          Jsr     hex_to_ASCII_L    ; Add the long to the string
000020D8                          2300          
000020D8  4E75                    2301          Rts
000020DA                          2302          
000020DA                          2303  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
000020DA  4EB9 00002174           2304          Jsr     GET3TO5                 ; Get source mode
000020E0  1A00                    2305          Move.B  D0, D5                  ; Move source mode to D5
000020E2  4EB9 00002186           2306          Jsr     Get0TO2                 ; Get source register
000020E8                          2307          
000020E8                          2308          ; List of valid effective addresses
000020E8  BA3C 0000               2309          Cmp.B   #Dn_Mode, D5            ; Dn
000020EC  6700 FF10               2310          Beq     EA_DN
000020F0                          2311          
000020F0  BA3C 0001               2312          Cmp.B   #An_Mode, D5            ; An
000020F4  6700 FF14               2313          Beq     EA_AN
000020F8                          2314          
000020F8  BA3C 0002               2315          Cmp.B   #An_Pntr_Mode, D5       ; (An)
000020FC  6700 FF18               2316          Beq     EA_AN_PNTR
00002100                          2317          
00002100  BA3C 0003               2318          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00002104  6700 FF24               2319          Beq     EA_AN_INC
00002108                          2320          
00002108  BA3C 0004               2321          Cmp.B   #An_Dec_Mode, D5        ; -(An)
0000210C  6700 FF34               2322          Beq     EA_AN_DEC
00002110                          2323          
00002110                          2324          ; Comparing registers at this point because modes are the same
00002110  B03C 0000               2325          Cmp.B   #Word_Reg, D0           ; (xxx).W
00002114  6700 FF44               2326          Beq     EA_WORD_ADDR
00002118                          2327          
00002118  B03C 0001               2328          Cmp.B   #Long_Reg, D0           ; (xxx).L
0000211C  6780                    2329          Beq     EA_LONG_ADDR
0000211E                          2330          
0000211E  4E75                    2331          Rts
00002120                          2332      
00002120                          2333  
00002120                          2334  ;---------------- Bit Chopping Sub Routines ----------------;
00002120                          2335  ; These Sub Routines Chop a WORD size piece of data from
00002120                          2336  ; Data register 4 into a smaller piece, leaving just the
00002120                          2337  ; Piece in register 0 while leaving the original piece
00002120                          2338  ; of data intact.
00002120                          2339  
00002120                          2340  ; REGISTERS USED: D0, D1, D4 (const input)
00002120                          2341  
00002120                          2342  GET12TO15   ;1001 0000 0000 0000 -> 1001
00002120  4280                    2343                  CLR.L   D0      
00002122  3004                    2344                  Move.W  D4, D0      
00002124                          2345                  
00002124  123C 000C               2346                  Move.B  #12, D1     
00002128  E268                    2347                  LSR.W       D1, D0      
0000212A                          2348                  
0000212A  4E75                    2349                  RTS
0000212C                          2350                  
0000212C                          2351  GET12TO13
0000212C  4280                    2352          CLR.L   D0
0000212E  3004                    2353          Move.W  D4, D0
00002130                          2354          
00002130  123C 0002               2355          Move.B  #2, D1
00002134  E368                    2356          LSL     D1, D0
00002136                          2357          
00002136  123C 000E               2358          Move.B  #14, D1
0000213A  E268                    2359          LSR     D1, D0
0000213C                          2360          
0000213C  4E75                    2361          RTS             
0000213E                          2362  
0000213E                          2363  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
0000213E  4280                    2364                  CLR.L   D0      ; Clear out D0
00002140  3004                    2365                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002142                          2366                  
00002142  123C 0004               2367                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002146  E368                    2368                  LSL.W   D1, D0      ; Move the string all the way to the left
00002148                          2369                  
00002148  123C 000C               2370                  Move.B  #12, D1     ; Change the amount of bits shifted
0000214C  E268                    2371                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
0000214E                          2372                  
0000214E  4E75                    2373                  RTS         ; Return from the subroutine
00002150                          2374                      
00002150                          2375  GET9TO11    ; 0000 1010 0000 0000 -> 101    
00002150  4280                    2376                  CLR.L   D0      ; Clear out D0
00002152  3004                    2377                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002154                          2378                  
00002154  123C 0004               2379                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002158  E368                    2380                  LSL.W   D1, D0      ; Move the string all the way to the left
0000215A                          2381                  
0000215A  123C 000D               2382                  Move.B  #13, D1     ; Change the amount of bits shifted
0000215E  E268                    2383                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
00002160                          2384                  
00002160  4E75                    2385                  RTS         ; Return from the subroutine
00002162                          2386                  
00002162                          2387  GET6TO8     ; 0000 0001 1000 0000 -> 110
00002162  4280                    2388                  CLR.L   D0
00002164  3004                    2389                  Move.W  D4, D0
00002166                          2390                  
00002166  123C 0007               2391                  Move.B  #7, D1
0000216A  E368                    2392                  LSL.W   D1, D0
0000216C                          2393                  
0000216C  123C 000D               2394                  Move.B  #13, D1
00002170  E268                    2395                  LSR.W       D1, D0
00002172                          2396                  
00002172  4E75                    2397                  RTS
00002174                          2398                  
00002174                          2399  GET3TO5     ; 0000 0000 0011 1000 -> 111
00002174  4280                    2400                  CLR.L   D0
00002176  3004                    2401                  Move.W  D4, D0
00002178                          2402                  
00002178  123C 000A               2403                  Move.B  #10, D1
0000217C  E368                    2404                  LSL.W   D1, D0
0000217E                          2405                  
0000217E  123C 000D               2406                  Move.B  #13, D1
00002182  E268                    2407                  LSR.W       D1, D0
00002184                          2408                  
00002184  4E75                    2409                  RTS
00002186                          2410  GET0TO2     ; 0000 0000 0000 0011 -> 011
00002186  4280                    2411                  CLR.L   D0
00002188  3004                    2412                  Move.W  D4, D0
0000218A                          2413                  
0000218A  123C 000D               2414                  Move.B  #13, D1
0000218E  E368                    2415                  LSL.W   D1, D0
00002190                          2416                  
00002190  123C 000D               2417                  Move.B  #13, D1
00002194  E268                    2418                  LSR.W       D1, D0
00002196                          2419                  
00002196  4E75                    2420                  RTS
00002198                          2421  GETBIT8     ; 0000 0001 0000 0000 -> 1
00002198  4280                    2422                  CLR.L   D0
0000219A  3004                    2423                  Move.W  D4, D0
0000219C                          2424                  
0000219C  123C 0007               2425                  Move.B  #7, D1
000021A0  E368                    2426                  LSL.W   D1, D0
000021A2                          2427                  
000021A2  123C 000F               2428                  Move.B  #15, D1
000021A6  E268                    2429                  LSR.W       D1, D0
000021A8                          2430                  
000021A8  4E75                    2431                  RTS
000021AA                          2432                  
000021AA                          2433  GET9AND10    ; 0000 0110 0000 0000 -> 11
000021AA  4280                    2434                  CLR.L   D0
000021AC  3004                    2435                  Move.W  D4, D0
000021AE                          2436                  
000021AE  123C 0005               2437                  Move.B  #5, D1
000021B2  E368                    2438                  LSL.W   D1, D0
000021B4                          2439                  
000021B4  123C 000E               2440                  Move.B  #14, D1
000021B8  E268                    2441                  LSR.W   D1, D0
000021BA                          2442                  
000021BA  4E75                    2443                  RTS             
000021BC                          2444                  
000021BC                          2445  GET6AND7    ; 0000 0000 1100 0000 -> 11
000021BC  4280                    2446                  CLR.L   D0
000021BE  3004                    2447                  Move.W  D4, D0
000021C0                          2448                  
000021C0  123C 0008               2449                  Move.B  #8, D1
000021C4  E368                    2450                  LSL.W   D1, D0
000021C6                          2451                  
000021C6  123C 000E               2452                  Move.B  #14, D1
000021CA  E268                    2453                  LSR.W   D1, D0
000021CC                          2454                  
000021CC  4E75                    2455                  RTS
000021CE                          2456                  
000021CE                          2457  GET3AND4    ; 0000 0000 0001 1000 -> 11
000021CE  4280                    2458                  CLR.L   D0
000021D0  3004                    2459                  Move.W  D4, D0
000021D2                          2460                  
000021D2  123C 000B               2461                  Move.B  #11, D1
000021D6  E368                    2462                  LSL.W   D1, D0
000021D8                          2463                  
000021D8  123C 000E               2464                  Move.B  #14, D1
000021DC  E268                    2465                  LSR.W   D1, D0
000021DE                          2466                  
000021DE  4E75                    2467                  RTS
000021E0                          2468                  
000021E0                          2469  GETBIT5
000021E0  4280                    2470          Clr.L   D0
000021E2  3004                    2471          Move.W  D4, D0
000021E4                          2472          
000021E4  123C 000A               2473          Move.B  #10, D1
000021E8  E368                    2474          Lsl     D1, D0
000021EA                          2475          
000021EA  123C 000F               2476          Move.B  #15, D1
000021EE  E268                    2477          Lsr     D1, D0
000021F0                          2478          
000021F0  4E75                    2479          Rts
000021F2                          2480  
000021F2                          2481  GET0TO7
000021F2  4280                    2482          Clr.L   D0
000021F4  3004                    2483          Move.W  D4, D0
000021F6                          2484          
000021F6  123C 0008               2485          Move.B  #8, D1
000021FA  E368                    2486          Lsl     D1, D0
000021FC                          2487          
000021FC  E268                    2488          Lsr     D1, D0
000021FE                          2489          
000021FE  4E75                    2490          Rts
00002200                          2491          
00002200                          2492  GETBIT10
00002200  4280                    2493          Clr.L   D0
00002202  3004                    2494          Move.W  D4, D0
00002204                          2495          
00002204  123C 0005               2496          Move.B  #5, D1
00002208  E368                    2497          Lsl     D1, D0
0000220A                          2498          
0000220A  123C 000F               2499          Move.B  #15, D1
0000220E  E268                    2500          Lsr     D1, D0
00002210                          2501          
00002210  4E75                    2502          Rts
00002212                          2503          
00002212                          2504  GET6TO7
00002212  4280                    2505          Clr.L   D0
00002214  3004                    2506          Move.W  D4, D0
00002216                          2507          
00002216  123C 0008               2508          Move.B  #8, D1
0000221A  E368                    2509          Lsl     D1, D0
0000221C                          2510          
0000221C  123C 000E               2511          Move.B  #14, D1
00002220  E268                    2512          Lsr     D1, D0
00002222                          2513          
00002222  4E75                    2514          Rts
00002224                          2515  
00002224                          2516  GET3TO8    ; 0000 0000 1100 0000 -> 11
00002224  4280                    2517                  CLR.L   D0
00002226  3004                    2518                  Move.W  D4, D0
00002228                          2519                  
00002228  123C 0007               2520                  Move.B  #7, D1
0000222C  E368                    2521                  LSL.W   D1, D0
0000222E                          2522                  
0000222E  123C 000A               2523                  Move.B  #10, D1
00002232  E268                    2524                  LSR.W   D1, D0
00002234                          2525                  
00002234  4E75                    2526                  RTS
00002236                          2527  
00002236                          2528  GET6TO11    ; 0000 0000 1100 0000 -> 11
00002236  4280                    2529                  CLR.L   D0
00002238  3004                    2530                  Move.W  D4, D0
0000223A                          2531                  
0000223A  123C 0004               2532                  Move.B  #4, D1
0000223E  E368                    2533                  LSL.W   D1, D0
00002240                          2534                  
00002240  123C 000A               2535                  Move.B  #10, D1
00002244  E268                    2536                  LSR.W   D1, D0
00002246                          2537                  
00002246  4E75                    2538                  RTS        
00002248                          2539                  
00002248                          2540             
00002248                          2541  ;-----------Constants/Messages-------------------------------------------------
00002248= 09 2D 2D 2D 2D 2D ...   2542  intro_stuff     DC.B    HT,'------------------------------------------------------',CR,LF,0
00002282                          2543  
00002282= 09 20 57 65 6C 63 ...   2544  intro_msg       DC.B    HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000022BA= 09 20 43 72 65 61 ...   2545                  DC.B    HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
000022F3                          2546         
000022F3= 50 6C 65 61 73 65 ...   2547  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
0000232C= 50 6C 65 61 73 65 ...   2548  end_address1    DC.B    'Please enter the ending address from $',0
00002353= 20 74 6F 20 24 30 ...   2549  end_address2    DC.B    ' to $00FFFFFE: ',0
00002363= 54 68 61 6E 6B 20 ...   2550  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
00002395= 57 6F 75 6C 64 20 ...   2551  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000023C5= 48 69 74 20 65 6E ...   2552  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
000023F3                          2553  
000023F3= 09 41 64 64 72 65 ...   2554  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
00002429= 09 59 6F 75 20 6E ...   2555  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
00002455= 09 50 6C 65 61 73 ...   2556  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
0000248D                          2557  
0000248E                          2558  start_input     DS.L    2               ; Allocates space for start address
00002496                          2559  end_input       DS.L    2               ; Allocates space for end address
0000249E                          2560  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
000024A6                          2561  hit_enter       DS.L    2               ; User input to hit enter
000024AE                          2562  line_count      DS.L    1               ; Holds the display line count  
000024B2                          2563  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
000025F2                          2564  valid_data      DS.L    80              ; Instructions that we converted
00002732                          2565                  
00002732                          2566                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            14FA
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           2455
ASK_INPUT           249E
ASK_USER            2395
BADADDR_INPUT       23F3
BAD_BUFF            1134
BEGIN               0
BIT_SHIFT           153A
BIT_SHIFT_MEM       154C
BIT_SHIFT_REG       156E
BRANCH_CONDITIONALS  1478
CHECK_10_LINES      118A
CHECK_INPUT         1244
CHK_BOUND           1336
CMP_EOR             1590
CONVERT_HEX         12F0
CR                  D
DISASSEMBLE         10DE
DISPLAY_DATA        114E
DN_MODE             0
DONE                1222
DONE_CONVERTING     1312
EA_0TO5             20DA
EA_ADD              1D8A
EA_ADDA             1DBE
EA_ADDQ             1E46
EA_ADDQ_CHECK_8     1E58
EA_ADDQ_DEST        1E7C
EA_ADDQ_IMMEDIATE   1E70
EA_ADD_ADDRESS      1E06
EA_ADD_OPMODE_DEST  1DEE
EA_ADD_OPMODE_SOURCE  1DD6
EA_ADD_SIZE         1E16
EA_AN               200A
EA_AND              1E90
EA_AN_DEC           2042
EA_AN_INC           202A
EA_AN_PNTR          2016
EA_BIT_SHIFT        1EA8
EA_BRANCH           1FD4
EA_BRANCH_16_BIT    1FEA
EA_BRANCH_ADD_DIS   1FF2
EA_BTST             1F8A
EA_BTST_ADDRESS     1FC0
EA_BTST_DN          1F9E
EA_BTST_IMM         1FB2
EA_CMP              1E88
EA_DIVS             1F86
EA_DN               1FFE
EA_EOR              1E94
EA_IMMEDIATE        1F26
EA_IMMEDIATE_DEST   1F56
EA_IMMEDIATE_SIZE   1F38
EA_IMM_BYTE         20AA
EA_IMM_LONG         20CA
EA_IMM_WORD         20BA
EA_JSR              1EA4
EA_LEA              1E8C
EA_LONG_ADDR        209E
EA_MOVE             1B46
EA_MOVEM            1BD0
EA_MOVEM_ADD_LAST_REG  1CBA
EA_MOVEM_ADD_SINGLE_REG  1C9A
EA_MOVEM_CARRY_CLEAR  1C7A
EA_MOVEM_CARRY_SET  1C5A
EA_MOVEM_FIRST_REG  1C8A
EA_MOVEM_LAST_REG   1CAC
EA_MOVEM_LIST_END   1C44
EA_MOVEM_LIST_LOOP  1C28
EA_MOVEM_MEM_TO_REG  1C0C
EA_MOVEM_POST_INC   1C50
EA_MOVEM_PRE_DEC    1C46
EA_MOVEM_REG        1CCE
EA_MOVEM_REG_TO_MEM  1BF6
EA_MOVE_DEST        1B68
EA_MOVE_SIZE        1BB0
EA_MOVE_SOURCE      1B58
EA_MULS             1F5E
EA_MULS_ADDRESS     1F76
EA_NEG              1E98
EA_NOT              1EA0
EA_SHIFT_CHECK_8    1EDA
EA_SHIFT_COMMA      1F14
EA_SHIFT_DN         1F02
EA_SHIFT_IMMEDIATE  1EF2
EA_SHIFT_MEMORY     1EBE
EA_SHIFT_REGISTER   1EC6
EA_SIGN_EXT_16      2072
EA_SIGN_EXT_32      2088
EA_SUB              1E84
EA_WORD_ADDR        205A
END                 FFFFFE
ENDING              2363
END_ADDRESS1        232C
END_ADDRESS2        2353
END_ERROR           131E
END_INPUT           2496
GET0TO2             2186
GET0TO7             21F2
GET12TO13           212C
GET12TO15           2120
GET3AND4            21CE
GET3TO5             2174
GET3TO8             2224
GET6AND7            21BC
GET6TO11            2236
GET6TO7             2212
GET6TO8             2162
GET8TO11            213E
GET9AND10           21AA
GET9TO11            2150
GETBIT10            2200
GETBIT5             21E0
GETBIT8             2198
GOOD_BUFF           1144
HEX_ASCII_LOOPB     12DA
HEX_ASCII_LOOPL     129A
HEX_ASCII_LOOPW     12BA
HEX_TO_ASCII_B      12D0
HEX_TO_ASCII_L      1290
HEX_TO_ASCII_W      12B0
HIT_ENTER           24A6
HIT_ENTER_MSG       23C5
HT                  9
ILLEGAL             1158
ILLEGAL_DATA        24B2
IMMEDIATE_BTST      13D8
IMM_MODE            7
IMM_REG             4
INTRO_MSG           2282
INTRO_STUFF         2248
INVALID             1288
IS_LETTER           127A
IS_NUMBER           1272
JSR_RTS             145E
LF                  A
LINE_COUNT          24AE
LOAD_BAD_INPUT      1328
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1ABE
MAIN_LOOP           1124
MAKE_LETTER         1308
MAKE_NUMBER         12FC
ODD_ERR             134A
ODD_INPUT           2429
OP_ADD              16A8
OP_ADDQ             15FE
OP_ADD_ADDR         16D2
OP_ADD_ADDRESS_VERSION  1AD2
OP_AND              1996
OP_AS_MEM           19D0
OP_AS_REG           19B2
OP_BRANCH           182A
OP_BRA_CC           186C
OP_BRA_CS           1882
OP_BRA_EQ           18AE
OP_BRA_GE           191C
OP_BRA_GT           1948
OP_BRA_HIGH         1840
OP_BRA_LE           195E
OP_BRA_LOW          1856
OP_BRA_LT           1932
OP_BRA_MI           1906
OP_BRA_NE           1898
OP_BRA_PL           18F0
OP_BRA_VC           18C4
OP_BRA_VS           18DA
OP_BTST             16E6
OP_CHECK_ADDRESS_VERSION  1AC8
OP_CHECK_DATA_SIZE  1AD8
OP_CHECK_DATA_SIZE_ADDR  1AF8
OP_CMP              1A54
OP_CMPI             175C
OP_CMP_ADDR         1A7E
OP_CODE_TREE        135C
OP_DIVS             163A
OP_EOR              1A92
OP_EORI             173C
OP_JSR              1814
OP_LEA              177C
OP_LS_MEM           1A06
OP_LS_REG           19E8
OP_MOVE             15B2
OP_MOVEM            17CA
OP_MOVEM_DATA       17EE
OP_MOVE_DATA        15E4
OP_MULS             1974
OP_NEG              1792
OP_NOT              17AE
OP_ORI              1700
OP_RO_MEM           1A3C
OP_RO_REG           1A1E
OP_RTS              1800
OP_SET_BAD_BUFFER   1AAE
OP_SET_DATA_BYTE    1B0A
OP_SET_DATA_LONG    1B1E
OP_SET_DATA_WORD    1B14
OP_SHIFT_DIRECTION  1B28
OP_SHIFT_LEFT       1B40
OP_SHIFT_RIGHT      1B3A
OP_SUB              166A
OP_SUBI             171C
OP_SUB_ADDR         1694
OP_TAB              1AB4
PROMPT_END          107A
PROMPT_FOR_DATA     119C
PROMPT_START        1024
PROMPT_TO_RERUN     11BA
RERUN_ERR_MSG       1214
RETURN              128C
SINGLE_OPERATOR_CODES  141E
START               1000
START_ADDRESS       22F3
START_ERROR         1314
START_INPUT         248E
VALID_DATA          25F2
VALID_END           10BE
VALID_START         1058
VERIFIED            1282
VERIFY_INPUT        1232
WORD_MODE           7
WORD_REG            0
