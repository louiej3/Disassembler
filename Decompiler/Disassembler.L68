00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 12/3/2014 2:14:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 000022AA             30                  LEA     psychobots1, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 000022F9             33                  LEA     psychobots2, A1     ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 0000234A             36                  LEA     psychobots3, A1     ; Load introduction
0000101E  103C 000E                 37                  MOVE.B  #14, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024  43F9 0000239C             39                  LEA     psychobots4, A1     ; Load introduction
0000102A  103C 000E                 40                  MOVE.B  #14, D0             ; Load task code for display
0000102E  4E4F                      41                  TRAP    #15                 ; Display introduction
00001030  43F9 000023EF             42                  LEA     psychobots5, A1     ; Load introduction
00001036  103C 000E                 43                  MOVE.B  #14, D0             ; Load task code for display
0000103A  4E4F                      44                  TRAP    #15                 ; Display introduction
0000103C  43F9 00002442             45                  LEA     intro_stuff, A1     ; Load introduction
00001042  103C 000E                 46                  MOVE.B  #14, D0             ; Load task code for display
00001046  4E4F                      47                  TRAP    #15                 ; Display introduction
00001048  43F9 0000247D             48                  LEA     intro_msg, A1       ; Load introduction
0000104E  103C 000E                 49                  MOVE.B  #14, D0             ; Load task code for display
00001052  4E4F                      50                  TRAP    #15                 ; Display introduction
00001054  43F9 00002442             51                  LEA     intro_stuff, A1     ; Load introduction
0000105A  103C 000D                 52                  MOVE.B  #13, D0             ; Load task code for display
0000105E  4E4F                      53                  TRAP    #15                 ; Display introduction
00001060                            54                  
00001060                            55  
00001060                            56  *-----------Prompt For Starting Address---------------------                  
00001060  43F9 000024F0             57  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
00001066  103C 000E                 58                  MOVE.B  #14,D0              ; Load task code for display
0000106A  4E4F                      59                  TRAP    #15                 ; Display prompt message
0000106C                            60                  
0000106C  43F9 0000268A             61                  LEA     start_input,A1      ; Load address to store user's input
00001072  103C 0002                 62                  MOVE.B  #2,D0               ; Load task code for user input
00001076  4E4F                      63                  TRAP    #15                 ; Ask for user input
00001078  4EB9 0000126E             64                  JSR     verify_input        ; Verifies user input string
0000107E  B83C 0001                 65                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001082  6700 0010                 66                  BEQ     valid_start         ; Go to valid start if equal 
00001086                            67                  
00001086  43F9 000025F0             68                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
0000108C  103C 000E                 69                  MOVE.B  #14,D0              ; Load task code for display
00001090  4E4F                      70                  TRAP    #15                 ; Display bad input message
00001092  60CC                      71                  BRA     prompt_start        ; Go back beginning, asking for start address
00001094                            72  
00001094  4EB9 00001372             73  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000109A  B67C FFFF                 74                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
0000109E  67C0                      75                  BEQ     prompt_start        ; Go back and ask for correct input
000010A0  7C00                      76                  MOVE.L  #begin,D6           ; Store minimum address in D6
000010A2  B686                      77                  CMP.L   D6,D3               ; If start address is lower than minimum address
000010A4  6D00 02AA                 78                  BLT     start_error         ; Then, start address is too low
000010A8  2C3C 00FFFFFE             79                  MOVE.L  #end,D6             ; Store max end address for comparison
000010AE  B686                      80                  CMP.L   D6,D3               ; If start address is lower than minimum address
000010B0  6E00 029E                 81                  BGT     start_error         ; Then, start address is too high
000010B4  2643                      82                  MOVEA.L D3,A3               ; Load starting address                 
000010B6                            83  
000010B6                            84  *-----------Prompt for Ending Address-----------------------            
000010B6  43F9 00002529             85  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
000010BC  103C 000E                 86                  MOVE.B  #14,D0              ; Load task code for display
000010C0  4E4F                      87                  TRAP    #15                 ; Display prompt message
000010C2  43F9 0000268A             88                  LEA     start_input,A1      ; Load starting address
000010C8  4E4F                      89                  TRAP    #15                 ; Display starting address
000010CA  43F9 00002550             90                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
000010D0  4E4F                      91                  TRAP    #15                 ; Display prompt message
000010D2  43F9 00002692             92                  LEA     end_input,A1        ; Ask for ending address
000010D8  103C 0002                 93                  MOVE.B  #2,D0               ; Load task code for input
000010DC  4E4F                      94                  TRAP    #15                 ; Prompt for input
000010DE  4EB9 0000126E             95                  JSR     verify_input        ; Verifies user input string
000010E4  B83C 0001                 96                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010E8  6700 0010                 97                  BEQ     valid_end           ; Now validate the ending address
000010EC  43F9 000025F0             98                  LEA     badAddr_input,A1        ; Else, bad input
000010F2  103C 000E                 99                  MOVE.B  #14,D0              ; Load task code for display
000010F6  4E4F                     100                  TRAP    #15                 ; Display bad input message
000010F8  60BC                     101                  BRA     prompt_end          ; Restart process
000010FA                           102  
000010FA  4EB9 00001372            103  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
00001100  B67C FFFF                104                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
00001104  67B0                     105                  BEQ     prompt_end          ; Go back and ask for correct input
00001106  2C3C 00FFFFFE            106                  MOVE.L  #end,D6             ; Move max address to compare with input
0000110C  B686                     107                  CMP.L   D6,D3               ; Is input higher than max
0000110E  6E00 024A                108                  BGT     end_error           ; Input address is too high
00001112  B68B                     109                  CMP.L   A3,D3               ; Is input at or above minimum address
00001114  6D00 0244                110                  BLT     end_error           ; Input address is too low
00001118  2843                     111                  MOVEA.L D3,A4               ; Load ending address
0000111A                           112                                 
0000111A                           113  ;-------------- disassemble ---------------------------------------------------
0000111A                           114  ; -- Reads the data from the specified memory locations
0000111A                           115  ; -- Passes the data over to OP-code to verify the instruction
0000111A                           116  ; -- Decodes the word data from the specified memory location until the end
0000111A                           117  ; -- Checks for illegal data and valid data with the bad buffer bit
0000111A                           118  ;------------------------------------------------------------------------------
0000111A  4283                     119  disassemble     CLR.L   D3                  ; Clear for IO usage
0000111C  4284                     120                  CLR.L   D4                  ; Clear for OP Code usage              
0000111E  B7CC                     121                  CMP.L   A4,A3               ; At the end address?
00001120  6E00 00D4                122                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
00001124                           123                  
00001124  4EB9 000011C6            124                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
0000112A  2C0B                     125                  MOVE.L  A3,D6               ; Store current address
0000112C                           126                  
0000112C  4DF9 000026AE            127                  LEA     illegal_data,A6     ; Load illegal data's address
00001132  4EB9 000012CC            128                  JSR     hex_to_ASCII_L      ; Store address to memory for display
00001138  204E                     129                  MOVEA.L A6,A0               ; Store current location of illegal data
0000113A                           130                  
0000113A  4BF9 000027EE            131                  LEA     valid_data,A5       ; Store current address to memory
00001140                           132                  
00001140  4DF9 000027EE            133                  LEA     valid_data,A6       ; Store current address to memory
00001146  4EB9 000012CC            134                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
0000114C  1CFC 0009                135                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001150                           136                  
00001150  381B                     137                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001152  4EB9 00001398            138                  JSR     OP_CODE_TREE        ; Go to OP code jump table
00001158                           139                  
00001158  BE3C 0001                140                  CMP.B   #1,D7               ; Bad buffer set?
0000115C  6700 0036                141                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001160                           142  main_loop
00001160                           143                  ; Store new line in memory
00001160  1CFC 000A                144                  MOVE.B  #LF,(A6)+
00001164  1CFC 000D                145                  MOVE.B  #CR,(A6)+
00001168  BE3C 0001                146                  CMP.B   #1,D7               ; Bad buffer set?
0000116C  6600 0012                147                  BNE     good_buff           ; Good Buffer, go prep for display
00001170                           148                  
00001170  4287                     149  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001172  1CFC 0000                150                  MOVE.B  #00,(A6)+           ; Add null terminator
00001176  43F9 000026AE            151                  LEA     illegal_data,A1     ; Load the illegal data for display
0000117C  6000 000C                152                  BRA     display_data        ; Go to display data
00001180                           153                  
00001180  1CFC 0000                154  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001184  43F9 000027EE            155                  LEA     valid_data,A1       ; Load the valid data for display
0000118A                           156                  
0000118A  4280                     157  display_data    CLR.L   D0                  ; Clear for TASK TRAP
0000118C  103C 000E                158                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001190  4E4F                     159                  TRAP    #15                 ; to in memory.
00001192  6086                     160                  BRA     disassemble         ; Done disassembling the word, next word                
00001194                           161                                                 
00001194                           162  ILLEGAL         ; word data from memory is not a required instruction
00001194  4BF9 000026AE            163                  LEA     illegal_data,A5     ; Store current address to memory
0000119A  2C48                     164                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
0000119C  1CFC 0009                165                  MOVE.B  #HT,(A6)+           ; Store TAB 
000011A0  1CFC 0044                166                  MOVE.B  #'D',(A6)+          ; Store DATA
000011A4  1CFC 0041                167                  MOVE.B  #'A',(A6)+
000011A8  1CFC 0054                168                  MOVE.B  #'T',(A6)+
000011AC  1CFC 0041                169                  MOVE.B  #'A',(A6)+
000011B0  4EB9 00001B04            170                  JSR     OP_TAB              ; Set up third collumn
000011B6  1CFC 0024                171                  MOVE.B  #'$',(A6)+
000011BA                           172                  
000011BA                           173                  ; Store 4 hex digits that represent the word into memory
000011BA  4286                     174                  CLR.L   D6
000011BC  3C04                     175                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
000011BE  4EB9 000012EC            176                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
000011C4  609A                     177                  BRA     main_loop           ; Store info to memory as string              
000011C6                           178  
000011C6                           179  ;------------check_10_lines----------------------------------------------------
000011C6                           180  ; -- Prompt user to hit enter when there are 10 lines of data
000011C6                           181  ; -- Then reset the line count and go back to disassemble more data
000011C6                           182  ;------------------------------------------------------------------------------
000011C6                           183  check_10_lines
000011C6  45F9 000026AA            184                  LEA     line_count,A2       ; Assign A2 pointer for line count
000011CC  5212                     185                  ADD.B   #1,(A2)             ; Increment counter
000011CE  0C12 0014                186                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
000011D2  6700 0004                187                  BEQ     prompt_for_data     ; At 31
000011D6  4E75                     188                  RTS                         ; Return to disassemble
000011D8                           189  
000011D8  43F9 000025C2            190  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011DE  103C 000E                191                  MOVE.B  #14,D0              ; Display message
000011E2  4E4F                     192                  TRAP    #15
000011E4  43F9 000026A2            193                  LEA     hit_enter,A1        ; Take user input
000011EA  103C 0002                194                  MOVE.B  #2,D0               
000011EE  4E4F                     195                  TRAP    #15
000011F0  14BC 0000                196                  MOVE.B  #0,(A2)             ; Reset counter
000011F4  4E75                     197                  RTS                         ; Return to disassemble
000011F6                           198  
000011F6                           199  ;------------prompt_to_rerun----------------------------------------------------
000011F6                           200  ; -- Prompt user to rerun or end program
000011F6                           201  ;------------------------------------------------------------------------------
000011F6  43F9 00002592            202  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011FC  103C 000E                203                  MOVE.B  #14,D0
00001200  4E4F                     204                  TRAP    #15
00001202  43F9 0000269A            205                  LEA     ask_input,A1        ; Take user input
00001208  103C 0002                206                  MOVE.B  #2,D0
0000120C  4E4F                     207                  TRAP    #15
0000120E  45F9 000026AA            208                  LEA     line_count,A2       ; Load line count to reset
00001214  14BC 0000                209                  MOVE.B  #0,(A2)             ; Reset the line_count
00001218  B23C 0001                210                  CMP.B   #1,D1               ; User input must be the length of 1
0000121C  6E00 0032                211                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
00001220  6D00 002E                212                  BLT     rerun_err_msg       ; until the user inputs correctly.
00001224  4240                     213                  CLR     D0                  ; Clear D0 for comparison
00001226  1039 0000269A            214                  MOVE.B  ask_input,D0        ; Load user input for comparison
0000122C  B03C 004E                215                  CMP.B   #'N',D0             ; User input is N
00001230  6700 002C                216                  BEQ     done                ; End of program if N
00001234  B03C 006E                217                  CMP.B   #'n',D0             ; User input is n
00001238  6700 0024                218                  BEQ     done                ; End of program if n
0000123C  B03C 0059                219                  CMP.B   #'Y',D0             ; User input is Y
00001240  6700 FE1E                220                  BEQ     prompt_start        ; Run the program again
00001244  B03C 0079                221                  CMP.B   #'y',D0             ; User input is y
00001248  6700 FE16                222                  BEQ     prompt_start        ; Run the program again
0000124C  6000 0002                223                  BRA     rerun_err_msg       ; Bad input, prompt user
00001250                           224                  
00001250  43F9 00002652            225  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
00001256  103C 000E                226                  MOVE.B  #14,D0
0000125A  4E4F                     227                  TRAP    #15
0000125C  6098                     228                  BRA     prompt_to_rerun     ; Prompt user for rerun           
0000125E                           229                  
0000125E                           230      
0000125E                           231  ;------------End-of-Program----------------------------------------------------                
0000125E  43F9 00002560            232  done            LEA     ending,A1           ; Load ending message
00001264  103C 000D                233                  MOVE.B  #13,D0              ; Load task code for display
00001268  4E4F                     234                  TRAP    #15                 ; Display ending message
0000126A  4E72 2700                235                  STOP    #$00002700          ; End of program
0000126E                           236                  
0000126E                           237  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
0000126E  4283                     238  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001270  4285                     239                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001272  B205                     240                  CMP.B   D5,D1               ; Check input length, if lower than one
00001274  6700 004E                241                  BEQ     invalid             ; Its an invalid input
00001278  0C41 0008                242                  CMPI    #$8,D1              ; Check input length, if higher than 8
0000127C  6E00 0046                243                  BGT     invalid             ; Its an invalid input
00001280                           244                  
00001280  4282                     245  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001282  1419                     246                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001284  B405                     247                  CMP.B   D5,D2               ; Check to see if next char is null(0)
00001286  6700 0040                248                  BEQ     return              ; Character is null, end of input
0000128A                           249                  
0000128A  B43C 0046                250                  CMP.B   #70,D2              ; Invalid character if decimal value
0000128E  6E00 0034                251                  BGT     invalid             ; is higher than 70.
00001292  B43C 0040                252                  CMP.B   #64,D2              ; Is a letter if decimal value is 
00001296  6E00 001E                253                  BGT     is_letter           ; between 65 - 70.
0000129A                           254                  
0000129A  B43C 0039                255                  CMP.B   #57,D2              ; Invalid character if decimal value is
0000129E  6E00 0024                256                  BGT     invalid             ; between 58 - 64
000012A2  B43C 002F                257                  CMP.B   #47,D2              ; Is a number if decimal value is 
000012A6  6E00 0006                258                  BGT     is_number           ; between 48 - 57.
000012AA  6000 0018                259                  BRA     invalid             ; Decimal values below 48 are invalid 
000012AE                           260                               
000012AE  0402 0030                261  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
000012B2  6000 000A                262                  BRA     verified            ; Put character into a register
000012B6                           263                               
000012B6  0402 0037                264  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
000012BA  6000 0002                265                  BRA     verified            ; Put character into a register
000012BE                           266                 
000012BE  E983                     267  verified        ASL.L   #4,D3               ; Shift hex bit left one
000012C0  D602                     268                  ADD.B   D2,D3               ; Add to verified register
000012C2  60BC                     269                  BRA     check_input         ; Check the rest of the input                       
000012C4                           270                  
000012C4  7800                     271  invalid         MOVEQ   #0,D4               ; Invalid address
000012C6  4E75                     272                  RTS                         ; Return to start/end prompt
000012C8                           273                  
000012C8  7801                     274  return          MOVEQ   #1,D4               ; Valid address
000012CA  4E75                     275                  RTS                         ; Return to start/end prompt
000012CC                           276                  
000012CC                           277  ;----------------------------------------------------------
000012CC                           278  ; Convert Hexidecimal to ASCII (Stores into Memory)
000012CC                           279  ;
000012CC                           280  ; -- At the moment, takes the Illegal data and stores 
000012CC                           281  ;    it into memory so that it can be printed later
000012CC                           282  ;----------------------------------------------------------
000012CC  4281                     283  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
000012CE  4282                     284                  CLR.L   D2                      ; Used for shifting left
000012D0  4283                     285                  CLR.L   D3                      ; Counter
000012D2  123C 001C                286                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
000012D6                           287  hex_ASCII_loopL
000012D6  B63C 0008                288                  CMP.B   #8,D3                   ; Done converting?
000012DA  6700 0072                289                  BEQ     done_converting         ; If equal to 8, done
000012DE  2006                     290                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E0  E5A8                     291                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012E2  E2A8                     292                  LSR.L   D1,D0                   ; Isolate number
000012E4  4EB9 0000132C            293                  JSR     convert_hex
000012EA  60EA                     294                  BRA     hex_ASCII_loopL
000012EC                           295                  
000012EC  4281                     296  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012EE  4282                     297                  CLR.L   D2                      ; Used for shifting left
000012F0  4283                     298                  CLR.L   D3                      ; Counter
000012F2  123C 000C                299                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012F6                           300  hex_ASCII_loopW
000012F6  B63C 0004                301                  CMP.B   #4,D3                   ; Done converting?
000012FA  6700 0052                302                  BEQ     done_converting         ; If equal to 4, done
000012FE  2006                     303                  MOVE.L  D6,D0                   ; Do calculations in D0
00001300  E568                     304                  LSL.W   D2,D0                   ; Eliminate stuff to the left
00001302  E268                     305                  LSR.W   D1,D0                   ; Isolate number
00001304  4EB9 0000132C            306                  JSR     convert_hex
0000130A  60EA                     307                  BRA     hex_ASCII_loopW
0000130C                           308  
0000130C  4281                     309  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
0000130E  4282                     310                  CLR.L   D2                      ; Used for shifting left
00001310  4283                     311                  CLR.L   D3                      ; Counter
00001312  123C 0004                312                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
00001316                           313  hex_ASCII_loopB
00001316  B63C 0002                314                  CMP.B   #2,D3                   ; Done converting?
0000131A  6700 0032                315                  BEQ     done_converting         ; If equal to 2, done
0000131E  2006                     316                  MOVE.L  D6,D0                   ; Do calculations in D0
00001320  E528                     317                  LSL.B   D2,D0                   ; Eliminate stuff to the left
00001322  E228                     318                  LSR.B   D1,D0                   ; Isolate number
00001324  4EB9 0000132C            319                  JSR     convert_hex
0000132A  60EA                     320                  BRA     hex_ASCII_loopB                  
0000132C                           321  
0000132C  B03C 000A                322  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
00001330  6D00 0006                323                  BLT     make_number             ; Make it a number, if lower than 10
00001334  6C00 000E                324                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
00001338                           325                       
00001338  0600 0030                326  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
0000133C  1CC0                     327                  MOVE.B  D0,(A6)+                ; Store in memory
0000133E  5203                     328                  ADD.B   #1,D3                   ; Add to counter
00001340  5802                     329                  ADD.B   #4,D2                   ; Shift left by one digit
00001342  4E75                     330                  RTS                             ; Check next number
00001344                           331                  
00001344  0600 0037                332  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
00001348  1CC0                     333                  MOVE.B  D0,(A6)+                ; Store to memory
0000134A  5203                     334                  ADD.B   #1,D3                   ; Add to counter
0000134C  5802                     335                  ADD.B   #4,D2                   ; Shift left by one digit                 
0000134E  4E75                     336  done_converting RTS                             ; Check next number              
00001350                           337  
00001350                           338  ;-----------Error Messages ----------------------------------------------------
00001350  4EB9 00001364            339  start_error     JSR     load_bad_input      ; Print bad input error message
00001356  4EF8 1060                340                  JMP     prompt_start        ; Return to prompt for start address
0000135A                           341                  
0000135A  4EB9 00001364            342  end_error       JSR     load_bad_input      ; Print bad input error message
00001360  4EF8 10B6                343                  JMP     prompt_end          ; Return to prompt for end address
00001364                           344  
00001364  43F9 000025F0            345  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000136A  103C 000D                346                  MOVE.B  #13,D0              ; Load task code for display
0000136E  4E4F                     347                  TRAP    #15                 ; Display bad input message
00001370  4E75                     348                  RTS                         ; Return to (start/end)_error
00001372                           349  
00001372  4282                     350  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001374  3403                     351                  MOVE.W  D3,D2               ; Put address in D2 for calulation
00001376  7202                     352                  MOVE.L  #2,D1               ; Load 2 into D1 for division
00001378  84C1                     353                  DIVU    D1,D2               ; Divide address by 2
0000137A  4842                     354                  SWAP    D2                  ; Swap contents of D2 to get remainder
0000137C  B43C 0001                355                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001380  6700 0004                356                  BEQ     odd_err             ; Go to print out odd bound error message
00001384  4E75                     357                  RTS                         ; Return to valid_(start/end)
00001386                           358                  
00001386  43F9 00002626            359  odd_err         LEA     odd_input,A1        ; Load odd input message
0000138C  103C 000E                360                  MOVE.B  #14,D0              ; Load task code for display
00001390  4E4F                     361                  TRAP    #15                 ; Display odd input message
00001392  4685                     362                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001394  2605                     363                  MOVE.L  D5,D3               ; Load -1 to returned data register
00001396  4E75                     364                  RTS                         ; Return to valid_(start/end)
00001398                           365  
00001398                           366  OP_CODE_TREE    ; Parses the Op-Code to find what it is
00001398                           367          
00001398  B8BC 00004E75            368          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
0000139E  6700 04B0                369          Beq     OP_RTS
000013A2                           370  
000013A2  4EB9 00002170            371          Jsr     GET12TO15
000013A8                           372          
000013A8  B03C 0000                373          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
000013AC  6700 0066                374          Beq     IMMEDIATE_BTST
000013B0                           375          
000013B0  B03C 0001                376          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
000013B4  6700 0230                377          Beq     OP_MOVE
000013B8                           378          
000013B8  B03C 0003                379          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
000013BC  6700 0228                380          Beq     OP_MOVE
000013C0                           381  
000013C0  B03C 0002                382          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
000013C4  6700 0220                383          Beq     OP_MOVE
000013C8                           384          
000013C8  B03C 0004                385          Cmp.B     #%0100, D0       ; not enough info, Single OPs
000013CC  6700 008C                386          Beq     SINGLE_OPERATOR_CODES
000013D0                           387      
000013D0  B03C 0006                388          Cmp.B     #%0110, D0       ; Beqnch conditionals
000013D4  6700 00D6                389          Beq     BRANCH_CONDITIONALS
000013D8                           390          
000013D8  B03C 000C                391          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013DC  6700 0150                392          Beq     AND_MULS
000013E0                           393          
000013E0  B03C 000E                394          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013E4  6700 0188                395          Beq     BIT_SHIFT
000013E8                           396          
000013E8  B03C 0005                397          Cmp.B     #%0101, D0       ; Add Quick
000013EC  6700 0244                398          Beq     OP_ADDQ
000013F0                           399          
000013F0  B03C 0008                400          Cmp.B     #%1000, D0       ; Signed Divide
000013F4  6700 0278                401          Beq     OP_DIVS
000013F8                           402          
000013F8  B03C 0009                403          Cmp.B     #%1001, D0       ; Sub & SubA
000013FC  6700 02A0                404          Beq     OP_SUB
00001400                           405          
00001400  B03C 000B                406          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
00001404  6700 01BE                407          Beq     CMP_EOR
00001408                           408          
00001408  B03C 000D                409          Cmp.B     #%1101, D0       ; Add & AddA
0000140C  6700 02CE                410          Beq     OP_ADD
00001410                           411          
00001410  6000 06EC                412          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
00001414                           413          
00001414                           414  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
00001414                           415          
00001414  4EB9 000021B2            416          Jsr     GET6TO8         ; Change out test bits
0000141A                           417          
0000141A  B03C 0004                418          Cmp.B     #%100, D0          ; Bit test
0000141E  6700 02FA                419          Beq     OP_BTST
00001422                           420          
00001422  4EB9 00002298            421          Jsr     GET6TO11
00001428                           422          
00001428  B03C 0020                423          Cmp.B   #%100000,D0     ;BTST
0000142C  6700 02EC                424          Beq     OP_BTST
00001430                           425          
00001430  4EB9 000021A0            426          Jsr     GET9TO11        ; Change out test bits
00001436                           427          
00001436  B03C 0000                428          Cmp.B     #%000, D0        ; Or I
0000143A  6700 02F8                429          Beq     OP_ORI
0000143E                           430          
0000143E  B03C 0002                431          Cmp.B     #%010, D0        ; Subtract I
00001442  6700 030C                432          Beq     OP_SUBI
00001446                           433          
00001446  B03C 0005                434          Cmp.B     #%101, D0        ; Exclusive or, I
0000144A  6700 0324                435          Beq     OP_EORI
0000144E                           436          
0000144E  B03C 0006                437          Cmp.B     #%110, D0        ; Compare I
00001452  6700 033C                438          Beq     OP_CMPI
00001456                           439          
00001456  6000 06A6                440          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
0000145A                           441          
0000145A                           442  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
0000145A                           443  
0000145A  4EB9 000021E8            444          Jsr     GETBIT8        ; Change out test bits
00001460                           445          
00001460  B03C 0001                446          Cmp.B     #%1, D0      ; Load effetive address
00001464  6700 034A                447          Beq     OP_LEA
00001468                           448                  
00001468  4EB9 000021A0            449          Jsr     GET9TO11       ; Change out test bits        
0000146E                           450  
0000146E  B03C 0002                451          Cmp.B     #%010, D0    ; Negate
00001472  6700 0352                452          Beq     OP_NEG
00001476                           453         
00001476  B03C 0003                454          Cmp.B     #%011, D0    ; Not
0000147A  6700 0366                455          Beq     OP_NOT
0000147E                           456          
0000147E  B03C 0004                457          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001482  6700 037A                458          Beq     OP_MOVEM
00001486                           459          
00001486  B03C 0006                460          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
0000148A  6700 0372                461          Beq     OP_MOVEM
0000148E                           462          
0000148E  B03C 0007                463          Cmp.B     #%111, D0    ; JSR
00001492  6700 0006                464          Beq     JSR_CHECK   ; A second check for JSR   
00001496                           465          
00001496  6000 0666                466          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
0000149A                           467  
0000149A                           468  JSR_CHECK     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
0000149A                           469  
0000149A  4EB9 000021B2            470          Jsr     GET6TO8        ; Change out test bits
000014A0                           471          
000014A0  B03C 0002                472          Cmp.B     #%010, D0    ; Jump to Subroutine
000014A4  6700 03BE                473          Beq     OP_JSR
000014A8                           474          
000014A8  6000 0654                475          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
000014AC                           476  
000014AC                           477  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
000014AC                           478  
000014AC  4EB9 0000218E            479          Jsr     GET8TO11    ; Change out test bits        
000014B2                           480  
000014B2  B03C 0000                481          Cmp.B     #%0000, D0   ; Branch
000014B6  6700 03C2                482          Beq     OP_BRANCH      
000014BA                           483          
000014BA  B03C 0002                484          Cmp.B     #%0010, D0   ; High
000014BE  6700 03D0                485          Beq     OP_BRA_HIGH
000014C2                           486          
000014C2  B03C 0003                487          Cmp.B     #%0011, D0   ; Low/same
000014C6  6700 03DE                488          Beq     OP_BRA_LOW
000014CA                           489          
000014CA  B03C 0004                490          Cmp.B     #%0100, D0   ; Carry Clear
000014CE  6700 03EC                491          Beq     OP_BRA_CC
000014D2                           492          
000014D2  B03C 0005                493          Cmp.B     #%0101, D0   ; Carry Set
000014D6  6700 03FA                494          Beq     OP_BRA_CS
000014DA                           495          
000014DA  B03C 0006                496          Cmp.B     #%0110, D0   ; Not Equal
000014DE  6700 0408                497          Beq     OP_BRA_NE
000014E2                           498          
000014E2  B03C 0007                499          Cmp.B     #%0111, D0   ; Equal
000014E6  6700 0416                500          Beq     OP_BRA_EQ
000014EA                           501          
000014EA  B03C 0008                502          Cmp.B     #%1000, D0   ; Overflow Clear
000014EE  6700 0424                503          Beq     OP_BRA_VC
000014F2                           504          
000014F2  B03C 0009                505          Cmp.B     #%1001, D0   ; Overflow Set
000014F6  6700 0432                506          Beq     OP_BRA_VS
000014FA                           507          
000014FA  B03C 000A                508          Cmp.B     #%1010, D0   ; Plus
000014FE  6700 0440                509          Beq     OP_BRA_PL
00001502                           510          
00001502  B03C 000B                511          Cmp.B     #%1011, D0   ; Minus
00001506  6700 044E                512          Beq     OP_BRA_MI
0000150A                           513          
0000150A  B03C 000C                514          Cmp.B     #%1100, D0   ; Greater than or Equal
0000150E  6700 045C                515          Beq     OP_BRA_GE
00001512                           516          
00001512  B03C 000D                517          Cmp.B     #%1101, D0   ; Less Than
00001516  6700 046A                518          Beq     OP_BRA_LT
0000151A                           519          
0000151A  B03C 000E                520          Cmp.B     #%1110, D0   ; Greater Than
0000151E  6700 0478                521          Beq     OP_BRA_GT
00001522                           522          
00001522  B03C 000F                523          Cmp.B     #%1111, D0   ; Less than or Equal
00001526  6700 0486                524          Beq     OP_BRA_LE
0000152A                           525          
0000152A  6000 05D2                526          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
0000152E                           527  
0000152E                           528  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
0000152E                           529  
0000152E  4EB9 00002286            530          Jsr     Get3TO8
00001534                           531          
00001534  B03C 0021                532          Cmp.B     #%100001, D0   ; ABCD
00001538  6700 05C4                533          Beq     OP_SET_BAD_BUFFER        
0000153C  B03C 0020                534          Cmp.B     #%100000,D0    ; ABCD
00001540  6700 05BC                535          Beq     OP_SET_BAD_BUFFER        
00001544  B03C 0028                536          Cmp.B     #%101000,D0    ; EXG
00001548  6700 05B4                537          Beq     OP_SET_BAD_BUFFER
0000154C  B03C 0029                538          Cmp.B     #%101001,D0    ; EXG
00001550  6700 05AC                539          Beq     OP_SET_BAD_BUFFER
00001554  B03C 0031                540          Cmp.B     #%110001,D0    ; EXG
00001558  6700 FC3A                541          Beq     ILLEGAL        
0000155C                           542  
0000155C  4EB9 000021B2            543          Jsr     GET6TO8        ; Change out test bits        
00001562                           544  
00001562  B03C 0007                545          Cmp.B     #%111, D0    ; Multiply signed
00001566  6700 045C                546          Beq     OP_MULS
0000156A                           547          
0000156A  6000 047A                548          Bra     OP_AND      ; Probably AND, check more in OP_AND
0000156E                           549          
0000156E                           550  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
0000156E                           551          
0000156E                           552          ; Determine if the shift is Register or Memory shifting
0000156E                           553          
0000156E  4EB9 0000220C            554          Jsr     GET6AND7
00001574                           555          
00001574  B03C 0003                556          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
00001578  6700 0006                557          Beq     BIT_SHIFT_MEM
0000157C                           558  
0000157C  6000 0024                559          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
00001580                           560  
00001580                           561  BIT_SHIFT_MEM
00001580                           562          
00001580  4EB9 000021FA            563          Jsr     GET9AND10         ; Change out test bits
00001586                           564          
00001586  B03C 0000                565          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
0000158A  6700 0494                566          Beq     OP_AS_MEM
0000158E                           567          
0000158E  B03C 0001                568          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
00001592  6700 04C2                569          Beq     OP_LS_MEM
00001596                           570          
00001596  B03C 0003                571          Cmp.B     #%11, D0        ; Rotate (Left or Right)
0000159A  6700 04F0                572          Beq     OP_RO_MEM
0000159E                           573          
0000159E  6000 055E                574          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
000015A2                           575  
000015A2                           576  BIT_SHIFT_REG
000015A2                           577          
000015A2  4EB9 00002230            578          Jsr     GET3AND4        ; Change out test bits
000015A8                           579          
000015A8  B03C 0000                580          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
000015AC  6700 0454                581          Beq     OP_AS_REG
000015B0                           582          
000015B0  B03C 0001                583          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
000015B4  6700 0482                584          Beq     OP_LS_REG
000015B8                           585          
000015B8  B03C 0003                586          Cmp.B     #%11, D0        ; Rotate (Left or Right)
000015BC  6700 04B0                587          Beq     OP_RO_REG
000015C0                           588          
000015C0  6000 053C                589          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
000015C4                           590  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
000015C4                           591          
000015C4  4EB9 000021B2            592          Jsr     GET6TO8         ; Change out test bits
000015CA                           593          
000015CA  B03C 0004                594          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
000015CE  6700 0512                595          Beq     OP_EOR
000015D2                           596          
000015D2  B03C 0005                597          Cmp.B     #%101,D0
000015D6  6700 050A                598          Beq     OP_EOR
000015DA                           599          
000015DA  B03C 0006                600          Cmp.B     #%110,D0
000015DE  6700 0502                601          Beq     OP_EOR
000015E2                           602          
000015E2                           603          
000015E2  6000 04C0                604          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015E6                           605  
000015E6                           606  ;---------------------OP_CODE Functions---------------------;
000015E6                           607  ; These Functions have all determined what Op-code or group
000015E6                           608  ; of op-codes I have. The next goal is to Add to the string
000015E6                           609  ; and call the accompying EA function to get the rest of the
000015E6                           610  ; String
000015E6                           611  
000015E6                           612  ; REGISTERS USED: D0, D4 (const), A6
000015E6                           613  
000015E6                           614  ;-----------------------  MOVE  -----------------------------;
000015E6                           615  OP_MOVE
000015E6                           616      ; start string
000015E6                           617      
000015E6  1CFC 004D                618          Move.B  #'M', (A6)+
000015EA  1CFC 004F                619          Move.B  #'O', (A6)+
000015EE  1CFC 0056                620          Move.B  #'V', (A6)+
000015F2  1CFC 0045                621          Move.B  #'E', (A6)+
000015F6                           622      
000015F6                           623      ; is it an address move?
000015F6  4EB9 000021B2            624          Jsr     GET6TO8     ; Get the mode
000015FC  4EB9 00001B18            625          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
00001602                           626          
00001602                           627      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
00001602                           628      ; But move does not use the Op-mode bits, so i'll do it manually
00001602                           629      
00001602  4EB9 00002170            630          Jsr     GET12TO15
00001608                           631  
00001608                           632          ; Jump to a sub routine to get the data, so it returns back correctly
00001608  4EB9 00001618            633          Jsr     OP_MOVE_DATA
0000160E                           634          
0000160E                           635          ; Put in tabs
0000160E  4EB9 00001B04            636          Jsr     OP_TAB
00001614                           637          
00001614                           638          ; Hand the function off to John
00001614  6000 0580                639          BRA     EA_MOVE        
00001618                           640  
00001618                           641  OP_MOVE_DATA
00001618                           642          
00001618  B07C 0001                643          Cmp     #%0001, D0
0000161C  6700 053C                644          Beq     OP_SET_DATA_BYTE
00001620                           645          
00001620  B07C 0002                646          Cmp     #%0010, D0
00001624  6700 0548                647          Beq     OP_SET_DATA_LONG
00001628                           648          
00001628  B07C 0003                649          Cmp     #%0011, D0
0000162C  6700 0536                650          Beq     OP_SET_DATA_WORD
00001630                           651          
00001630  4E75                     652          Rts
00001632                           653  
00001632                           654  ;-----------------------  ADDQ  -----------------------------;
00001632                           655          
00001632                           656  OP_ADDQ
00001632                           657      ; Check fringe cases
00001632  4EB9 000021E8            658          Jsr     GETBIT8
00001638  B03C 0001                659          Cmp.B   #%1,D0
0000163C  6700 04C0                660          Beq     OP_SET_BAD_BUFFER        
00001640  4EB9 0000220C            661          Jsr     GET6AND7
00001646  B03C 0003                662          Cmp.B   #%11,D0
0000164A  6700 04B2                663          Beq     OP_SET_BAD_BUFFER       
0000164E                           664  
0000164E                           665      ; start string
0000164E                           666      
0000164E  1CFC 0041                667          Move.B  #'A', (A6)+
00001652  1CFC 0044                668          Move.B  #'D', (A6)+
00001656  1CFC 0044                669          Move.B  #'D', (A6)+
0000165A  1CFC 0051                670          Move.B  #'Q', (A6)+
0000165E                           671          
0000165E                           672      ; Check data type        
0000165E  4EB9 00001B28            673          Jsr     OP_CHECK_DATA_SIZE
00001664                           674          
00001664                           675      ; Put in tabs
00001664  4EB9 00001B04            676          Jsr     OP_TAB
0000166A                           677          
0000166A                           678      ; Hand the function off to John
0000166A  6000 082A                679          BRA     EA_ADDQ
0000166E                           680  
0000166E                           681      
0000166E                           682  ;------------------  DIVIDE SINGED  -------------------------;
0000166E                           683      
0000166E                           684  OP_DIVS
0000166E                           685      ; One last check to make sure I have the right stuff
0000166E                           686      
0000166E  4EB9 000021B2            687          Jsr     GET6TO8
00001674  B07C 0007                688          Cmp     #%111,D0
00001678  6600 0484                689          Bne     OP_SET_BAD_BUFFER
0000167C                           690          
0000167C                           691      ; start string
0000167C                           692      
0000167C  1CFC 0044                693          Move.B  #'D', (A6)+
00001680  1CFC 0049                694          Move.B  #'I', (A6)+
00001684  1CFC 0056                695          Move.B  #'V', (A6)+
00001688  1CFC 0053                696          Move.B  #'S', (A6)+
0000168C  1CFC 002E                697          Move.B  #'.', (A6)+
00001690  1CFC 0057                698          Move.B  #'W', (A6)+
00001694                           699          
00001694                           700      ; Put in tabs
00001694  4EB9 00001B04            701          Jsr     OP_TAB    
0000169A                           702      
0000169A                           703      ; Handoff to John
0000169A                           704          
0000169A  6000 093A                705          BRA     EA_DIVS
0000169E                           706  
0000169E                           707      
0000169E                           708  ;-----------------------  SUB  ------------------------------;    
0000169E                           709      
0000169E                           710  OP_SUB
0000169E                           711      ; start string
0000169E                           712      
0000169E  1CFC 0053                713          Move.B  #'S', (A6)+
000016A2  1CFC 0055                714          Move.B  #'U', (A6)+
000016A6  1CFC 0042                715          Move.B  #'B', (A6)+
000016AA                           716  
000016AA                           717  
000016AA                           718       ; Check for address version
000016AA                           719          
000016AA  4EB9 0000220C            720          Jsr     GET6AND7
000016B0  B03C 0003                721          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016B4                           722          
000016B4  6700 0012                723          Beq     OP_SUB_ADDR
000016B8                           724  
000016B8                           725          ; Don't need to worry about ADDA in V1
000016B8                           726          ; Check data size
000016B8  4EB9 00001B28            727          Jsr     OP_CHECK_DATA_SIZE
000016BE                           728          
000016BE                           729          ; Put in tabs
000016BE  4EB9 00001B04            730          Jsr     OP_TAB
000016C4                           731          
000016C4  6000 080E                732          BRA     EA_SUB 
000016C8                           733          
000016C8                           734  OP_SUB_ADDR
000016C8                           735          
000016C8  1CFC 0041                736          Move.B  #'A',(A6)+ ; add to the string
000016CC                           737          
000016CC                           738          ; Find data size
000016CC                           739          
000016CC  4EB9 00001B48            740          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016D2                           741          
000016D2                           742          ; Put in tabs
000016D2  4EB9 00001B04            743          Jsr     OP_TAB
000016D8                           744          
000016D8                           745          ; Handoff
000016D8  6000 07FA                746          BRA     EA_SUB
000016DC                           747          
000016DC                           748  ;-----------------------  ADD  ------------------------------;
000016DC                           749  
000016DC                           750  OP_ADD
000016DC                           751      ; start string
000016DC                           752      
000016DC  1CFC 0041                753          Move.B  #'A', (A6)+
000016E0  1CFC 0044                754          Move.B  #'D', (A6)+
000016E4  1CFC 0044                755          Move.B  #'D', (A6)+
000016E8                           756  
000016E8                           757      ; Check for address version
000016E8                           758          
000016E8  4EB9 0000220C            759          Jsr     GET6AND7
000016EE  B03C 0003                760          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016F2                           761          
000016F2  6700 0012                762          Beq     OP_ADD_ADDR
000016F6                           763          
000016F6                           764          ; Don't need to worry about ADDA in V1
000016F6                           765          ; Check data size
000016F6  4EB9 00001B28            766          Jsr     OP_CHECK_DATA_SIZE
000016FC                           767          
000016FC                           768          ; Put in tabs
000016FC  4EB9 00001B04            769          Jsr     OP_TAB
00001702                           770          
00001702  6000 06D6                771          BRA     EA_ADD
00001706                           772          
00001706                           773  OP_ADD_ADDR
00001706                           774          
00001706  1CFC 0041                775          Move.B  #'A',(A6)+ ; add to the string
0000170A                           776          
0000170A                           777          ; Find data size
0000170A                           778          
0000170A  4EB9 00001B48            779          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001710                           780          
00001710                           781          ; Put in tabs
00001710  4EB9 00001B04            782          Jsr     OP_TAB
00001716                           783          
00001716                           784          ; Handoff
00001716  6000 06F6                785          BRA     EA_ADDA
0000171A                           786  
0000171A                           787  ;------------------------  BTST -----------------------------;
0000171A                           788  
0000171A                           789  OP_BTST
0000171A                           790      ; start string
0000171A                           791      
0000171A  1CFC 0042                792          Move.B  #'B', (A6)+
0000171E  1CFC 0054                793          Move.B  #'T', (A6)+
00001722  1CFC 0053                794          Move.B  #'S', (A6)+
00001726  1CFC 0054                795          Move.B  #'T', (A6)+
0000172A                           796          
0000172A                           797      ; Btst has data sizes, but they are implicit based on mode
0000172A                           798          
0000172A                           799      ; Put in tabs
0000172A  4EB9 00001B04            800          Jsr     OP_TAB
00001730                           801          
00001730                           802      ; Hand the function off to John
00001730  6000 08A8                803          BRA     EA_BTST
00001734                           804  
00001734                           805  
00001734                           806  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
00001734                           807  
00001734                           808  ;------------------------  ORI  -----------------------------;
00001734                           809      
00001734                           810  OP_ORI
00001734                           811      ; start string
00001734                           812      
00001734  1CFC 004F                813          Move.B  #'O', (A6)+
00001738  1CFC 0052                814          Move.B  #'R', (A6)+
0000173C  1CFC 0049                815          Move.B  #'I', (A6)+
00001740                           816          
00001740                           817      ; Check data type        
00001740  4EB9 00001B28            818          Jsr     OP_CHECK_DATA_SIZE
00001746                           819          
00001746                           820      ; Put in tabs
00001746  4EB9 00001B04            821          Jsr     OP_TAB
0000174C                           822          
0000174C                           823      ; Hand the function off to John
0000174C  6000 0828                824          BRA     EA_IMMEDIATE
00001750                           825  
00001750                           826  ;-----------------------  SUBI  -----------------------------;
00001750                           827  
00001750                           828  OP_SUBI
00001750                           829      ; start string
00001750                           830      
00001750  1CFC 0053                831          Move.B  #'S', (A6)+
00001754  1CFC 0055                832          Move.B  #'U', (A6)+
00001758  1CFC 0042                833          Move.B  #'B', (A6)+
0000175C  1CFC 0049                834          Move.B  #'I', (A6)+
00001760                           835          
00001760                           836      ; Check data type        
00001760  4EB9 00001B28            837          Jsr     OP_CHECK_DATA_SIZE
00001766                           838          
00001766                           839      ; Put in tabs
00001766  4EB9 00001B04            840          Jsr     OP_TAB
0000176C                           841          
0000176C                           842      ; Hand the function off to John
0000176C  6000 0808                843          BRA     EA_IMMEDIATE  
00001770                           844          
00001770                           845  ;-----------------------  EORI  -----------------------------;        
00001770                           846          
00001770                           847  OP_EORI
00001770                           848      ; start string
00001770                           849      
00001770  1CFC 0045                850          Move.B  #'E', (A6)+
00001774  1CFC 004F                851          Move.B  #'O', (A6)+
00001778  1CFC 0052                852          Move.B  #'R', (A6)+
0000177C  1CFC 0049                853          Move.B  #'I', (A6)+
00001780                           854          
00001780                           855      ; Check data type        
00001780  4EB9 00001B28            856          Jsr     OP_CHECK_DATA_SIZE
00001786                           857          
00001786                           858      ; Put in tabs
00001786  4EB9 00001B04            859          Jsr     OP_TAB
0000178C                           860          
0000178C                           861      ; Hand the function off to John
0000178C  6000 07E8                862          BRA     EA_IMMEDIATE  
00001790                           863          
00001790                           864  ;-----------------------  CMPI  -----------------------------;        
00001790                           865          
00001790                           866  OP_CMPI
00001790                           867      ; start string
00001790                           868      
00001790  1CFC 0043                869          Move.B  #'C', (A6)+
00001794  1CFC 004D                870          Move.B  #'M', (A6)+
00001798  1CFC 0050                871          Move.B  #'P', (A6)+
0000179C  1CFC 0049                872          Move.B  #'I', (A6)+
000017A0                           873          
000017A0                           874      ; Check data type        
000017A0  4EB9 00001B28            875          Jsr     OP_CHECK_DATA_SIZE
000017A6                           876          
000017A6                           877      ; Put in tabs
000017A6  4EB9 00001B04            878          Jsr     OP_TAB
000017AC                           879          
000017AC                           880      ; Hand the function off to John
000017AC  6000 07C8                881          BRA     EA_IMMEDIATE  
000017B0                           882          
000017B0                           883  ;-----------------------  LEA  ------------------------------;
000017B0                           884  
000017B0                           885  OP_LEA
000017B0                           886      ; start string
000017B0                           887      
000017B0  1CFC 004C                888          Move.B  #'L', (A6)+
000017B4  1CFC 0045                889          Move.B  #'E', (A6)+
000017B8  1CFC 0041                890          Move.B  #'A', (A6)+
000017BC                           891          
000017BC                           892      ; No data size for LEA
000017BC                           893          
000017BC                           894      ; Put in tabs
000017BC  4EB9 00001B04            895          Jsr     OP_TAB
000017C2                           896          
000017C2                           897      ; Hand the function off to John
000017C2  6000 0718                898          BRA     EA_LEA  
000017C6                           899  
000017C6                           900  ;-----------------------  NEG  ------------------------------;
000017C6                           901  
000017C6                           902  OP_NEG
000017C6                           903      ; start string
000017C6                           904      
000017C6  1CFC 004E                905          Move.B  #'N', (A6)+
000017CA  1CFC 0045                906          Move.B  #'E', (A6)+
000017CE  1CFC 0047                907          Move.B  #'G', (A6)+
000017D2                           908          
000017D2                           909      ; Data size
000017D2  4EB9 00001B28            910          Jsr     OP_CHECK_DATA_SIZE
000017D8                           911          
000017D8                           912      ; Put in tabs
000017D8  4EB9 00001B04            913          Jsr     OP_TAB
000017DE                           914          
000017DE                           915      ; Hand the function off to John
000017DE  6000 0708                916          BRA     EA_NEG  
000017E2                           917  
000017E2                           918      
000017E2                           919  ;-----------------------  NOT  ------------------------------;    
000017E2                           920      
000017E2                           921  OP_NOT
000017E2                           922      ; start string
000017E2                           923      
000017E2  1CFC 004E                924          Move.B  #'N', (A6)+
000017E6  1CFC 004F                925          Move.B  #'O', (A6)+
000017EA  1CFC 0054                926          Move.B  #'T', (A6)+
000017EE                           927          
000017EE                           928      ; Data size
000017EE  4EB9 00001B28            929          Jsr     OP_CHECK_DATA_SIZE
000017F4                           930          
000017F4                           931      ; Put in tabs
000017F4  4EB9 00001B04            932          Jsr     OP_TAB
000017FA                           933          
000017FA                           934      ; Hand the function off to John
000017FA  6000 06F4                935          BRA     EA_NOT
000017FE                           936  
000017FE                           937  ;-------------------  MOVE MULITPLE  ------------------------;
000017FE                           938          
000017FE                           939  OP_MOVEM
000017FE                           940      ; Exception checks
000017FE  4EB9 0000221E            941          Jsr     GET7AND8
00001804  B03C 0001                942          Cmp.B   #%01,D0
00001808  6600 02F4                943          Bne     OP_SET_BAD_BUFFER
0000180C                           944          
0000180C  4EB9 000021C4            945          Jsr     GET3TO5
00001812  B03C 0000                946          Cmp.B   #%000,D0
00001816  6700 02E6                947          Beq     OP_SET_BAD_BUFFER
0000181A                           948  
0000181A                           949      ; start string
0000181A                           950      
0000181A  1CFC 004D                951          Move.B  #'M', (A6)+
0000181E  1CFC 004F                952          Move.B  #'O', (A6)+
00001822  1CFC 0056                953          Move.B  #'V', (A6)+
00001826  1CFC 0045                954          Move.B  #'E', (A6)+
0000182A  1CFC 004D                955          Move.B  #'M', (A6)+        
0000182E                           956  
0000182E                           957      ; Data size has to be checked manually
0000182E  4EB9 0000183E            958          Jsr     OP_MOVEM_DATA
00001834                           959          
00001834                           960      ; Put in tabs
00001834  4EB9 00001B04            961          Jsr     OP_TAB
0000183A                           962          
0000183A                           963      ; Hand the function off to John
0000183A  6000 03E4                964          BRA     EA_MOVEM
0000183E                           965          
0000183E                           966  OP_MOVEM_DATA
0000183E                           967      ; get the size bit
0000183E  4EB9 0000220C            968          Jsr     GET6AND7
00001844                           969          
00001844  B03C 0002                970          Cmp.B   #%10,D0
00001848  6700 031A                971          Beq     OP_SET_DATA_WORD
0000184C                           972          
0000184C  6000 0320                973          Bra     OP_SET_DATA_LONG   
00001850                           974  
00001850                           975  OP_RTS
00001850                           976      ; start string
00001850                           977      
00001850  1CFC 0052                978          Move.B  #'R', (A6)+
00001854  1CFC 0054                979          Move.B  #'T', (A6)+
00001858  1CFC 0053                980          Move.B  #'S', (A6)+
0000185C                           981  
0000185C                           982      ; Put in tabs
0000185C  4EB9 00001B04            983          Jsr     OP_TAB
00001862                           984  
00001862                           985      ; Handoff to Blong
00001862                           986      
00001862  4E75                     987          Rts
00001864                           988          
00001864                           989  ;-----------------------  JSR  ------------------------------;        
00001864                           990          
00001864                           991  OP_JSR
00001864                           992      ; start string
00001864                           993      
00001864  1CFC 004A                994          Move.B  #'J', (A6)+
00001868  1CFC 0053                995          Move.B  #'S', (A6)+
0000186C  1CFC 0052                996          Move.B  #'R', (A6)+
00001870                           997          
00001870                           998      ; No data size
00001870                           999          
00001870                          1000      ; Put in tabs
00001870  4EB9 00001B04           1001          Jsr     OP_TAB
00001876                          1002          
00001876                          1003      ; Hand the function off to John
00001876  6000 067C               1004          BRA     EA_JSR
0000187A                          1005  
0000187A                          1006  ;------------------  BRANCH CONDITIONALS  ------------------------;
0000187A                          1007  
0000187A                          1008  OP_BRANCH
0000187A                          1009      ; start string
0000187A                          1010      
0000187A  1CFC 0042               1011          Move.B  #'B', (A6)+
0000187E  1CFC 0052               1012          Move.B  #'R', (A6)+
00001882  1CFC 0041               1013          Move.B  #'A', (A6)+
00001886                          1014  
00001886                          1015      ; Put in tabs
00001886  4EB9 00001B04           1016          Jsr     OP_TAB
0000188C                          1017  
0000188C                          1018      ; Handoff to John
0000188C                          1019      
0000188C  6000 0796               1020          BRA     EA_BRANCH
00001890                          1021      
00001890                          1022  OP_BRA_HIGH
00001890                          1023      ; start string
00001890                          1024      
00001890  1CFC 0042               1025          Move.B  #'B', (A6)+
00001894  1CFC 0048               1026          Move.B  #'H', (A6)+
00001898  1CFC 0049               1027          Move.B  #'I', (A6)+
0000189C                          1028  
0000189C                          1029      ; Put in tabs
0000189C  4EB9 00001B04           1030          Jsr     OP_TAB
000018A2                          1031  
000018A2                          1032      ; Handoff to John
000018A2                          1033      
000018A2  6000 0780               1034          BRA     EA_BRANCH
000018A6                          1035      
000018A6                          1036  OP_BRA_LOW
000018A6                          1037      ; start string
000018A6                          1038      
000018A6  1CFC 0042               1039          Move.B  #'B', (A6)+
000018AA  1CFC 004C               1040          Move.B  #'L', (A6)+
000018AE  1CFC 0053               1041          Move.B  #'S', (A6)+
000018B2                          1042  
000018B2                          1043      ; Put in tabs
000018B2  4EB9 00001B04           1044          Jsr     OP_TAB
000018B8                          1045  
000018B8                          1046      ; Handoff to John
000018B8                          1047      
000018B8  6000 076A               1048          BRA     EA_BRANCH
000018BC                          1049      
000018BC                          1050  OP_BRA_CC
000018BC                          1051      ; start string
000018BC                          1052      
000018BC  1CFC 0042               1053          Move.B  #'B', (A6)+
000018C0  1CFC 0043               1054          Move.B  #'C', (A6)+
000018C4  1CFC 0043               1055          Move.B  #'C', (A6)+
000018C8                          1056  
000018C8                          1057      ; Put in tabs
000018C8  4EB9 00001B04           1058          Jsr     OP_TAB
000018CE                          1059  
000018CE                          1060      ; Handoff to John
000018CE                          1061      
000018CE  6000 0754               1062          BRA     EA_BRANCH
000018D2                          1063  
000018D2                          1064  OP_BRA_CS
000018D2                          1065      ; start string
000018D2                          1066      
000018D2  1CFC 0042               1067          Move.B  #'B', (A6)+
000018D6  1CFC 0043               1068          Move.B  #'C', (A6)+
000018DA  1CFC 0053               1069          Move.B  #'S', (A6)+
000018DE                          1070  
000018DE                          1071      ; Put in tabs
000018DE  4EB9 00001B04           1072          Jsr     OP_TAB
000018E4                          1073  
000018E4                          1074      ; Handoff to John
000018E4                          1075      
000018E4  6000 073E               1076          BRA     EA_BRANCH
000018E8                          1077  
000018E8                          1078  OP_BRA_NE
000018E8                          1079      ; start string
000018E8                          1080      
000018E8  1CFC 0042               1081          Move.B  #'B', (A6)+
000018EC  1CFC 004E               1082          Move.B  #'N', (A6)+
000018F0  1CFC 0045               1083          Move.B  #'E', (A6)+
000018F4                          1084  
000018F4                          1085      ; Put in tabs
000018F4  4EB9 00001B04           1086          Jsr     OP_TAB
000018FA                          1087  
000018FA                          1088      ; Handoff to John
000018FA                          1089      
000018FA  6000 0728               1090          BRA     EA_BRANCH
000018FE                          1091  
000018FE                          1092  OP_BRA_EQ
000018FE                          1093      ; start string
000018FE                          1094      
000018FE  1CFC 0042               1095          Move.B  #'B', (A6)+
00001902  1CFC 0045               1096          Move.B  #'E', (A6)+
00001906  1CFC 0051               1097          Move.B  #'Q', (A6)+
0000190A                          1098  
0000190A                          1099      ; Put in tabs
0000190A  4EB9 00001B04           1100          Jsr     OP_TAB
00001910                          1101  
00001910                          1102      ; Handoff to John
00001910                          1103      
00001910  6000 0712               1104          BRA     EA_BRANCH
00001914                          1105  
00001914                          1106  OP_BRA_VC
00001914                          1107      ; start string
00001914                          1108      
00001914  1CFC 0042               1109          Move.B  #'B', (A6)+
00001918  1CFC 0056               1110          Move.B  #'V', (A6)+
0000191C  1CFC 0043               1111          Move.B  #'C', (A6)+
00001920                          1112  
00001920                          1113      ; Put in tabs
00001920  4EB9 00001B04           1114          Jsr     OP_TAB
00001926                          1115  
00001926                          1116      ; Handoff to John
00001926                          1117      
00001926  6000 06FC               1118          BRA     EA_BRANCH
0000192A                          1119  
0000192A                          1120  OP_BRA_VS
0000192A                          1121      ; start string
0000192A                          1122      
0000192A  1CFC 0042               1123          Move.B  #'B', (A6)+
0000192E  1CFC 0056               1124          Move.B  #'V', (A6)+
00001932  1CFC 0053               1125          Move.B  #'S', (A6)+
00001936                          1126  
00001936                          1127      ; Put in tabs
00001936  4EB9 00001B04           1128          Jsr     OP_TAB
0000193C                          1129  
0000193C                          1130      ; Handoff to John
0000193C                          1131      
0000193C  6000 06E6               1132          BRA     EA_BRANCH
00001940                          1133  
00001940                          1134  OP_BRA_PL
00001940                          1135      ; start string
00001940                          1136      
00001940  1CFC 0042               1137          Move.B  #'B', (A6)+
00001944  1CFC 0050               1138          Move.B  #'P', (A6)+
00001948  1CFC 004C               1139          Move.B  #'L', (A6)+
0000194C                          1140  
0000194C                          1141      ; Put in tabs
0000194C  4EB9 00001B04           1142          Jsr     OP_TAB
00001952                          1143  
00001952                          1144      ; Handoff to John
00001952                          1145      
00001952  6000 06D0               1146          BRA     EA_BRANCH
00001956                          1147  
00001956                          1148  OP_BRA_MI
00001956                          1149      ; start string
00001956                          1150      
00001956  1CFC 0042               1151          Move.B  #'B', (A6)+
0000195A  1CFC 004D               1152          Move.B  #'M', (A6)+
0000195E  1CFC 0049               1153          Move.B  #'I', (A6)+
00001962                          1154  
00001962                          1155      ; Put in tabs
00001962  4EB9 00001B04           1156          Jsr     OP_TAB
00001968                          1157  
00001968                          1158      ; Handoff to John
00001968                          1159      
00001968  6000 06BA               1160          BRA     EA_BRANCH
0000196C                          1161  
0000196C                          1162  OP_BRA_GE
0000196C                          1163      ; start string
0000196C                          1164      
0000196C  1CFC 0042               1165          Move.B  #'B', (A6)+
00001970  1CFC 0047               1166          Move.B  #'G', (A6)+
00001974  1CFC 0045               1167          Move.B  #'E', (A6)+
00001978                          1168  
00001978                          1169      ; Put in tabs
00001978  4EB9 00001B04           1170          Jsr     OP_TAB
0000197E                          1171  
0000197E                          1172      ; Handoff to John
0000197E                          1173      
0000197E  6000 06A4               1174          BRA     EA_BRANCH
00001982                          1175  
00001982                          1176  OP_BRA_LT
00001982                          1177      ; start string
00001982                          1178      
00001982  1CFC 0042               1179          Move.B  #'B', (A6)+
00001986  1CFC 004C               1180          Move.B  #'L', (A6)+
0000198A  1CFC 0054               1181          Move.B  #'T', (A6)+
0000198E                          1182  
0000198E                          1183      ; Put in tabs
0000198E  4EB9 00001B04           1184          Jsr     OP_TAB
00001994                          1185  
00001994                          1186      ; Handoff to John
00001994                          1187      
00001994  6000 068E               1188          BRA     EA_BRANCH
00001998                          1189  
00001998                          1190  OP_BRA_GT
00001998                          1191      ; start string
00001998                          1192      
00001998  1CFC 0042               1193          Move.B  #'B', (A6)+
0000199C  1CFC 0047               1194          Move.B  #'G', (A6)+
000019A0  1CFC 0054               1195          Move.B  #'T', (A6)+
000019A4                          1196  
000019A4                          1197      ; Put in tabs
000019A4  4EB9 00001B04           1198          Jsr     OP_TAB
000019AA                          1199  
000019AA                          1200      ; Handoff to John
000019AA                          1201      
000019AA  6000 0678               1202          BRA     EA_BRANCH
000019AE                          1203  
000019AE                          1204  OP_BRA_LE
000019AE                          1205      ; start string
000019AE                          1206      
000019AE  1CFC 0042               1207          Move.B  #'B', (A6)+
000019B2  1CFC 004C               1208          Move.B  #'L', (A6)+
000019B6  1CFC 0045               1209          Move.B  #'E', (A6)+
000019BA                          1210  
000019BA                          1211      ; Put in tabs
000019BA  4EB9 00001B04           1212          Jsr     OP_TAB
000019C0                          1213  
000019C0                          1214      ; Handoff to John
000019C0                          1215      
000019C0  6000 0662               1216          BRA     EA_BRANCH
000019C4                          1217  
000019C4                          1218  ;------------------  Multiply Singed ----------------------;    
000019C4                          1219  
000019C4                          1220  OP_MULS
000019C4                          1221      ; MULS only has one format, and that data size of word, so I don't need
000019C4                          1222      ; a very intelligent system
000019C4                          1223      
000019C4  1CFC 004D               1224          Move.B  #'M', (A6)+
000019C8  1CFC 0055               1225          Move.B  #'U', (A6)+
000019CC  1CFC 004C               1226          Move.B  #'L', (A6)+
000019D0  1CFC 0053               1227          Move.B  #'S', (A6)+
000019D4  1CFC 002E               1228          Move.B  #'.', (A6)+
000019D8  1CFC 0057               1229          Move.B  #'W', (A6)+
000019DC                          1230  
000019DC                          1231      ; Put in tabs
000019DC  4EB9 00001B04           1232          Jsr     OP_TAB       
000019E2                          1233      
000019E2                          1234      ; Give to john
000019E2                          1235      
000019E2  6000 05CA               1236          BRA     EA_MULS
000019E6                          1237  
000019E6                          1238      
000019E6                          1239  ;-----------------------  AND  ------------------------------;    
000019E6                          1240      
000019E6                          1241  OP_AND
000019E6                          1242      ; start string
000019E6                          1243      
000019E6  1CFC 0041               1244          Move.B  #'A', (A6)+
000019EA  1CFC 004E               1245          Move.B  #'N', (A6)+
000019EE  1CFC 0044               1246          Move.B  #'D', (A6)+
000019F2                          1247  
000019F2                          1248      ; No Address Version
000019F2                          1249          
000019F2                          1250      ; Check data size
000019F2  4EB9 00001B28           1251          Jsr     OP_CHECK_DATA_SIZE
000019F8                          1252          
000019F8                          1253      ; Put in tabs
000019F8  4EB9 00001B04           1254          Jsr     OP_TAB
000019FE                          1255          
000019FE  6000 04E0               1256      BRA     EA_AND
00001A02                          1257  
00001A02                          1258      
00001A02                          1259  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
00001A02                          1260          
00001A02                          1261  OP_AS_REG
00001A02                          1262      ; start string
00001A02                          1263      
00001A02  1CFC 0041               1264          Move.B  #'A', (A6)+
00001A06  1CFC 0053               1265          Move.B  #'S', (A6)+
00001A0A                          1266          
00001A0A                          1267      ; Determine Left or right shift
00001A0A                          1268      
00001A0A  4EB9 00001B78           1269          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A10                          1270          
00001A10                          1271      ; Determine data size
00001A10                          1272      
00001A10  4EB9 00001B28           1273          Jsr     OP_CHECK_DATA_SIZE
00001A16                          1274         
00001A16                          1275      ; Tab out function
00001A16                          1276      
00001A16  4EB9 00001B04           1277          Jsr     OP_TAB
00001A1C                          1278         
00001A1C                          1279      ; Handoff function
00001A1C  6000 04DA               1280          BRA     EA_BIT_SHIFT
00001A20                          1281          
00001A20                          1282  OP_AS_MEM
00001A20                          1283      
00001A20                          1284      ; start string
00001A20                          1285      
00001A20  1CFC 0041               1286          Move.B  #'A', (A6)+
00001A24  1CFC 0053               1287          Move.B  #'S', (A6)+
00001A28                          1288          
00001A28                          1289      ; Determine Left or right shift
00001A28                          1290      
00001A28  4EB9 00001B78           1291          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A2E                          1292         
00001A2E                          1293      ; Tab out function
00001A2E                          1294      
00001A2E  4EB9 00001B04           1295          Jsr     OP_TAB
00001A34                          1296         
00001A34                          1297      ; Handoff function
00001A34  6000 04C2               1298          BRA     EA_BIT_SHIFT
00001A38                          1299  
00001A38                          1300  
00001A38                          1301  ;-------------------  LOGICAL SHIFT  ------------------------;
00001A38                          1302  
00001A38                          1303  OP_LS_REG
00001A38                          1304      ; start string
00001A38                          1305      
00001A38  1CFC 004C               1306          Move.B  #'L', (A6)+
00001A3C  1CFC 0053               1307          Move.B  #'S', (A6)+
00001A40                          1308          
00001A40                          1309      ; Determine Left or right shift
00001A40                          1310      
00001A40  4EB9 00001B78           1311          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A46                          1312          
00001A46                          1313      ; Determine data size
00001A46                          1314      
00001A46  4EB9 00001B28           1315          Jsr     OP_CHECK_DATA_SIZE
00001A4C                          1316         
00001A4C                          1317      ; Tab out function
00001A4C                          1318      
00001A4C  4EB9 00001B04           1319          Jsr     OP_TAB
00001A52                          1320         
00001A52                          1321      ; Handoff function
00001A52  6000 04A4               1322          BRA     EA_BIT_SHIFT
00001A56                          1323  
00001A56                          1324      
00001A56                          1325  OP_LS_MEM    
00001A56                          1326  
00001A56                          1327      ; start string
00001A56                          1328      
00001A56  1CFC 004C               1329          Move.B  #'L', (A6)+
00001A5A  1CFC 0053               1330          Move.B  #'S', (A6)+
00001A5E                          1331          
00001A5E                          1332      ; Determine Left or right shift
00001A5E                          1333      
00001A5E  4EB9 00001B78           1334          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A64                          1335         
00001A64                          1336      ; Tab out function
00001A64                          1337      
00001A64  4EB9 00001B04           1338          Jsr     OP_TAB
00001A6A                          1339         
00001A6A                          1340      ; Handoff function
00001A6A  6000 048C               1341          BRA     EA_BIT_SHIFT
00001A6E                          1342  
00001A6E                          1343  
00001A6E                          1344  ;----------------------  ROTATE  ----------------------------;
00001A6E                          1345  
00001A6E                          1346  OP_RO_REG
00001A6E                          1347      ; start string
00001A6E                          1348      
00001A6E  1CFC 0052               1349          Move.B  #'R', (A6)+
00001A72  1CFC 004F               1350          Move.B  #'O', (A6)+
00001A76                          1351          
00001A76                          1352      ; Determine Left or right shift
00001A76                          1353      
00001A76  4EB9 00001B78           1354          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A7C                          1355          
00001A7C                          1356      ; Determine data size
00001A7C                          1357      
00001A7C  4EB9 00001B28           1358          Jsr     OP_CHECK_DATA_SIZE
00001A82                          1359         
00001A82                          1360      ; Tab out function
00001A82                          1361      
00001A82  4EB9 00001B04           1362          Jsr     OP_TAB
00001A88                          1363         
00001A88                          1364      ; Handoff function
00001A88  6000 046E               1365          BRA     EA_BIT_SHIFT
00001A8C                          1366  
00001A8C                          1367      
00001A8C                          1368  OP_RO_MEM
00001A8C                          1369  
00001A8C                          1370      ; start string
00001A8C                          1371      
00001A8C  1CFC 0052               1372          Move.B  #'R', (A6)+
00001A90  1CFC 004F               1373          Move.B  #'O', (A6)+
00001A94                          1374          
00001A94                          1375      ; Determine Left or right shift
00001A94                          1376      
00001A94  4EB9 00001B78           1377          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A9A                          1378         
00001A9A                          1379      ; Tab out function
00001A9A                          1380      
00001A9A  4EB9 00001B04           1381          Jsr     OP_TAB
00001AA0                          1382         
00001AA0                          1383      ; Handoff function
00001AA0  6000 0456               1384          BRA     EA_BIT_SHIFT
00001AA4                          1385  
00001AA4                          1386  
00001AA4                          1387  ;-----------------------  CMP  ------------------------------;
00001AA4                          1388  
00001AA4                          1389  OP_Cmp
00001AA4                          1390      ; start string
00001AA4                          1391      
00001AA4  1CFC 0043               1392          Move.B  #'C', (A6)+
00001AA8  1CFC 004D               1393          Move.B  #'M', (A6)+
00001AAC  1CFC 0050               1394          Move.B  #'P', (A6)+
00001AB0                          1395  
00001AB0                          1396      ; Check for address version
00001AB0                          1397          
00001AB0  4EB9 0000220C           1398          Jsr     GET6AND7
00001AB6  B03C 0003               1399          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001ABA                          1400          
00001ABA  6700 0012               1401          Beq     OP_CMP_ADDR
00001ABE                          1402          
00001ABE                          1403      ; Check which of the two versions is it?
00001ABE                          1404  
00001ABE  4EB9 00001B28           1405          Jsr     OP_CHECK_DATA_SIZE
00001AC4                          1406          
00001AC4                          1407      ; Put in tabs
00001AC4  4EB9 00001B04           1408          Jsr     OP_TAB
00001ACA                          1409  
00001ACA                          1410      ; Handoff
00001ACA  6000 040C               1411          BRA     EA_CMP
00001ACE                          1412          
00001ACE                          1413  OP_CMP_ADDR
00001ACE                          1414          
00001ACE  1CFC 0041               1415          Move.B  #'A',(A6)+ ; add to the string
00001AD2                          1416      
00001AD2                          1417      ; Find data size
00001AD2                          1418          
00001AD2  4EB9 00001B48           1419          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001AD8                          1420          
00001AD8                          1421      ; Put in tabs
00001AD8  4EB9 00001B04           1422          Jsr     OP_TAB
00001ADE                          1423  
00001ADE                          1424      ; Handoff
00001ADE  6000 03F8               1425          BRA     EA_CMP
00001AE2                          1426      
00001AE2                          1427  ;-----------------------  EOR  ------------------------------;
00001AE2                          1428  
00001AE2                          1429  OP_EOR
00001AE2                          1430      ; start string
00001AE2                          1431      
00001AE2  1CFC 0045               1432          Move.B  #'E', (A6)+
00001AE6  1CFC 004F               1433          Move.B  #'O', (A6)+
00001AEA  1CFC 0052               1434          Move.B  #'R', (A6)+
00001AEE                          1435  
00001AEE                          1436      ; No Address Version
00001AEE                          1437          
00001AEE                          1438      ; Check data size
00001AEE  4EB9 00001B28           1439          Jsr     OP_CHECK_DATA_SIZE
00001AF4                          1440          
00001AF4                          1441      ; Put in tabs
00001AF4  4EB9 00001B04           1442          Jsr     OP_TAB
00001AFA                          1443          
00001AFA  6000 03E8               1444      BRA     EA_EOR
00001AFE                          1445  
00001AFE                          1446  ;---------------- Misc Op-Code Sub Routines ----------------;
00001AFE                          1447  ; Set Bad Buffer
00001AFE                          1448  ; Sub Routine that sets the Bad buffer bit and returns
00001AFE                          1449  ;
00001AFE                          1450  ; REGISTERS USED: D7
00001AFE                          1451  
00001AFE                          1452  OP_SET_BAD_BUFFER
00001AFE  1E3C 0001               1453      Move.B  #%1, D7
00001B02  4E75                    1454      Rts
00001B04                          1455  
00001B04                          1456  ;-------------------------- Tab ----------------------------;
00001B04                          1457  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001B04                          1458  ; taking into account the current size of the string
00001B04                          1459  
00001B04                          1460  ; REGISTERS USED: A6, A5(const), D0
00001B04                          1461  
00001B04                          1462  OP_TAB
00001B04  220D                    1463      Move.L      A5,D1   ; Move the start of string to a Dn
00001B06  928E                    1464      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001B08  0681 00000014           1465      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001B0E                          1466      
00001B0E                          1467      ; Loop till you have enough spaces
00001B0E                          1468  LOOP_TAB
00001B0E  1CFC 0020               1469      Move.B      #' ',(A6)+  ; Add a space to the string
00001B12  5301                    1470      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001B14  66F8                    1471      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001B16                          1472      
00001B16  4E75                    1473      Rts
00001B18                          1474  
00001B18                          1475  ;--------------------- Address Version ---------------------;
00001B18                          1476  ; This Sub Routine Checks if the Src address is an An and
00001B18                          1477  ; Adds an A to the sring if it is, to represent that it is
00001B18                          1478  ; Is the Address version of the Op-code. This function assumes
00001B18                          1479  ; That D0 will have the mode for the Destination in it.
00001B18                          1480  
00001B18                          1481  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001B18                          1482  ;                 A6 (Add string input)
00001B18                          1483  
00001B18                          1484  OP_CHECK_ADDRESS_VERSION
00001B18                          1485  
00001B18  B03C 0001               1486      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001B1C  6700 0004               1487      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001B20                          1488      
00001B20  4E75                    1489      Rts     ; Otherwise go back without changing anything
00001B22                          1490  
00001B22                          1491  OP_ADD_ADDRESS_VERSION
00001B22  1CFC 0041               1492      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001B26                          1493      
00001B26  4E75                    1494      Rts     ; Finish up and go back
00001B28                          1495      
00001B28                          1496  ;--------------------- Data Size Check ---------------------;
00001B28                          1497  ; A set of sub routines to check the size of the data and add it
00001B28                          1498  ; To the string.
00001B28                          1499  
00001B28                          1500  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001B28                          1501  ;                 A6(adds letters)    
00001B28                          1502  OP_CHECK_DATA_SIZE
00001B28  4EB9 0000220C           1503      Jsr     GET6AND7
00001B2E                          1504      
00001B2E  B03C 0000               1505      Cmp.B    #%00, D0    ; Byte Size
00001B32  6700 0026               1506      Beq     OP_SET_DATA_BYTE
00001B36                          1507      
00001B36  B03C 0001               1508      Cmp.B    #%01, D0    ; Word Size
00001B3A  6700 0028               1509      Beq     OP_SET_DATA_WORD
00001B3E                          1510      
00001B3E  B03C 0002               1511      Cmp.B    #%10, D0    ; Long Size
00001B42  6700 002A               1512      Beq     OP_SET_DATA_LONG
00001B46                          1513      
00001B46                          1514      ; If it was not one of those three types, it is not a legal operation
00001B46  60B6                    1515      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001B48                          1516  
00001B48                          1517  OP_CHECK_DATA_SIZE_ADDR
00001B48  4EB9 000021E8           1518      Jsr     GETBIT8
00001B4E                          1519      
00001B4E  B03C 0000               1520      Cmp.B   #%0, D0     ; Word Size
00001B52  6700 0010               1521      Beq     OP_SET_DATA_WORD
00001B56                          1522                          ; Otherwise its Long Size
00001B56  6000 0016               1523      Bra     OP_SET_DATA_LONG
00001B5A                          1524  
00001B5A                          1525  OP_SET_DATA_BYTE
00001B5A                          1526  
00001B5A  1CFC 002E               1527      Move.B  #'.',(A6)+  ; Add Letters
00001B5E  1CFC 0042               1528      Move.B  #'B',(A6)+
00001B62                          1529      
00001B62  4E75                    1530      Rts
00001B64                          1531  
00001B64                          1532  OP_SET_DATA_WORD
00001B64                          1533  
00001B64  1CFC 002E               1534      Move.B  #'.',(A6)+  ; Add Letters
00001B68  1CFC 0057               1535      Move.B  #'W',(A6)+
00001B6C                          1536  
00001B6C  4E75                    1537      Rts
00001B6E                          1538  
00001B6E                          1539  OP_SET_DATA_LONG
00001B6E                          1540  
00001B6E  1CFC 002E               1541      Move.B  #'.',(A6)+  ; Add Letters
00001B72  1CFC 004C               1542      Move.B  #'L',(A6)+
00001B76                          1543  
00001B76  4E75                    1544      Rts
00001B78                          1545  
00001B78                          1546  ;------------------- Bit Shift Direction -------------------;
00001B78                          1547  ; This checks bit 8 to see what direction the shift is going
00001B78                          1548  
00001B78                          1549  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B78                          1550  
00001B78                          1551  OP_SHIFT_DIRECTION
00001B78  4EB9 000021E8           1552      Jsr     GETBIT8 ; Get the shift direction bit
00001B7E                          1553      
00001B7E  B03C 0000               1554      Cmp.B   #%0,D0  ; 0 is Right
00001B82  6700 0006               1555      Beq     OP_SHIFT_RIGHT
00001B86                          1556  
00001B86  6000 0008               1557      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001B8A                          1558  
00001B8A                          1559  OP_SHIFT_RIGHT
00001B8A                          1560      ; Add the character and return
00001B8A  1CFC 0052               1561      Move.B  #'R',(A6)+
00001B8E                          1562  
00001B8E  4E75                    1563      Rts    
00001B90                          1564  
00001B90                          1565  OP_SHIFT_LEFT
00001B90                          1566      ; Add the character and return
00001B90  1CFC 004C               1567      Move.B  #'L',(A6)+
00001B94                          1568  
00001B94  4E75                    1569      Rts
00001B96                          1570      
00001B96                          1571  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001B96                          1572  ;-------------------- Effective Address Sub Routines --------------------;
00001B96                          1573  ; These subroutines look for the correct effective address
00001B96                          1574  ; in each OP code.
00001B96                          1575  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001B96                          1576  
00001B96                          1577  ;=============================================;
00001B96                          1578  ;--------------- EA Move/MoveA ---------------;
00001B96                          1579  ;=============================================;
00001B96                          1580  EA_MOVE
00001B96  4EB9 00001BA8           1581          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001B9C  1CFC 002C               1582          Move.B  #',', (A6)+             ; Add a comma
00001BA0  4EB9 00001BB8           1583          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001BA6                          1584          
00001BA6  4E75                    1585          RTS
00001BA8                          1586                  
00001BA8                          1587  EA_MOVE_SOURCE  ; Find out Move's source
00001BA8  4EB9 0000212A           1588          Jsr     EA_0TO5                 ; Get the EA
00001BAE                          1589          
00001BAE  B03C 0004               1590          Cmp.B   #Imm_Reg, D0            ; #<data>
00001BB2  6700 004C               1591          Beq     EA_MOVE_SIZE
00001BB6                          1592          
00001BB6  4E75                    1593          Rts
00001BB8                          1594          
00001BB8                          1595  EA_MOVE_DEST    ; Find out Move's destination
00001BB8  4EB9 000021B2           1596          Jsr     GET6TO8                 ; Get destination mode
00001BBE  1A00                    1597          Move.B  D0, D5                  ; Move destination mode to D5
00001BC0  4EB9 000021A0           1598          Jsr     GET9TO11                ; Get destination register
00001BC6                          1599          
00001BC6                          1600          ; List of valid effective addresses
00001BC6  BA3C 0000               1601          Cmp.B   #Dn_Mode, D5            ; Dn
00001BCA  6700 0482               1602          Beq     EA_DN
00001BCE                          1603          
00001BCE  BA3C 0001               1604          Cmp.B   #An_Mode, D5            ; An
00001BD2  6700 0486               1605          Beq     EA_AN
00001BD6                          1606          
00001BD6  BA3C 0002               1607          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001BDA  6700 048A               1608          Beq     EA_AN_PNTR
00001BDE                          1609          
00001BDE  BA3C 0003               1610          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001BE2  6700 0496               1611          Beq     EA_AN_INC
00001BE6                          1612          
00001BE6  BA3C 0004               1613          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001BEA  6700 04A6               1614          Beq     EA_AN_DEC
00001BEE                          1615          
00001BEE                          1616          ; Comparing registers at this point because modes are the same
00001BEE  B03C 0000               1617          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001BF2  6700 04B6               1618          Beq     EA_WORD_ADDR
00001BF6                          1619          
00001BF6  B03C 0001               1620          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001BFA  6700 04F2               1621          Beq     EA_LONG_ADDR
00001BFE                          1622          
00001BFE  4E75                    1623          Rts
00001C00                          1624          
00001C00                          1625  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001C00  4EB9 0000217C           1626          Jsr     GET12TO13               ; Get Move size
00001C06                          1627  
00001C06  B03C 0001               1628          Cmp.B   #%01, D0                ; Byte
00001C0A  6700 04EE               1629          Beq     EA_IMM_BYTE
00001C0E                          1630  
00001C0E  B03C 0003               1631          Cmp.B   #%11, D0                ; Word
00001C12  6700 04F6               1632          Beq     EA_IMM_WORD
00001C16                          1633          
00001C16  B03C 0002               1634          Cmp.B   #%10, D0                ; Long
00001C1A  6700 04FE               1635          Beq     EA_IMM_LONG
00001C1E                          1636          
00001C1E  4E75                    1637          Rts
00001C20                          1638          
00001C20                          1639  ;=================================================================;
00001C20                          1640  ;---------------------------- EA MoveM ---------------------------;
00001C20                          1641  ; D2 stores the counter for the number of consecutive ones in the
00001C20                          1642  ; register list mask
00001C20                          1643  ;
00001C20                          1644  ; D3 stores a 1 if the register being added is the first register, 
00001C20                          1645  ; or 0 if the register is not the first register being added
00001C20                          1646  ;
00001C20                          1647  ; D5 stores the register list mask
00001C20                          1648  ;
00001C20                          1649  ; D6 stores any expansion words
00001C20                          1650  ;
00001C20                          1651  ; D7 stores the loop counter
00001C20                          1652  ;=================================================================;
00001C20                          1653  EA_MOVEM    ; Determines the EA for MoveM
00001C20  48E7 3F00               1654          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001C24                          1655          
00001C24  4282                    1656          Clr.L   D2                      ; Clear out the data registers
00001C26  4283                    1657          Clr.L   D3
00001C28  4285                    1658          Clr.L   D5
00001C2A  4286                    1659          Clr.L   D6
00001C2C  4287                    1660          Clr.L   D7
00001C2E                          1661          
00001C2E  5203                    1662          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001C30  3A1B                    1663          Move.W  (A3)+, D5               ; Store the register list mask
00001C32                          1664          
00001C32  4EB9 00002262           1665          Jsr     GETBIT10                ; Get the direction bit
00001C38                          1666          
00001C38  B03C 0000               1667          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001C3C  6700 0008               1668          Beq     EA_MOVEM_REG_TO_MEM
00001C40                          1669          
00001C40  4EF9 00001C5C           1670          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001C46                          1671          
00001C46                          1672  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001C46  4EB9 00001C78           1673          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C4C  1CFC 002C               1674          Move.B  #',', (A6)+             ; Add a comma
00001C50  4EB9 0000212A           1675          Jsr     EA_0TO5                 ; Get the EA
00001C56                          1676          
00001C56  4CDF 00FC               1677          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C5A                          1678                  
00001C5A  4E75                    1679          RTS
00001C5C                          1680          
00001C5C                          1681  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C5C  3E05                    1682          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C5E  4EB9 0000212A           1683          Jsr     EA_0TO5                 ; Get the EA
00001C64  1CFC 002C               1684          Move.B  #',', (A6)+             ; Add a comma
00001C68  3A07                    1685          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C6A  4287                    1686          Clr.L   D7                      ; Clear D7
00001C6C  4EB9 00001C78           1687          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C72                          1688          
00001C72  4CDF 00FC               1689          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C76                          1690                  
00001C76  4E75                    1691          RTS
00001C78                          1692                  
00001C78                          1693  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C78  BE3C 0010               1694          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C7C  6C00 0016               1695          Bge     EA_MOVEM_LIST_END
00001C80                          1696  
00001C80  4EB9 000021C4           1697          Jsr     GET3TO5                 ; Get the EA mode
00001C86                          1698          
00001C86  B03C 0004               1699          Cmp.B   #%100, D0               ; Predecrement mode
00001C8A  6700 000A               1700          Beq     EA_MOVEM_PRE_DEC
00001C8E                          1701          
00001C8E  4EF9 00001CA0           1702          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001C94                          1703          
00001C94                          1704  EA_MOVEM_LIST_END   ; Ends the list loop
00001C94  4E75                    1705          Rts
00001C96                          1706          
00001C96                          1707  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001C96  E35D                    1708          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001C98                          1709          
00001C98  6500 0010               1710          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001C9C                          1711          
00001C9C  6400 002C               1712          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001CA0                          1713          
00001CA0                          1714  EA_MOVEM_POST_INC   ; Post increment mode
00001CA0  E25D                    1715          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001CA2                          1716          
00001CA2  6500 0006               1717          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001CA6                          1718          
00001CA6  6400 0022               1719          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001CAA                          1720          
00001CAA                          1721  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001CAA  B63C 0001               1722          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001CAE  6700 002A               1723          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001CB2                          1724          
00001CB2  B43C 0000               1725          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001CB6  6700 0032               1726          Beq     EA_MOVEM_ADD_SINGLE_REG
00001CBA                          1727          
00001CBA  5207                    1728          Add.B   #1, D7                  ; Increment the loop counter
00001CBC  5202                    1729          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CBE                          1730          
00001CBE  BE3C 0010               1731          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001CC2  6700 0038               1732          Beq     EA_MOVEM_LAST_REG
00001CC6                          1733          
00001CC6  4EF8 1C78               1734          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CCA                          1735          
00001CCA                          1736  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001CCA  B43C 0001               1737          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001CCE  6E00 003A               1738          Bgt     EA_MOVEM_ADD_LAST_REG
00001CD2                          1739          
00001CD2  5207                    1740          Add.B   #1, D7                  ; Increment the loop counter
00001CD4                          1741          
00001CD4  4282                    1742          Clr.L   D2                      ; Clear the counter for consecutive ones
00001CD6                          1743          
00001CD6  4EF8 1C78               1744          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CDA                          1745  
00001CDA                          1746  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001CDA  4EB9 00001D1E           1747          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001CE0                          1748          
00001CE0  4283                    1749          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001CE2                          1750          
00001CE2  5207                    1751          Add.B   #1, D7                  ; Increment the loop counter
00001CE4  5202                    1752          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CE6                          1753          
00001CE6  4EF8 1C78               1754          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CEA                          1755          
00001CEA                          1756  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001CEA  1CFC 002F               1757          Move.B  #'/', (A6)+
00001CEE                          1758          
00001CEE  4EB9 00001D1E           1759          Jsr     EA_MOVEM_REG            ; Add a register
00001CF4                          1760          
00001CF4  5207                    1761          Add.B   #1, D7                  ; Increment the loop counter 
00001CF6  5202                    1762          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CF8                          1763          
00001CF8  4EF8 1C78               1764          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CFC                          1765          
00001CFC                          1766  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001CFC  B43C 0001               1767          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001D00  6E00 0008               1768          Bgt     EA_MOVEM_ADD_LAST_REG
00001D04                          1769          
00001D04  5207                    1770          Add.B   #1, D7                  ; Increment the loop counter
00001D06                          1771          
00001D06  4EF8 1C78               1772          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D0A                          1773          
00001D0A                          1774  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001D0A  1CFC 002D               1775          Move.B  #'-', (A6)+
00001D0E                          1776          
00001D0E  5307                    1777          Sub.B   #1, D7                  ; Move back to the previous register
00001D10                          1778          
00001D10  4EB9 00001D1E           1779          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001D16                          1780          
00001D16  5407                    1781          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001D18                          1782          
00001D18  4282                    1783          Clr.L   D2                      ; Clear the consecutive ones counter
00001D1A                          1784          
00001D1A  4EF8 1C78               1785          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D1E                          1786          
00001D1E                          1787  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001D1E  4280                    1788          Clr.L   D0                      ; Clear D0
00001D20  BE3C 0000               1789          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001D24  6700 0328               1790          Beq     EA_DN
00001D28                          1791          
00001D28  103C 0001               1792          Move.B  #1, D0                  ; Move a 1 into D0
00001D2C  BE3C 0001               1793          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001D30  6700 031C               1794          Beq     EA_DN
00001D34                          1795          
00001D34  103C 0002               1796          Move.B  #2, D0
00001D38  BE3C 0002               1797          Cmp.B   #2, D7
00001D3C  6700 0310               1798          Beq     EA_DN
00001D40                          1799  
00001D40  103C 0003               1800          Move.B  #3, D0
00001D44  BE3C 0003               1801          Cmp.B   #3, D7
00001D48  6700 0304               1802          Beq     EA_DN
00001D4C                          1803  
00001D4C  103C 0004               1804          Move.B  #4, D0
00001D50  BE3C 0004               1805          Cmp.B   #4, D7
00001D54  6700 02F8               1806          Beq     EA_DN
00001D58                          1807  
00001D58  103C 0005               1808          Move.B  #5, D0
00001D5C  BE3C 0005               1809          Cmp.B   #5, D7
00001D60  6700 02EC               1810          Beq     EA_DN
00001D64                          1811  
00001D64  103C 0006               1812          Move.B  #6, D0
00001D68  BE3C 0006               1813          Cmp.B   #6, D7
00001D6C  6700 02E0               1814          Beq     EA_DN
00001D70                          1815          
00001D70  103C 0007               1816          Move.B  #7, D0
00001D74  BE3C 0007               1817          Cmp.B   #7, D7
00001D78  6700 02D4               1818          Beq     EA_DN
00001D7C                          1819          
00001D7C  4280                    1820          Clr.L   D0
00001D7E  BE3C 0008               1821          Cmp.B   #8, D7
00001D82  6700 02D6               1822          Beq     EA_AN
00001D86                          1823  
00001D86  103C 0001               1824          Move.B  #1, D0
00001D8A  BE3C 0009               1825          Cmp.B   #9, D7
00001D8E  6700 02CA               1826          Beq     EA_AN
00001D92                          1827  
00001D92  103C 0002               1828          Move.B  #2, D0
00001D96  BE3C 000A               1829          Cmp.B   #10, D7
00001D9A  6700 02BE               1830          Beq     EA_AN
00001D9E                          1831          
00001D9E  103C 0003               1832          Move.B  #3, D0
00001DA2  BE3C 000B               1833          Cmp.B   #11, D7
00001DA6  6700 02B2               1834          Beq     EA_AN
00001DAA                          1835          
00001DAA  103C 0004               1836          Move.B  #4, D0
00001DAE  BE3C 000C               1837          Cmp.B   #12, D7
00001DB2  6700 02A6               1838          Beq     EA_AN
00001DB6                          1839          
00001DB6  103C 0005               1840          Move.B  #5, D0
00001DBA  BE3C 000D               1841          Cmp.B   #13, D7
00001DBE  6700 029A               1842          Beq     EA_AN
00001DC2                          1843          
00001DC2  103C 0006               1844          Move.B  #6, D0
00001DC6  BE3C 000E               1845          Cmp.B   #14, D7
00001DCA  6700 028E               1846          Beq     EA_AN
00001DCE                          1847          
00001DCE  103C 0007               1848          Move.B  #7, D0
00001DD2  BE3C 000F               1849          Cmp.B   #15, D7
00001DD6  6700 0282               1850          Beq     EA_AN
00001DDA                          1851  
00001DDA                          1852  ;===========================================;        
00001DDA                          1853  ;--------------- EA Add/AddA ---------------;
00001DDA                          1854  ;===========================================;       
00001DDA                          1855  EA_ADD  ; Figures out the EA for Add        
00001DDA  4EB9 000021B2           1856          Jsr     GET6TO8                 ; Isolate the Op mode
00001DE0                          1857          
00001DE0  B03C 0003               1858          Cmp.B   #%011, D0               ; Compare to AddA word
00001DE4  6700 0028               1859          Beq     EA_ADDA
00001DE8                          1860          
00001DE8  B03C 0007               1861          Cmp.B   #%111, D0               ; Compare to AddA long
00001DEC  6700 0020               1862          Beq     EA_ADDA
00001DF0                          1863  
00001DF0  B03C 0000               1864          Cmp.B   #%000, D0               ; Compare to Add source byte
00001DF4  6700 0030               1865          Beq     EA_ADD_OPMODE_SOURCE
00001DF8                          1866          
00001DF8  B03C 0001               1867          Cmp.B   #%001, D0               ; Compare to Add source word
00001DFC  6700 0028               1868          Beq     EA_ADD_OPMODE_SOURCE
00001E00                          1869          
00001E00  B03C 0002               1870          Cmp.B   #%010, D0               ; Compare to Add source Long
00001E04  6700 0020               1871          Beq     EA_ADD_OPMODE_SOURCE
00001E08                          1872          
00001E08  4EF9 00001E3E           1873          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001E0E                          1874          
00001E0E                          1875  EA_ADDA ; Figures out the EA for AddA
00001E0E  4EB9 00001E56           1876          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001E14  1CFC 002C               1877          Move.B  #',', (A6)+             ; Add a comma
00001E18  4EB9 000021A0           1878          Jsr     GET9TO11                ; Get the register
00001E1E  4EB9 0000205A           1879          Jsr     EA_AN                   ; Add An
00001E24                          1880          
00001E24  4E75                    1881          RTS
00001E26                          1882          
00001E26                          1883  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001E26  4EB9 00001E56           1884          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001E2C  1CFC 002C               1885          Move.B  #',', (A6)+             ; Add a comma
00001E30  4EB9 000021A0           1886          Jsr     GET9TO11                ; Get the register
00001E36  4EB9 0000204E           1887          Jsr     EA_DN                   ; Add Dn
00001E3C                          1888          
00001E3C  4E75                    1889          RTS
00001E3E                          1890          
00001E3E                          1891  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001E3E  4EB9 000021A0           1892          Jsr     GET9TO11                ; Get the register
00001E44  4EB9 0000204E           1893          Jsr     EA_DN                   ; Add Dn
00001E4A  1CFC 002C               1894          Move.B  #',', (A6)+             ; Add a comma
00001E4E  4EB9 00001E56           1895          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001E54                          1896          
00001E54  4E75                    1897          RTS
00001E56                          1898          
00001E56                          1899  EA_ADD_ADDRESS
00001E56  4EB9 0000212A           1900          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E5C                          1901          
00001E5C  B03C 0004               1902          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E60  6700 0004               1903          Beq     EA_ADD_SIZE
00001E64                          1904  
00001E64  4E75                    1905          Rts
00001E66                          1906          
00001E66                          1907  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E66  4EB9 000021B2           1908          Jsr     GET6TO8                 ; Get Move size
00001E6C                          1909  
00001E6C  B03C 0000               1910          Cmp.B   #%000, D0               ; Byte
00001E70  6700 0288               1911          Beq     EA_IMM_BYTE
00001E74                          1912  
00001E74  B03C 0001               1913          Cmp.B   #%001, D0               ; Word
00001E78  6700 0290               1914          Beq     EA_IMM_WORD
00001E7C                          1915          
00001E7C  B03C 0002               1916          Cmp.B   #%010, D0               ; Long
00001E80  6700 0298               1917          Beq     EA_IMM_LONG
00001E84                          1918          
00001E84  B03C 0003               1919          Cmp.B   #%011, D0               ; AddA Word
00001E88  6700 0280               1920          Beq     EA_IMM_WORD
00001E8C                          1921     
00001E8C  B03C 0007               1922          Cmp.B   #%111, D0               ; AddA Long
00001E90  6700 0288               1923          Beq     EA_IMM_LONG
00001E94                          1924          
00001E94  4E75                    1925          Rts
00001E96                          1926          
00001E96                          1927  ;=================================================;        
00001E96                          1928  ;-------------------- EA AddQ --------------------;
00001E96                          1929  ;=================================================;
00001E96                          1930  EA_ADDQ ; Figures out the EA for AddQ
00001E96  4EB9 00001EA8           1931          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001E9C  1CFC 002C               1932          Move.B  #',', (A6)+             ; Add a comma
00001EA0  4EB9 00001ECC           1933          Jsr     EA_ADDQ_DEST            ; Add the destination
00001EA6                          1934          
00001EA6  4E75                    1935          Rts
00001EA8                          1936  
00001EA8                          1937  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001EA8  4EB9 000021A0           1938          Jsr     GET9TO11                ; Isolate the count/register bits
00001EAE                          1939          
00001EAE  B03C 0000               1940          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001EB2  6E00 000C               1941          Bgt     EA_ADDQ_IMMEDIATE
00001EB6                          1942          
00001EB6  103C 0008               1943          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001EBA                          1944          
00001EBA  4EF9 00001EC0           1945          Jmp     EA_ADDQ_IMMEDIATE
00001EC0                          1946          
00001EC0                          1947  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001EC0  1CFC 0023               1948          Move.B  #'#', (A6)+
00001EC4  0600 0030               1949          Add.B   #$30, D0
00001EC8  1CC0                    1950          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001ECA                          1951          
00001ECA  4E75                    1952          Rts
00001ECC                          1953          
00001ECC                          1954  EA_ADDQ_DEST    ; Determines the destination       
00001ECC  4EB9 0000212A           1955          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001ED2                          1956          
00001ED2  4E75                    1957          Rts     
00001ED4                          1958          
00001ED4                          1959  ;=========================================================;        
00001ED4                          1960  ;---------------------- EA Sub/SubA ----------------------;
00001ED4                          1961  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001ED4                          1962  ; Sub/SubA are exactly the same.
00001ED4                          1963  ;=========================================================;
00001ED4                          1964  EA_SUB
00001ED4  4EF8 1DDA               1965          Jmp     EA_ADD
00001ED8                          1966  
00001ED8                          1967  ;=========================================================;        
00001ED8                          1968  ;---------------------- EA Cmp/CmpA ----------------------;
00001ED8                          1969  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001ED8                          1970  ; Cmp/CmpA are exactly the same.
00001ED8                          1971  ;=========================================================;
00001ED8                          1972  EA_CMP       
00001ED8  4EF8 1DDA               1973          Jmp     EA_ADD
00001EDC                          1974          
00001EDC                          1975  ;=========================================================;        
00001EDC                          1976  ;------------------------ EA Lea -------------------------;
00001EDC                          1977  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001EDC                          1978  ; are exactly the same.
00001EDC                          1979  ;=========================================================;
00001EDC                          1980  EA_LEA
00001EDC  4EF8 1DDA               1981          Jmp     EA_ADD
00001EE0                          1982          
00001EE0                          1983  ;=========================================================;        
00001EE0                          1984  ;------------------------ EA And -------------------------;
00001EE0                          1985  ; Jumps straight to EA_ADD because the EA for Add and And
00001EE0                          1986  ; are exactly the same.
00001EE0                          1987  ;=========================================================;
00001EE0                          1988  EA_AND
00001EE0  4EF8 1DDA               1989          Jmp     EA_ADD
00001EE4                          1990          
00001EE4                          1991  ;=========================================================;        
00001EE4                          1992  ;------------------------ EA Eor -------------------------;
00001EE4                          1993  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001EE4                          1994  ; are exactly the same.
00001EE4                          1995  ;=========================================================;
00001EE4                          1996  EA_EOR
00001EE4  4EF8 1DDA               1997          Jmp     EA_ADD
00001EE8                          1998          
00001EE8                          1999  ;=========================================================;        
00001EE8                          2000  ;------------------------ EA Neg -------------------------;
00001EE8                          2001  ;=========================================================;
00001EE8                          2002  EA_NEG
00001EE8  4EB9 0000212A           2003          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EEE                          2004          
00001EEE  4E75                    2005          RTS
00001EF0                          2006          
00001EF0                          2007  ;=========================================================;        
00001EF0                          2008  ;------------------------ EA Not -------------------------;
00001EF0                          2009  ; Jumps straight to EA_NEG because Neg and Not have the
00001EF0                          2010  ; exact same EAs. 
00001EF0                          2011  ;=========================================================;
00001EF0                          2012  EA_NOT
00001EF0  4EF8 1EE8               2013          Jmp     EA_NEG 
00001EF4                          2014          
00001EF4                          2015  ;=========================================================;        
00001EF4                          2016  ;------------------------ EA Jsr -------------------------;
00001EF4                          2017  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001EF4                          2018  ; exact same EAs. 
00001EF4                          2019  ;=========================================================;
00001EF4                          2020  EA_Jsr
00001EF4  4EF8 1EE8               2021          Jmp     EA_NEG 
00001EF8                          2022  
00001EF8                          2023  ;=========================================================;
00001EF8                          2024  ;--------------------- EA Bit Shift ----------------------;
00001EF8                          2025  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001EF8                          2026  ; are combined because the EA for each code is exactly the
00001EF8                          2027  ; same.
00001EF8                          2028  ;=========================================================;
00001EF8                          2029  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001EF8  4EB9 00002274           2030          Jsr     GET6TO7
00001EFE                          2031          
00001EFE  B03C 0003               2032          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001F02  6600 0012               2033          Bne     EA_SHIFT_REGISTER
00001F06                          2034          
00001F06  4EB9 00001F0E           2035          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001F0C                          2036          
00001F0C  4E75                    2037          RTS
00001F0E                          2038                  
00001F0E                          2039  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001F0E  4EB9 0000212A           2040          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F14                          2041          
00001F14  4E75                    2042          Rts
00001F16                          2043          
00001F16                          2044  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001F16  4EB9 00002242           2045          Jsr     GETBIT5
00001F1C                          2046          
00001F1C  B03C 0000               2047          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001F20  6700 0008               2048          Beq     EA_SHIFT_CHECK_8
00001F24                          2049          
00001F24  4EF9 00001F52           2050          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001F2A                          2051          
00001F2A                          2052  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001F2A  4EB9 000021A0           2053          Jsr     GET9TO11                ; Isolate the count/register bits
00001F30                          2054          
00001F30  B03C 0000               2055          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001F34  6E00 000C               2056          Bgt     EA_SHIFT_IMMEDIATE
00001F38                          2057          
00001F38  103C 0008               2058          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001F3C                          2059                  
00001F3C  4EF9 00001F42           2060          Jmp     EA_SHIFT_IMMEDIATE
00001F42                          2061          
00001F42                          2062  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001F42  1CFC 0023               2063          Move.B  #'#', (A6)+
00001F46  0600 0030               2064          Add.B   #$30, D0
00001F4A  1CC0                    2065          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001F4C                          2066  
00001F4C  4EF9 00001F64           2067          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001F52                          2068          
00001F52                          2069  EA_SHIFT_DN ; Adds a data register before the comma
00001F52  4EB9 000021A0           2070          Jsr     GET9TO11                ; Isolate the data register bits
00001F58                          2071          
00001F58  4EB9 0000204E           2072          Jsr     EA_DN                   ; Add the data register to the string
00001F5E                          2073          
00001F5E  4EF9 00001F64           2074          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F64                          2075          
00001F64                          2076  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F64  1CFC 002C               2077          Move.B  #',', (A6)+
00001F68                          2078          
00001F68  4EB9 000021D6           2079          Jsr     GET0TO2                 ; Get the register number
00001F6E                          2080          
00001F6E  4EB9 0000204E           2081          Jsr     EA_DN                   ; Add the register
00001F74                          2082          
00001F74  4E75                    2083          RTS
00001F76                          2084  
00001F76                          2085  ;============================================;        
00001F76                          2086  ;--------------- EA Immediate ---------------;
00001F76                          2087  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F76                          2088  ;============================================;
00001F76                          2089  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F76  4EB9 00001F88           2090          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F7C  1CFC 002C               2091          Move.B  #',', (A6)+             ; Add a comma
00001F80  4EB9 00001FA6           2092          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001F86                          2093          
00001F86  4E75                    2094          RTS
00001F88                          2095          
00001F88                          2096  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001F88  4EB9 00002274           2097          Jsr     GET6TO7                 ; Isolate the size bits
00001F8E                          2098                  
00001F8E  B03C 0001               2099          Cmp.B   #%01, D0                ; Immediate word
00001F92  6700 0176               2100          Beq     EA_IMM_WORD
00001F96                          2101          
00001F96  B03C 0002               2102          Cmp.B   #%10, D0                ; Immediate long
00001F9A  6700 017E               2103          Beq     EA_IMM_LONG
00001F9E                          2104        
00001F9E  4EF9 000020FA           2105          Jmp     EA_IMM_BYTE
00001FA4                          2106  
00001FA4  4E75                    2107          Rts
00001FA6                          2108          
00001FA6                          2109  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001FA6  4EB9 0000212A           2110          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001FAC                          2111          
00001FAC  4E75                    2112          Rts
00001FAE                          2113        
00001FAE                          2114  ;=================================================;  
00001FAE                          2115  ;-------------------- EA Muls --------------------;
00001FAE                          2116  ;=================================================;
00001FAE                          2117  EA_MULS ; Determines the EA for Muls
00001FAE  4EB9 00001FC6           2118          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001FB4  1CFC 002C               2119          Move.B  #',', (A6)+             ; Add a comma
00001FB8  4EB9 000021A0           2120          Jsr     GET9TO11                ; Get the register
00001FBE  4EB9 0000204E           2121          Jsr     EA_DN                   ; Add Dn
00001FC4                          2122          
00001FC4  4E75                    2123          RTS
00001FC6                          2124          
00001FC6                          2125  EA_MULS_ADDRESS ; Determines the EA
00001FC6  4EB9 0000212A           2126          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001FCC                          2127          
00001FCC  B03C 0004               2128          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001FD0  6700 0138               2129          Beq     EA_IMM_WORD
00001FD4                          2130          
00001FD4  4E75                    2131          Rts
00001FD6                          2132          
00001FD6                          2133  ;=================================================;  
00001FD6                          2134  ;-------------------- EA DIVS --------------------;
00001FD6                          2135  ; Jumps straight to EA_DIVS because the EA for
00001FD6                          2136  ; both OP codes is exactly the same.
00001FD6                          2137  ;=================================================;
00001FD6                          2138  EA_DIVS
00001FD6  4EF8 1FAE               2139          Jmp     EA_MULS
00001FDA                          2140          
00001FDA                          2141  ;=================================================;        
00001FDA                          2142  ;-------------------- EA BTST --------------------;
00001FDA                          2143  ;=================================================;
00001FDA                          2144  EA_BTST ; Determines the EA for Btst
00001FDA  4EB9 000021E8           2145          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001FE0                          2146          
00001FE0  B03C 0001               2147          Cmp.B   #%1, D0                 ; 1 is a data register
00001FE4  6700 0008               2148          Beq     EA_BTST_DN
00001FE8                          2149          
00001FE8  4EF9 00002002           2150          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
00001FEE                          2151          
00001FEE                          2152  EA_BTST_DN  ; Gets the register for the bit number
00001FEE  4EB9 000021A0           2153          Jsr     GET9TO11                ; Get the register
00001FF4  4EB9 0000204E           2154          Jsr     EA_DN                   ; Add the register to the string
00001FFA                          2155          
00001FFA  4EB9 00002010           2156          Jsr     EA_BTST_ADDRESS         ; Add the EA
00002000                          2157          
00002000  4E75                    2158          RTS
00002002                          2159  
00002002                          2160  EA_BTST_IMM ; Gets the immediate data for the bit number
00002002  4EB9 000020FA           2161          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00002008                          2162          
00002008  4EB9 00002010           2163          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
0000200E                          2164          
0000200E  4E75                    2165          RTS
00002010                          2166  
00002010                          2167  EA_BTST_ADDRESS ; Get the EA
00002010  1CFC 002C               2168          Move.B  #',', (A6)+
00002014                          2169  
00002014  4EB9 0000212A           2170          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
0000201A                          2171          
0000201A  B03C 0004               2172          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
0000201E  6700 00DA               2173          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
00002022                          2174          
00002022  4E75                    2175          Rts
00002024                          2176          
00002024                          2177  ;==================================================;        
00002024                          2178  ;------------------- EA Branch --------------------;
00002024                          2179  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00002024                          2180  ;==================================================;
00002024                          2181  EA_BRANCH  ; Determines the EA for Branch codes
00002024  4EB9 00002254           2182          Jsr     GET0TO7                 ; Get the 8 displacement bits
0000202A                          2183          
0000202A  2C0B                    2184          Move.L  A3, D6                  ; Move address after the Bra word to D6
0000202C                          2185          
0000202C  B03C 0000               2186          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
00002030  6700 0008               2187          Beq     EA_BRANCH_16_BIT
00002034                          2188          
00002034  4EF9 00002042           2189          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
0000203A                          2190  
0000203A                          2191  EA_BRANCH_16_BIT   ; Gets the next word
0000203A  301B                    2192          Move.W  (A3)+, D0               ; Stores the word in D0
0000203C                          2193  
0000203C  4EF9 00002042           2194          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
00002042                          2195          
00002042                          2196  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
00002042  DC40                    2197          Add.W   D0, D6                  ; Add the displacement to D6
00002044                          2198      
00002044  1CFC 0024               2199          Move.B  #'$', (A6)+             ; Add '$' to the string
00002048                          2200          
00002048  4EB8 12CC               2201          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
0000204C                          2202  
0000204C  4E75                    2203          RTS
0000204E                          2204                         
0000204E                          2205  ;==========================================;        
0000204E                          2206  ;---------- General EA functions ----------;
0000204E                          2207  ;==========================================;
0000204E                          2208  EA_DN   ; Adds Dn EA to string
0000204E  1CFC 0044               2209          Move.B  #'D', (A6)+             
00002052  0600 0030               2210          Add.B   #$30, D0        
00002056  1CC0                    2211          Move.B  D0, (A6)+               
00002058                          2212                  
00002058  4E75                    2213          Rts
0000205A                          2214  
0000205A                          2215  EA_AN   ; Adds An EA to string
0000205A  1CFC 0041               2216          Move.B  #'A', (A6)+
0000205E  0600 0030               2217          Add.B   #$30, D0    
00002062  1CC0                    2218          Move.B  D0, (A6)+               
00002064                          2219                  
00002064  4E75                    2220          Rts
00002066                          2221  
00002066                          2222  EA_AN_PNTR  ; Adds (An) EA to string
00002066  1CFC 0028               2223          Move.B  #'(', (A6)+
0000206A  1CFC 0041               2224          Move.B  #'A', (A6)+
0000206E  0600 0030               2225          Add.B   #$30, D0
00002072  1CC0                    2226          Move.B  D0, (A6)+
00002074  1CFC 0029               2227          Move.B  #')', (A6)+
00002078                          2228                  
00002078  4E75                    2229          Rts
0000207A                          2230          
0000207A                          2231  EA_AN_INC   ; Adds (An)+ EA to string
0000207A  1CFC 0028               2232          Move.B  #'(', (A6)+
0000207E  1CFC 0041               2233          Move.B  #'A', (A6)+
00002082  0600 0030               2234          Add.B   #$30, D0
00002086  1CC0                    2235          Move.B  D0, (A6)+
00002088  1CFC 0029               2236          Move.B  #')', (A6)+
0000208C  1CFC 002B               2237          Move.B  #'+', (A6)+
00002090                          2238                  
00002090  4E75                    2239          Rts 
00002092                          2240          
00002092                          2241  EA_AN_DEC   ; Adds -(An) EA to string
00002092  1CFC 002D               2242          Move.B  #'-', (A6)+
00002096  1CFC 0028               2243          Move.B  #'(', (A6)+
0000209A  1CFC 0041               2244          Move.B  #'A', (A6)+
0000209E  0600 0030               2245          Add.B   #$30, D0
000020A2  1CC0                    2246          Move.B  D0, (A6)+
000020A4  1CFC 0029               2247          Move.B  #')', (A6)+
000020A8                          2248                  
000020A8  4E75                    2249          Rts 
000020AA                          2250  
000020AA                          2251  EA_WORD_ADDR    ; Adds $Word to string
000020AA  3C1B                    2252          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
000020AC                          2253          
000020AC  1CFC 0024               2254          Move.B  #'$', (A6)+
000020B0                          2255          
000020B0  BC7C 8000               2256          Cmp.W   #$8000, D6          ; Word address is less than 8000
000020B4  6500 000C               2257          Bcs     EA_SIGN_EXT_16
000020B8                          2258          
000020B8  BC7C 8000               2259          Cmp.W   #$8000, D6          ; Word address is greater than 8000
000020BC  6400 001A               2260          Bcc     EA_SIGN_EXT_32
000020C0                          2261          
000020C0  4E75                    2262          Rts
000020C2                          2263                  
000020C2                          2264  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
000020C2  1CFC 0030               2265          Move.B  #'0', (A6)+
000020C6  1CFC 0030               2266          Move.B  #'0', (A6)+
000020CA  1CFC 0030               2267          Move.B  #'0', (A6)+
000020CE  1CFC 0030               2268          Move.B  #'0', (A6)+
000020D2                          2269          
000020D2  4EB8 12EC               2270          Jsr     hex_to_ASCII_W       
000020D6                          2271          
000020D6  4E75                    2272          Rts
000020D8                          2273  
000020D8                          2274  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
000020D8  1CFC 0046               2275          Move.B  #'F', (A6)+
000020DC  1CFC 0046               2276          Move.B  #'F', (A6)+
000020E0  1CFC 0046               2277          Move.B  #'F', (A6)+
000020E4  1CFC 0046               2278          Move.B  #'F', (A6)+
000020E8                          2279          
000020E8  4EB8 12EC               2280          Jsr     hex_to_ASCII_W   
000020EC                          2281          
000020EC  4E75                    2282          Rts
000020EE                          2283                  
000020EE                          2284  EA_LONG_ADDR    ; Adds $Long to string
000020EE  2C1B                    2285          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
000020F0                          2286          
000020F0  1CFC 0024               2287          Move.B  #'$', (A6)+
000020F4                          2288          
000020F4  4EB8 12CC               2289          Jsr     hex_to_ASCII_L
000020F8                          2290  
000020F8  4E75                    2291          Rts
000020FA                          2292                  
000020FA                          2293  
000020FA                          2294  EA_IMM_BYTE ; Finds the immediate byte data
000020FA  3C1B                    2295          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
000020FC                          2296          
000020FC  1CFC 0023               2297          Move.B  #'#', (A6)+         
00002100  1CFC 0024               2298          Move.B  #'$', (A6)+         
00002104                          2299          
00002104  4EB8 130C               2300          Jsr     hex_to_ASCII_B    ; Add the byte to the string
00002108                          2301          
00002108  4E75                    2302          Rts
0000210A                          2303                  
0000210A                          2304  EA_IMM_WORD ; Finds the immediate word data
0000210A  3C1B                    2305          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
0000210C                          2306          
0000210C  1CFC 0023               2307          Move.B  #'#', (A6)+         
00002110  1CFC 0024               2308          Move.B  #'$', (A6)+         
00002114                          2309          
00002114  4EB8 12EC               2310          Jsr     hex_to_ASCII_W    ; Add the word to the string
00002118                          2311          
00002118  4E75                    2312          Rts
0000211A                          2313          
0000211A                          2314  EA_IMM_LONG ; Finds the immediate long data
0000211A  2C1B                    2315          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
0000211C                          2316          
0000211C  1CFC 0023               2317          Move.B  #'#', (A6)+
00002120  1CFC 0024               2318          Move.B  #'$', (A6)+
00002124                          2319          
00002124  4EB8 12CC               2320          Jsr     hex_to_ASCII_L    ; Add the long to the string
00002128                          2321          
00002128  4E75                    2322          Rts
0000212A                          2323          
0000212A                          2324  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
0000212A  4EB9 000021C4           2325          Jsr     GET3TO5                 ; Get source mode
00002130  1A00                    2326          Move.B  D0, D5                  ; Move source mode to D5
00002132  4EB9 000021D6           2327          Jsr     Get0TO2                 ; Get source register
00002138                          2328          
00002138                          2329          ; List of valid effective addresses
00002138  BA3C 0000               2330          Cmp.B   #Dn_Mode, D5            ; Dn
0000213C  6700 FF10               2331          Beq     EA_DN
00002140                          2332          
00002140  BA3C 0001               2333          Cmp.B   #An_Mode, D5            ; An
00002144  6700 FF14               2334          Beq     EA_AN
00002148                          2335          
00002148  BA3C 0002               2336          Cmp.B   #An_Pntr_Mode, D5       ; (An)
0000214C  6700 FF18               2337          Beq     EA_AN_PNTR
00002150                          2338          
00002150  BA3C 0003               2339          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00002154  6700 FF24               2340          Beq     EA_AN_INC
00002158                          2341          
00002158  BA3C 0004               2342          Cmp.B   #An_Dec_Mode, D5        ; -(An)
0000215C  6700 FF34               2343          Beq     EA_AN_DEC
00002160                          2344          
00002160                          2345          ; Comparing registers at this point because modes are the same
00002160  B03C 0000               2346          Cmp.B   #Word_Reg, D0           ; (xxx).W
00002164  6700 FF44               2347          Beq     EA_WORD_ADDR
00002168                          2348          
00002168  B03C 0001               2349          Cmp.B   #Long_Reg, D0           ; (xxx).L
0000216C  6780                    2350          Beq     EA_LONG_ADDR
0000216E                          2351          
0000216E  4E75                    2352          Rts
00002170                          2353      
00002170                          2354  
00002170                          2355  ;---------------- Bit Chopping Sub Routines ----------------;
00002170                          2356  ; These Sub Routines Chop a WORD size piece of data from
00002170                          2357  ; Data register 4 into a smaller piece, leaving just the
00002170                          2358  ; Piece in register 0 while leaving the original piece
00002170                          2359  ; of data intact.
00002170                          2360  
00002170                          2361  ; REGISTERS USED: D0, D1, D4 (const input)
00002170                          2362  
00002170                          2363  GET12TO15   ;1001 0000 0000 0000 -> 1001
00002170  4280                    2364                  CLR.L   D0      
00002172  3004                    2365                  Move.W  D4, D0      
00002174                          2366                  
00002174  123C 000C               2367                  Move.B  #12, D1     
00002178  E268                    2368                  LSR.W       D1, D0      
0000217A                          2369                  
0000217A  4E75                    2370                  RTS
0000217C                          2371                  
0000217C                          2372  GET12TO13
0000217C  4280                    2373          CLR.L   D0
0000217E  3004                    2374          Move.W  D4, D0
00002180                          2375          
00002180  123C 0002               2376          Move.B  #2, D1
00002184  E368                    2377          LSL     D1, D0
00002186                          2378          
00002186  123C 000E               2379          Move.B  #14, D1
0000218A  E268                    2380          LSR     D1, D0
0000218C                          2381          
0000218C  4E75                    2382          RTS             
0000218E                          2383  
0000218E                          2384  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
0000218E  4280                    2385                  CLR.L   D0      ; Clear out D0
00002190  3004                    2386                  Move.W  D4, D0      ; Move a copy of the bit string to D0
00002192                          2387                  
00002192  123C 0004               2388                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
00002196  E368                    2389                  LSL.W   D1, D0      ; Move the string all the way to the left
00002198                          2390                  
00002198  123C 000C               2391                  Move.B  #12, D1     ; Change the amount of bits shifted
0000219C  E268                    2392                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
0000219E                          2393                  
0000219E  4E75                    2394                  RTS         ; Return from the subroutine
000021A0                          2395                      
000021A0                          2396  GET9TO11    ; 0000 1010 0000 0000 -> 101    
000021A0  4280                    2397                  CLR.L   D0      ; Clear out D0
000021A2  3004                    2398                  Move.W  D4, D0      ; Move a copy of the bit string to D0
000021A4                          2399                  
000021A4  123C 0004               2400                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
000021A8  E368                    2401                  LSL.W   D1, D0      ; Move the string all the way to the left
000021AA                          2402                  
000021AA  123C 000D               2403                  Move.B  #13, D1     ; Change the amount of bits shifted
000021AE  E268                    2404                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
000021B0                          2405                  
000021B0  4E75                    2406                  RTS         ; Return from the subroutine
000021B2                          2407                  
000021B2                          2408  GET6TO8     ; 0000 0001 1000 0000 -> 110
000021B2  4280                    2409                  CLR.L   D0
000021B4  3004                    2410                  Move.W  D4, D0
000021B6                          2411                  
000021B6  123C 0007               2412                  Move.B  #7, D1
000021BA  E368                    2413                  LSL.W   D1, D0
000021BC                          2414                  
000021BC  123C 000D               2415                  Move.B  #13, D1
000021C0  E268                    2416                  LSR.W       D1, D0
000021C2                          2417                  
000021C2  4E75                    2418                  RTS
000021C4                          2419                  
000021C4                          2420  GET3TO5     ; 0000 0000 0011 1000 -> 111
000021C4  4280                    2421                  CLR.L   D0
000021C6  3004                    2422                  Move.W  D4, D0
000021C8                          2423                  
000021C8  123C 000A               2424                  Move.B  #10, D1
000021CC  E368                    2425                  LSL.W   D1, D0
000021CE                          2426                  
000021CE  123C 000D               2427                  Move.B  #13, D1
000021D2  E268                    2428                  LSR.W       D1, D0
000021D4                          2429                  
000021D4  4E75                    2430                  RTS
000021D6                          2431  GET0TO2     ; 0000 0000 0000 0011 -> 011
000021D6  4280                    2432                  CLR.L   D0
000021D8  3004                    2433                  Move.W  D4, D0
000021DA                          2434                  
000021DA  123C 000D               2435                  Move.B  #13, D1
000021DE  E368                    2436                  LSL.W   D1, D0
000021E0                          2437                  
000021E0  123C 000D               2438                  Move.B  #13, D1
000021E4  E268                    2439                  LSR.W       D1, D0
000021E6                          2440                  
000021E6  4E75                    2441                  RTS
000021E8                          2442  GETBIT8     ; 0000 0001 0000 0000 -> 1
000021E8  4280                    2443                  CLR.L   D0
000021EA  3004                    2444                  Move.W  D4, D0
000021EC                          2445                  
000021EC  123C 0007               2446                  Move.B  #7, D1
000021F0  E368                    2447                  LSL.W   D1, D0
000021F2                          2448                  
000021F2  123C 000F               2449                  Move.B  #15, D1
000021F6  E268                    2450                  LSR.W       D1, D0
000021F8                          2451                  
000021F8  4E75                    2452                  RTS
000021FA                          2453                  
000021FA                          2454  GET9AND10    ; 0000 0110 0000 0000 -> 11
000021FA  4280                    2455                  CLR.L   D0
000021FC  3004                    2456                  Move.W  D4, D0
000021FE                          2457                  
000021FE  123C 0005               2458                  Move.B  #5, D1
00002202  E368                    2459                  LSL.W   D1, D0
00002204                          2460                  
00002204  123C 000E               2461                  Move.B  #14, D1
00002208  E268                    2462                  LSR.W   D1, D0
0000220A                          2463                  
0000220A  4E75                    2464                  RTS             
0000220C                          2465                  
0000220C                          2466  GET6AND7    
0000220C  4280                    2467                  CLR.L   D0
0000220E  3004                    2468                  Move.W  D4, D0
00002210                          2469                  
00002210  123C 0008               2470                  Move.B  #8, D1
00002214  E368                    2471                  LSL.W   D1, D0
00002216                          2472                  
00002216  123C 000E               2473                  Move.B  #14, D1
0000221A  E268                    2474                  LSR.W   D1, D0
0000221C                          2475                  
0000221C  4E75                    2476                  RTS
0000221E                          2477                  
0000221E                          2478  GET7AND8    
0000221E  4280                    2479                  CLR.L   D0
00002220  3004                    2480                  Move.W  D4, D0
00002222                          2481                  
00002222  123C 0007               2482                  Move.B  #7, D1
00002226  E368                    2483                  LSL.W   D1, D0
00002228                          2484                  
00002228  123C 000E               2485                  Move.B  #14, D1
0000222C  E268                    2486                  LSR.W   D1, D0
0000222E                          2487                  
0000222E  4E75                    2488                  RTS             
00002230                          2489                  
00002230                          2490  GET3AND4    
00002230  4280                    2491                  CLR.L   D0
00002232  3004                    2492                  Move.W  D4, D0
00002234                          2493                  
00002234  123C 000B               2494                  Move.B  #11, D1
00002238  E368                    2495                  LSL.W   D1, D0
0000223A                          2496                  
0000223A  123C 000E               2497                  Move.B  #14, D1
0000223E  E268                    2498                  LSR.W   D1, D0
00002240                          2499                  
00002240  4E75                    2500                  RTS
00002242                          2501                  
00002242                          2502  GETBIT5
00002242  4280                    2503          Clr.L   D0
00002244  3004                    2504          Move.W  D4, D0
00002246                          2505          
00002246  123C 000A               2506          Move.B  #10, D1
0000224A  E368                    2507          Lsl     D1, D0
0000224C                          2508          
0000224C  123C 000F               2509          Move.B  #15, D1
00002250  E268                    2510          Lsr     D1, D0
00002252                          2511          
00002252  4E75                    2512          Rts
00002254                          2513  
00002254                          2514  GET0TO7
00002254  4280                    2515          Clr.L   D0
00002256  3004                    2516          Move.W  D4, D0
00002258                          2517          
00002258  123C 0008               2518          Move.B  #8, D1
0000225C  E368                    2519          Lsl     D1, D0
0000225E                          2520          
0000225E  E268                    2521          Lsr     D1, D0
00002260                          2522          
00002260  4E75                    2523          Rts
00002262                          2524          
00002262                          2525  GETBIT10
00002262  4280                    2526          Clr.L   D0
00002264  3004                    2527          Move.W  D4, D0
00002266                          2528          
00002266  123C 0005               2529          Move.B  #5, D1
0000226A  E368                    2530          Lsl     D1, D0
0000226C                          2531          
0000226C  123C 000F               2532          Move.B  #15, D1
00002270  E268                    2533          Lsr     D1, D0
00002272                          2534          
00002272  4E75                    2535          Rts
00002274                          2536          
00002274                          2537  GET6TO7
00002274  4280                    2538          Clr.L   D0
00002276  3004                    2539          Move.W  D4, D0
00002278                          2540          
00002278  123C 0008               2541          Move.B  #8, D1
0000227C  E368                    2542          Lsl     D1, D0
0000227E                          2543          
0000227E  123C 000E               2544          Move.B  #14, D1
00002282  E268                    2545          Lsr     D1, D0
00002284                          2546          
00002284  4E75                    2547          Rts
00002286                          2548  
00002286                          2549  GET3TO8    ; 0000 0000 1100 0000 -> 11
00002286  4280                    2550                  CLR.L   D0
00002288  3004                    2551                  Move.W  D4, D0
0000228A                          2552                  
0000228A  123C 0007               2553                  Move.B  #7, D1
0000228E  E368                    2554                  LSL.W   D1, D0
00002290                          2555                  
00002290  123C 000A               2556                  Move.B  #10, D1
00002294  E268                    2557                  LSR.W   D1, D0
00002296                          2558                  
00002296  4E75                    2559                  RTS
00002298                          2560  
00002298                          2561  GET6TO11    ; 0000 0000 1100 0000 -> 11
00002298  4280                    2562                  CLR.L   D0
0000229A  3004                    2563                  Move.W  D4, D0
0000229C                          2564                  
0000229C  123C 0004               2565                  Move.B  #4, D1
000022A0  E368                    2566                  LSL.W   D1, D0
000022A2                          2567                  
000022A2  123C 000A               2568                  Move.B  #10, D1
000022A6  E268                    2569                  LSR.W   D1, D0
000022A8                          2570                  
000022A8  4E75                    2571                  RTS        
000022AA                          2572                  
000022AA                          2573             
000022AA                          2574  ;-----------Constants/Messages-------------------------------------------------
000022AA= 20 5F 5F 5F 5F 5F ...   2575  psychobots1     DC.B    ' _____  ____   _  _   ____   __  __   _____    _____   _____    _____    ___',CR,LF,0
000022F9= 2F 5C 20 3D 3D 20 ...   2576  psychobots2     DC.B    '/\ == \/\  _\ /\\_\\ /\  _\ /\ \_\ \ /\  __ \ /\ == \ /\  __ \ /\_   _\ /\  _\',CR,LF,0
0000234A= 5C 20 5C 20 20 2D ...   2577  psychobots3     DC.B    '\ \  -/\ \__ \\ \__ \\ \ \__\ \  __ \\ \ \/\ \\ \  _< \ \ \/\ \\/_/\ \/ \ \__ \',CR,LF,0
0000239C= 20 5C 20 5C 5F 5C ...   2578  psychobots4     DC.B    ' \ \_\  \/\___\\/\___\\ \___\\ \_\ \_\\ \_____\\ \____\\ \_____\  \ \_\  \/\___\',CR,LF,0
000023EF= 20 20 5C 2F 5F 2F ...   2579  psychobots5     DC.B    '  \/_/   \/___/ \/___/ \/___/ \/_/\/_/ \/_____/ \/_____/\/_____/   \/_/   \/___/',CR,LF,0
00002442= 09 09 2D 2D 2D 2D ...   2580  intro_stuff     DC.B    HT,HT,'------------------------------------------------------',CR,LF,0
0000247D                          2581  
0000247D= 09 09 20 57 65 6C ...   2582  intro_msg       DC.B    HT,HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000024B6= 09 09 20 43 72 65 ...   2583                  DC.B    HT,HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
000024F0                          2584         
000024F0= 50 6C 65 61 73 65 ...   2585  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
00002529= 50 6C 65 61 73 65 ...   2586  end_address1    DC.B    'Please enter the ending address from $',0
00002550= 20 74 6F 20 24 30 ...   2587  end_address2    DC.B    ' to $00FFFFFE: ',0
00002560= 54 68 61 6E 6B 20 ...   2588  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
00002592= 57 6F 75 6C 64 20 ...   2589  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000025C2= 48 69 74 20 65 6E ...   2590  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
000025F0                          2591  
000025F0= 09 41 64 64 72 65 ...   2592  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
00002626= 09 59 6F 75 20 6E ...   2593  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
00002652= 09 50 6C 65 61 73 ...   2594  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
0000268A                          2595  
0000268A                          2596  start_input     DS.L    2               ; Allocates space for start address
00002692                          2597  end_input       DS.L    2               ; Allocates space for end address
0000269A                          2598  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
000026A2                          2599  hit_enter       DS.L    2               ; User input to hit enter
000026AA                          2600  line_count      DS.L    1               ; Holds the display line count  
000026AE                          2601  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
000027EE                          2602  valid_data      DS.L    80              ; Instructions that we converted
0000292E                          2603                  
0000292E                          2604                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            152E
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           2652
ASK_INPUT           269A
ASK_USER            2592
BADADDR_INPUT       25F0
BAD_BUFF            1170
BEGIN               0
BIT_SHIFT           156E
BIT_SHIFT_MEM       1580
BIT_SHIFT_REG       15A2
BRANCH_CONDITIONALS  14AC
CHECK_10_LINES      11C6
CHECK_INPUT         1280
CHK_BOUND           1372
CMP_EOR             15C4
CONVERT_HEX         132C
CR                  D
DISASSEMBLE         111A
DISPLAY_DATA        118A
DN_MODE             0
DONE                125E
DONE_CONVERTING     134E
EA_0TO5             212A
EA_ADD              1DDA
EA_ADDA             1E0E
EA_ADDQ             1E96
EA_ADDQ_CHECK_8     1EA8
EA_ADDQ_DEST        1ECC
EA_ADDQ_IMMEDIATE   1EC0
EA_ADD_ADDRESS      1E56
EA_ADD_OPMODE_DEST  1E3E
EA_ADD_OPMODE_SOURCE  1E26
EA_ADD_SIZE         1E66
EA_AN               205A
EA_AND              1EE0
EA_AN_DEC           2092
EA_AN_INC           207A
EA_AN_PNTR          2066
EA_BIT_SHIFT        1EF8
EA_BRANCH           2024
EA_BRANCH_16_BIT    203A
EA_BRANCH_ADD_DIS   2042
EA_BTST             1FDA
EA_BTST_ADDRESS     2010
EA_BTST_DN          1FEE
EA_BTST_IMM         2002
EA_CMP              1ED8
EA_DIVS             1FD6
EA_DN               204E
EA_EOR              1EE4
EA_IMMEDIATE        1F76
EA_IMMEDIATE_DEST   1FA6
EA_IMMEDIATE_SIZE   1F88
EA_IMM_BYTE         20FA
EA_IMM_LONG         211A
EA_IMM_WORD         210A
EA_JSR              1EF4
EA_LEA              1EDC
EA_LONG_ADDR        20EE
EA_MOVE             1B96
EA_MOVEM            1C20
EA_MOVEM_ADD_LAST_REG  1D0A
EA_MOVEM_ADD_SINGLE_REG  1CEA
EA_MOVEM_CARRY_CLEAR  1CCA
EA_MOVEM_CARRY_SET  1CAA
EA_MOVEM_FIRST_REG  1CDA
EA_MOVEM_LAST_REG   1CFC
EA_MOVEM_LIST_END   1C94
EA_MOVEM_LIST_LOOP  1C78
EA_MOVEM_MEM_TO_REG  1C5C
EA_MOVEM_POST_INC   1CA0
EA_MOVEM_PRE_DEC    1C96
EA_MOVEM_REG        1D1E
EA_MOVEM_REG_TO_MEM  1C46
EA_MOVE_DEST        1BB8
EA_MOVE_SIZE        1C00
EA_MOVE_SOURCE      1BA8
EA_MULS             1FAE
EA_MULS_ADDRESS     1FC6
EA_NEG              1EE8
EA_NOT              1EF0
EA_SHIFT_CHECK_8    1F2A
EA_SHIFT_COMMA      1F64
EA_SHIFT_DN         1F52
EA_SHIFT_IMMEDIATE  1F42
EA_SHIFT_MEMORY     1F0E
EA_SHIFT_REGISTER   1F16
EA_SIGN_EXT_16      20C2
EA_SIGN_EXT_32      20D8
EA_SUB              1ED4
EA_WORD_ADDR        20AA
END                 FFFFFE
ENDING              2560
END_ADDRESS1        2529
END_ADDRESS2        2550
END_ERROR           135A
END_INPUT           2692
GET0TO2             21D6
GET0TO7             2254
GET12TO13           217C
GET12TO15           2170
GET3AND4            2230
GET3TO5             21C4
GET3TO8             2286
GET6AND7            220C
GET6TO11            2298
GET6TO7             2274
GET6TO8             21B2
GET7AND8            221E
GET8TO11            218E
GET9AND10           21FA
GET9TO11            21A0
GETBIT10            2262
GETBIT5             2242
GETBIT8             21E8
GOOD_BUFF           1180
HEX_ASCII_LOOPB     1316
HEX_ASCII_LOOPL     12D6
HEX_ASCII_LOOPW     12F6
HEX_TO_ASCII_B      130C
HEX_TO_ASCII_L      12CC
HEX_TO_ASCII_W      12EC
HIT_ENTER           26A2
HIT_ENTER_MSG       25C2
HT                  9
ILLEGAL             1194
ILLEGAL_DATA        26AE
IMMEDIATE_BTST      1414
IMM_MODE            7
IMM_REG             4
INTRO_MSG           247D
INTRO_STUFF         2442
INVALID             12C4
IS_LETTER           12B6
IS_NUMBER           12AE
JSR_CHECK           149A
LF                  A
LINE_COUNT          26AA
LOAD_BAD_INPUT      1364
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1B0E
MAIN_LOOP           1160
MAKE_LETTER         1344
MAKE_NUMBER         1338
ODD_ERR             1386
ODD_INPUT           2626
OP_ADD              16DC
OP_ADDQ             1632
OP_ADD_ADDR         1706
OP_ADD_ADDRESS_VERSION  1B22
OP_AND              19E6
OP_AS_MEM           1A20
OP_AS_REG           1A02
OP_BRANCH           187A
OP_BRA_CC           18BC
OP_BRA_CS           18D2
OP_BRA_EQ           18FE
OP_BRA_GE           196C
OP_BRA_GT           1998
OP_BRA_HIGH         1890
OP_BRA_LE           19AE
OP_BRA_LOW          18A6
OP_BRA_LT           1982
OP_BRA_MI           1956
OP_BRA_NE           18E8
OP_BRA_PL           1940
OP_BRA_VC           1914
OP_BRA_VS           192A
OP_BTST             171A
OP_CHECK_ADDRESS_VERSION  1B18
OP_CHECK_DATA_SIZE  1B28
OP_CHECK_DATA_SIZE_ADDR  1B48
OP_CMP              1AA4
OP_CMPI             1790
OP_CMP_ADDR         1ACE
OP_CODE_TREE        1398
OP_DIVS             166E
OP_EOR              1AE2
OP_EORI             1770
OP_JSR              1864
OP_LEA              17B0
OP_LS_MEM           1A56
OP_LS_REG           1A38
OP_MOVE             15E6
OP_MOVEM            17FE
OP_MOVEM_DATA       183E
OP_MOVE_DATA        1618
OP_MULS             19C4
OP_NEG              17C6
OP_NOT              17E2
OP_ORI              1734
OP_RO_MEM           1A8C
OP_RO_REG           1A6E
OP_RTS              1850
OP_SET_BAD_BUFFER   1AFE
OP_SET_DATA_BYTE    1B5A
OP_SET_DATA_LONG    1B6E
OP_SET_DATA_WORD    1B64
OP_SHIFT_DIRECTION  1B78
OP_SHIFT_LEFT       1B90
OP_SHIFT_RIGHT      1B8A
OP_SUB              169E
OP_SUBI             1750
OP_SUB_ADDR         16C8
OP_TAB              1B04
PROMPT_END          10B6
PROMPT_FOR_DATA     11D8
PROMPT_START        1060
PROMPT_TO_RERUN     11F6
PSYCHOBOTS1         22AA
PSYCHOBOTS2         22F9
PSYCHOBOTS3         234A
PSYCHOBOTS4         239C
PSYCHOBOTS5         23EF
RERUN_ERR_MSG       1250
RETURN              12C8
SINGLE_OPERATOR_CODES  145A
START               1000
START_ADDRESS       24F0
START_ERROR         1350
START_INPUT         268A
VALID_DATA          27EE
VALID_END           10FA
VALID_START         1094
VERIFIED            12BE
VERIFY_INPUT        126E
WORD_MODE           7
WORD_REG            0
