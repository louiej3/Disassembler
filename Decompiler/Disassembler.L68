00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/8/2014 6:23:36 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler - I/O Part
00000000                             3  * Written by : Blong Thao
00000000                             4  * Date       : 11/16/14
00000000                             5  * Description: This program asks for the starting address
00000000                             6  *               and the ending address, then reads the data
00000000                             7  *               in the specified range and disassembles the
00000000                             8  *               data in the memory to instructions.               
00000000                             9  *-----------------------------------------------------------
00000000  =0000000D                 10  CR              EQU     $0D                 ; Carriage return
00000000  =0000000A                 11  LF              EQU     $0A                 ; Line Feed
00000000  =00000009                 12  HT              EQU     $09                 ; Tab (horizontal 5 characters)
00000000  =00000000                 13  begin           EQU     $00000000           ; Lowest starting address
00000000  =00FFFFFE                 14  end             EQU     $00FFFFFE           ; Highest ending address
00000000  =00000000                 15  Dn_Mode         EQU     %000
00000000  =00000001                 16  An_Mode         EQU     %001
00000000  =00000002                 17  An_Pntr_Mode    EQU     %010
00000000  =00000003                 18  An_Inc_Mode     EQU     %011
00000000  =00000004                 19  An_Dec_Mode     EQU     %100
00000000  =00000007                 20  Word_Mode       EQU     %111
00000000  =00000000                 21  Word_Reg        EQU     %000
00000000  =00000007                 22  Long_Mode       EQU     %111
00000000  =00000001                 23  Long_Reg        EQU     %001
00000000  =00000007                 24  Imm_Mode        EQU     %111
00000000  =00000004                 25  Imm_Reg         EQU     %100
00000000                            26  
00001000                            27                  ORG     $1000
00001000                            28  START       
00001000                            29  *-----------Introduction Message----------------------------
00001000  43F9 000022C6             30                  LEA     psychobots1, A1     ; Load introduction
00001006  103C 000E                 31                  MOVE.B  #14, D0             ; Load task code for display
0000100A  4E4F                      32                  TRAP    #15                 ; Display introduction
0000100C  43F9 00002315             33                  LEA     psychobots2, A1     ; Load introduction
00001012  103C 000E                 34                  MOVE.B  #14, D0             ; Load task code for display
00001016  4E4F                      35                  TRAP    #15                 ; Display introduction
00001018  43F9 00002366             36                  LEA     psychobots3, A1     ; Load introduction
0000101E  103C 000E                 37                  MOVE.B  #14, D0             ; Load task code for display
00001022  4E4F                      38                  TRAP    #15                 ; Display introduction
00001024  43F9 000023B8             39                  LEA     psychobots4, A1     ; Load introduction
0000102A  103C 000E                 40                  MOVE.B  #14, D0             ; Load task code for display
0000102E  4E4F                      41                  TRAP    #15                 ; Display introduction
00001030  43F9 0000240B             42                  LEA     psychobots5, A1     ; Load introduction
00001036  103C 000E                 43                  MOVE.B  #14, D0             ; Load task code for display
0000103A  4E4F                      44                  TRAP    #15                 ; Display introduction
0000103C  43F9 0000245E             45                  LEA     intro_stuff, A1     ; Load introduction
00001042  103C 000E                 46                  MOVE.B  #14, D0             ; Load task code for display
00001046  4E4F                      47                  TRAP    #15                 ; Display introduction
00001048  43F9 00002499             48                  LEA     intro_msg, A1       ; Load introduction
0000104E  103C 000E                 49                  MOVE.B  #14, D0             ; Load task code for display
00001052  4E4F                      50                  TRAP    #15                 ; Display introduction
00001054  43F9 0000245E             51                  LEA     intro_stuff, A1     ; Load introduction
0000105A  103C 000D                 52                  MOVE.B  #13, D0             ; Load task code for display
0000105E  4E4F                      53                  TRAP    #15                 ; Display introduction
00001060                            54                  
00001060                            55  
00001060                            56  *-----------Prompt For Starting Address---------------------                  
00001060  43F9 0000250C             57  prompt_start    LEA     start_address,A1    ; Load prompt message for starting address
00001066  103C 000E                 58                  MOVE.B  #14,D0              ; Load task code for display
0000106A  4E4F                      59                  TRAP    #15                 ; Display prompt message
0000106C                            60                  
0000106C  43F9 000026A6             61                  LEA     start_input,A1      ; Load address to store user's input
00001072  103C 0002                 62                  MOVE.B  #2,D0               ; Load task code for user input
00001076  4E4F                      63                  TRAP    #15                 ; Ask for user input
00001078  4EB9 0000126E             64                  JSR     verify_input        ; Verifies user input string
0000107E  B83C 0001                 65                  CMP.B   #1,D4               ; If equal to 1, then that input is valid
00001082  6700 0010                 66                  BEQ     valid_start         ; Go to valid start if equal 
00001086                            67                  
00001086  43F9 0000260C             68                  LEA     badAddr_input,A1        ; Not equal to 1, its a bad input, start over
0000108C  103C 000E                 69                  MOVE.B  #14,D0              ; Load task code for display
00001090  4E4F                      70                  TRAP    #15                 ; Display bad input message
00001092  60CC                      71                  BRA     prompt_start        ; Go back beginning, asking for start address
00001094                            72  
00001094  4EB9 00001372             73  valid_start     JSR     chk_bound           ; Check if the input has odd/even bounds
0000109A  B67C FFFF                 74                  CMP.W   #-1,D3              ; If -1 in D3, then input was odd
0000109E  67C0                      75                  BEQ     prompt_start        ; Go back and ask for correct input
000010A0  7C00                      76                  MOVE.L  #begin,D6           ; Store minimum address in D6
000010A2  B686                      77                  CMP.L   D6,D3               ; If start address is lower than minimum address
000010A4  6D00 02AA                 78                  BLT     start_error         ; Then, start address is too low
000010A8  2C3C 00FFFFFE             79                  MOVE.L  #end,D6             ; Store max end address for comparison
000010AE  B686                      80                  CMP.L   D6,D3               ; If start address is lower than minimum address
000010B0  6E00 029E                 81                  BGT     start_error         ; Then, start address is too high
000010B4  2643                      82                  MOVEA.L D3,A3               ; Load starting address                 
000010B6                            83  
000010B6                            84  *-----------Prompt for Ending Address-----------------------            
000010B6  43F9 00002545             85  prompt_end      LEA     end_address1,A1     ; Load prompt msg for ending address(1/2)
000010BC  103C 000E                 86                  MOVE.B  #14,D0              ; Load task code for display
000010C0  4E4F                      87                  TRAP    #15                 ; Display prompt message
000010C2  43F9 000026A6             88                  LEA     start_input,A1      ; Load starting address
000010C8  4E4F                      89                  TRAP    #15                 ; Display starting address
000010CA  43F9 0000256C             90                  LEA     end_address2,A1     ; Load prompt msg for ending address(2/2)
000010D0  4E4F                      91                  TRAP    #15                 ; Display prompt message
000010D2  43F9 000026AE             92                  LEA     end_input,A1        ; Ask for ending address
000010D8  103C 0002                 93                  MOVE.B  #2,D0               ; Load task code for input
000010DC  4E4F                      94                  TRAP    #15                 ; Prompt for input
000010DE  4EB9 0000126E             95                  JSR     verify_input        ; Verifies user input string
000010E4  B83C 0001                 96                  CMP.B   #1,D4               ; If 1 in D4, then its valid
000010E8  6700 0010                 97                  BEQ     valid_end           ; Now validate the ending address
000010EC  43F9 0000260C             98                  LEA     badAddr_input,A1        ; Else, bad input
000010F2  103C 000E                 99                  MOVE.B  #14,D0              ; Load task code for display
000010F6  4E4F                     100                  TRAP    #15                 ; Display bad input message
000010F8  60BC                     101                  BRA     prompt_end          ; Restart process
000010FA                           102  
000010FA  4EB9 00001372            103  valid_end       JSR     chk_bound           ; Check if the input has odd/even bounds
00001100  B67C FFFF                104                  CMP.W   #-1,D3              ; If -1(FFFF), then it has odd bounds
00001104  67B0                     105                  BEQ     prompt_end          ; Go back and ask for correct input
00001106  2C3C 00FFFFFE            106                  MOVE.L  #end,D6             ; Move max address to compare with input
0000110C  B686                     107                  CMP.L   D6,D3               ; Is input higher than max
0000110E  6E00 024A                108                  BGT     end_error           ; Input address is too high
00001112  B68B                     109                  CMP.L   A3,D3               ; Is input at or above minimum address
00001114  6D00 0244                110                  BLT     end_error           ; Input address is too low
00001118  2843                     111                  MOVEA.L D3,A4               ; Load ending address
0000111A                           112                                 
0000111A                           113  ;-------------- disassemble ---------------------------------------------------
0000111A                           114  ; -- Reads the data from the specified memory locations
0000111A                           115  ; -- Passes the data over to OP-code to verify the instruction
0000111A                           116  ; -- Decodes the word data from the specified memory location until the end
0000111A                           117  ; -- Checks for illegal data and valid data with the bad buffer bit
0000111A                           118  ;------------------------------------------------------------------------------
0000111A  4283                     119  disassemble     CLR.L   D3                  ; Clear for IO usage
0000111C  4284                     120                  CLR.L   D4                  ; Clear for OP Code usage              
0000111E  B7CC                     121                  CMP.L   A4,A3               ; At the end address?
00001120  6E00 00D4                122                  BGT     prompt_to_rerun     ; Placeholder for printing out the instructions
00001124                           123                  
00001124  4EB9 000011C6            124                  JSR     check_10_lines      ; Prompt user to see more at 10 lines of data
0000112A  2C0B                     125                  MOVE.L  A3,D6               ; Store current address
0000112C                           126                  
0000112C  4DF9 000026CA            127                  LEA     illegal_data,A6     ; Load illegal data's address
00001132  4EB9 000012CC            128                  JSR     hex_to_ASCII_L      ; Store address to memory for display
00001138  204E                     129                  MOVEA.L A6,A0               ; Store current location of illegal data
0000113A                           130                  
0000113A  4BF9 0000280A            131                  LEA     valid_data,A5       ; Store current address to memory
00001140                           132                  
00001140  4DF9 0000280A            133                  LEA     valid_data,A6       ; Store current address to memory
00001146  4EB9 000012CC            134                  JSR     hex_to_ASCII_L      ; Store current address to memory as string
0000114C  1CFC 0009                135                  MOVE.B  #HT,(A6)+           ; Store a TAB
00001150                           136                  
00001150  381B                     137                  MOVE.W  (A3)+,D4            ; Read data from current memory location                
00001152  4EB9 00001398            138                  JSR     OP_CODE_TREE        ; Go to OP code jump table
00001158                           139                  
00001158  BE3C 0001                140                  CMP.B   #1,D7               ; Bad buffer set?
0000115C  6700 0036                141                  BEQ     ILLEGAL             ; Yes, go to ILLEGAL function                
00001160                           142  main_loop
00001160                           143                  ; Store new line in memory
00001160  1CFC 000A                144                  MOVE.B  #LF,(A6)+
00001164  1CFC 000D                145                  MOVE.B  #CR,(A6)+
00001168  BE3C 0001                146                  CMP.B   #1,D7               ; Bad buffer set?
0000116C  6600 0012                147                  BNE     good_buff           ; Good Buffer, go prep for display
00001170                           148                  
00001170  4287                     149  bad_buff        CLR.L   D7                  ; Reset bad buffer
00001172  1CFC 0000                150                  MOVE.B  #00,(A6)+           ; Add null terminator
00001176  43F9 000026CA            151                  LEA     illegal_data,A1     ; Load the illegal data for display
0000117C  6000 000C                152                  BRA     display_data        ; Go to display data
00001180                           153                  
00001180  1CFC 0000                154  good_buff       MOVE.B  #00,(A6)+           ; Add null terminator
00001184  43F9 0000280A            155                  LEA     valid_data,A1       ; Load the valid data for display
0000118A                           156                  
0000118A  4280                     157  display_data    CLR.L   D0                  ; Clear for TASK TRAP
0000118C  103C 000E                158                  MOVE.B  #14,D0              ; Display the data that A1 is pointing
00001190  4E4F                     159                  TRAP    #15                 ; to in memory.
00001192  6086                     160                  BRA     disassemble         ; Done disassembling the word, next word                
00001194                           161                                                 
00001194                           162  ILLEGAL         ; word data from memory is not a required instruction
00001194  4BF9 000026CA            163                  LEA     illegal_data,A5     ; Store current address to memory
0000119A  2C48                     164                  MOVEA.L A0,A6               ; Use A6 to write illegal data                
0000119C  1CFC 0009                165                  MOVE.B  #HT,(A6)+           ; Store TAB 
000011A0  1CFC 0044                166                  MOVE.B  #'D',(A6)+          ; Store DATA
000011A4  1CFC 0041                167                  MOVE.B  #'A',(A6)+
000011A8  1CFC 0054                168                  MOVE.B  #'T',(A6)+
000011AC  1CFC 0041                169                  MOVE.B  #'A',(A6)+
000011B0  4EB9 00001B20            170                  JSR     OP_TAB              ; Set up third collumn
000011B6  1CFC 0024                171                  MOVE.B  #'$',(A6)+
000011BA                           172                  
000011BA                           173                  ; Store 4 hex digits that represent the word into memory
000011BA  4286                     174                  CLR.L   D6
000011BC  3C04                     175                  MOVE.W  D4,D6               ; Move the word data into D6 for conversion
000011BE  4EB9 000012EC            176                  JSR     hex_to_ASCII_W      ; Converts hex to ascii for the word data
000011C4  609A                     177                  BRA     main_loop           ; Store info to memory as string              
000011C6                           178  
000011C6                           179  ;------------check_10_lines----------------------------------------------------
000011C6                           180  ; -- Prompt user to hit enter when there are 10 lines of data
000011C6                           181  ; -- Then reset the line count and go back to disassemble more data
000011C6                           182  ;------------------------------------------------------------------------------
000011C6                           183  check_10_lines
000011C6  45F9 000026C6            184                  LEA     line_count,A2       ; Assign A2 pointer for line count
000011CC  5212                     185                  ADD.B   #1,(A2)             ; Increment counter
000011CE  0C12 0014                186                  CMP.B   #20,(A2)            ; Has counter reached 31 yet?
000011D2  6700 0004                187                  BEQ     prompt_for_data     ; At 31
000011D6  4E75                     188                  RTS                         ; Return to disassemble
000011D8                           189  
000011D8  43F9 000025DE            190  prompt_for_data LEA     hit_enter_msg,A1    ; Ask user to hit enter
000011DE  103C 000E                191                  MOVE.B  #14,D0              ; Display message
000011E2  4E4F                     192                  TRAP    #15
000011E4  43F9 000026BE            193                  LEA     hit_enter,A1        ; Take user input
000011EA  103C 0002                194                  MOVE.B  #2,D0               
000011EE  4E4F                     195                  TRAP    #15
000011F0  14BC 0000                196                  MOVE.B  #0,(A2)             ; Reset counter
000011F4  4E75                     197                  RTS                         ; Return to disassemble
000011F6                           198  
000011F6                           199  ;------------prompt_to_rerun----------------------------------------------------
000011F6                           200  ; -- Prompt user to rerun or end program
000011F6                           201  ;------------------------------------------------------------------------------
000011F6  43F9 000025AE            202  prompt_to_rerun LEA     ask_user,A1         ; Load ask user message to rerun 
000011FC  103C 000E                203                  MOVE.B  #14,D0
00001200  4E4F                     204                  TRAP    #15
00001202  43F9 000026B6            205                  LEA     ask_input,A1        ; Take user input
00001208  103C 0002                206                  MOVE.B  #2,D0
0000120C  4E4F                     207                  TRAP    #15
0000120E  45F9 000026C6            208                  LEA     line_count,A2       ; Load line count to reset
00001214  14BC 0000                209                  MOVE.B  #0,(A2)             ; Reset the line_count
00001218  B23C 0001                210                  CMP.B   #1,D1               ; User input must be the length of 1
0000121C  6E00 0032                211                  BGT     rerun_err_msg       ; Otherwise, will prompt msg again
00001220  6D00 002E                212                  BLT     rerun_err_msg       ; until the user inputs correctly.
00001224  4240                     213                  CLR     D0                  ; Clear D0 for comparison
00001226  1039 000026B6            214                  MOVE.B  ask_input,D0        ; Load user input for comparison
0000122C  B03C 004E                215                  CMP.B   #'N',D0             ; User input is N
00001230  6700 002C                216                  BEQ     done                ; End of program if N
00001234  B03C 006E                217                  CMP.B   #'n',D0             ; User input is n
00001238  6700 0024                218                  BEQ     done                ; End of program if n
0000123C  B03C 0059                219                  CMP.B   #'Y',D0             ; User input is Y
00001240  6700 FE1E                220                  BEQ     prompt_start        ; Run the program again
00001244  B03C 0079                221                  CMP.B   #'y',D0             ; User input is y
00001248  6700 FE16                222                  BEQ     prompt_start        ; Run the program again
0000124C  6000 0002                223                  BRA     rerun_err_msg       ; Bad input, prompt user
00001250                           224                  
00001250  43F9 0000266E            225  rerun_err_msg   LEA     ask_error,A1        ; Bad input, display error message
00001256  103C 000E                226                  MOVE.B  #14,D0
0000125A  4E4F                     227                  TRAP    #15
0000125C  6098                     228                  BRA     prompt_to_rerun     ; Prompt user for rerun           
0000125E                           229                  
0000125E                           230      
0000125E                           231  ;------------End-of-Program----------------------------------------------------                
0000125E  43F9 0000257C            232  done            LEA     ending,A1           ; Load ending message
00001264  103C 000D                233                  MOVE.B  #13,D0              ; Load task code for display
00001268  4E4F                     234                  TRAP    #15                 ; Display ending message
0000126A  4E72 2700                235                  STOP    #$00002700          ; End of program
0000126E                           236                  
0000126E                           237  ;-----------Verify/ConvertASCIItoHex-------------------------------------------
0000126E  4283                     238  verify_input    CLR.L   D3                  ; D3 will hold valid user input chars
00001270  4285                     239                  CLR.L   D5                  ; D5 will be used as a NULL comparison
00001272  B205                     240                  CMP.B   D5,D1               ; Check input length, if lower than one
00001274  6700 004E                241                  BEQ     invalid             ; Its an invalid input
00001278  0C41 0008                242                  CMPI    #$8,D1              ; Check input length, if higher than 8
0000127C  6E00 0046                243                  BGT     invalid             ; Its an invalid input
00001280                           244                  
00001280  4282                     245  check_input     CLR.L   D2                  ; Clear D2 to store chars from user input
00001282  1419                     246                  MOVE.B  (A1)+,D2            ; Move next char to D2 to validate
00001284  B405                     247                  CMP.B   D5,D2               ; Check to see if next char is null(0)
00001286  6700 0040                248                  BEQ     return              ; Character is null, end of input
0000128A                           249                  
0000128A  B43C 0046                250                  CMP.B   #70,D2              ; Invalid character if decimal value
0000128E  6E00 0034                251                  BGT     invalid             ; is higher than 70.
00001292  B43C 0040                252                  CMP.B   #64,D2              ; Is a letter if decimal value is 
00001296  6E00 001E                253                  BGT     is_letter           ; between 65 - 70.
0000129A                           254                  
0000129A  B43C 0039                255                  CMP.B   #57,D2              ; Invalid character if decimal value is
0000129E  6E00 0024                256                  BGT     invalid             ; between 58 - 64
000012A2  B43C 002F                257                  CMP.B   #47,D2              ; Is a number if decimal value is 
000012A6  6E00 0006                258                  BGT     is_number           ; between 48 - 57.
000012AA  6000 0018                259                  BRA     invalid             ; Decimal values below 48 are invalid 
000012AE                           260                               
000012AE  0402 0030                261  is_number       SUBI.B  #48,D2              ; Convert ASCII to Hex, 0-9
000012B2  6000 000A                262                  BRA     verified            ; Put character into a register
000012B6                           263                               
000012B6  0402 0037                264  is_letter       SUBI.B  #55,D2              ; Convert ASCII to HEX, A-F
000012BA  6000 0002                265                  BRA     verified            ; Put character into a register
000012BE                           266                 
000012BE  E983                     267  verified        ASL.L   #4,D3               ; Shift hex bit left one
000012C0  D602                     268                  ADD.B   D2,D3               ; Add to verified register
000012C2  60BC                     269                  BRA     check_input         ; Check the rest of the input                       
000012C4                           270                  
000012C4  7800                     271  invalid         MOVEQ   #0,D4               ; Invalid address
000012C6  4E75                     272                  RTS                         ; Return to start/end prompt
000012C8                           273                  
000012C8  7801                     274  return          MOVEQ   #1,D4               ; Valid address
000012CA  4E75                     275                  RTS                         ; Return to start/end prompt
000012CC                           276                  
000012CC                           277  ;----------------------------------------------------------
000012CC                           278  ; Convert Hexidecimal to ASCII (Stores into Memory)
000012CC                           279  ;
000012CC                           280  ; -- At the moment, takes the Illegal data and stores 
000012CC                           281  ;    it into memory so that it can be printed later
000012CC                           282  ;----------------------------------------------------------
000012CC  4281                     283  hex_to_ASCII_L  CLR.L   D1                      ; Used for shifting right
000012CE  4282                     284                  CLR.L   D2                      ; Used for shifting left
000012D0  4283                     285                  CLR.L   D3                      ; Counter
000012D2  123C 001C                286                  MOVE.B  #28,D1                  ; Shift right by 7 hex digits                  
000012D6                           287  hex_ASCII_loopL
000012D6  B63C 0008                288                  CMP.B   #8,D3                   ; Done converting?
000012DA  6700 0072                289                  BEQ     done_converting         ; If equal to 8, done
000012DE  2006                     290                  MOVE.L  D6,D0                   ; Do calculations in D0
000012E0  E5A8                     291                  LSL.L   D2,D0                   ; Eliminate stuff to the left
000012E2  E2A8                     292                  LSR.L   D1,D0                   ; Isolate number
000012E4  4EB9 0000132C            293                  JSR     convert_hex
000012EA  60EA                     294                  BRA     hex_ASCII_loopL
000012EC                           295                  
000012EC  4281                     296  hex_to_ASCII_W  CLR.L   D1                      ; Used for shifting right
000012EE  4282                     297                  CLR.L   D2                      ; Used for shifting left
000012F0  4283                     298                  CLR.L   D3                      ; Counter
000012F2  123C 000C                299                  MOVE.B  #12,D1                  ; Shift right by 3 hex digits                  
000012F6                           300  hex_ASCII_loopW
000012F6  B63C 0004                301                  CMP.B   #4,D3                   ; Done converting?
000012FA  6700 0052                302                  BEQ     done_converting         ; If equal to 4, done
000012FE  2006                     303                  MOVE.L  D6,D0                   ; Do calculations in D0
00001300  E568                     304                  LSL.W   D2,D0                   ; Eliminate stuff to the left
00001302  E268                     305                  LSR.W   D1,D0                   ; Isolate number
00001304  4EB9 0000132C            306                  JSR     convert_hex
0000130A  60EA                     307                  BRA     hex_ASCII_loopW
0000130C                           308  
0000130C  4281                     309  hex_to_ASCII_B  CLR.L   D1                      ; Used for shifting right
0000130E  4282                     310                  CLR.L   D2                      ; Used for shifting left
00001310  4283                     311                  CLR.L   D3                      ; Counter
00001312  123C 0004                312                  MOVE.B  #4,D1                   ; Shift right by 1 hex digits                  
00001316                           313  hex_ASCII_loopB
00001316  B63C 0002                314                  CMP.B   #2,D3                   ; Done converting?
0000131A  6700 0032                315                  BEQ     done_converting         ; If equal to 2, done
0000131E  2006                     316                  MOVE.L  D6,D0                   ; Do calculations in D0
00001320  E528                     317                  LSL.B   D2,D0                   ; Eliminate stuff to the left
00001322  E228                     318                  LSR.B   D1,D0                   ; Isolate number
00001324  4EB9 0000132C            319                  JSR     convert_hex
0000132A  60EA                     320                  BRA     hex_ASCII_loopB                  
0000132C                           321  
0000132C  B03C 000A                322  convert_hex     CMP.B   #$A,D0                  ; What should I make this hex digit?
00001330  6D00 0006                323                  BLT     make_number             ; Make it a number, if lower than 10
00001334  6C00 000E                324                  BGE     make_letter             ; Make it a letter, if greater than or eqaul to 10
00001338                           325                       
00001338  0600 0030                326  make_number     ADD.B   #48,D0                  ; Convert to Ascii (0-9)
0000133C  1CC0                     327                  MOVE.B  D0,(A6)+                ; Store in memory
0000133E  5203                     328                  ADD.B   #1,D3                   ; Add to counter
00001340  5802                     329                  ADD.B   #4,D2                   ; Shift left by one digit
00001342  4E75                     330                  RTS                             ; Check next number
00001344                           331                  
00001344  0600 0037                332  make_letter     ADD.B   #55,D0                  ; Convert to Ascii (0-9)
00001348  1CC0                     333                  MOVE.B  D0,(A6)+                ; Store to memory
0000134A  5203                     334                  ADD.B   #1,D3                   ; Add to counter
0000134C  5802                     335                  ADD.B   #4,D2                   ; Shift left by one digit                 
0000134E  4E75                     336  done_converting RTS                             ; Check next number              
00001350                           337  
00001350                           338  ;-----------Error Messages ----------------------------------------------------
00001350  4EB9 00001364            339  start_error     JSR     load_bad_input      ; Print bad input error message
00001356  4EF8 1060                340                  JMP     prompt_start        ; Return to prompt for start address
0000135A                           341                  
0000135A  4EB9 00001364            342  end_error       JSR     load_bad_input      ; Print bad input error message
00001360  4EF8 10B6                343                  JMP     prompt_end          ; Return to prompt for end address
00001364                           344  
00001364  43F9 0000260C            345  load_bad_input  LEA     badAddr_input,A1    ; Load bad input message
0000136A  103C 000D                346                  MOVE.B  #13,D0              ; Load task code for display
0000136E  4E4F                     347                  TRAP    #15                 ; Display bad input message
00001370  4E75                     348                  RTS                         ; Return to (start/end)_error
00001372                           349  
00001372  4282                     350  chk_bound       CLR.L   D2                  ; Clear buffer before usage
00001374  3403                     351                  MOVE.W  D3,D2               ; Put address in D2 for calulation
00001376  7202                     352                  MOVE.L  #2,D1               ; Load 2 into D1 for division
00001378  84C1                     353                  DIVU    D1,D2               ; Divide address by 2
0000137A  4842                     354                  SWAP    D2                  ; Swap contents of D2 to get remainder
0000137C  B43C 0001                355                  CMP.B   #$01,D2             ; Check remainder, if one then address is odd
00001380  6700 0004                356                  BEQ     odd_err             ; Go to print out odd bound error message
00001384  4E75                     357                  RTS                         ; Return to valid_(start/end)
00001386                           358                  
00001386  43F9 00002642            359  odd_err         LEA     odd_input,A1        ; Load odd input message
0000138C  103C 000E                360                  MOVE.B  #14,D0              ; Load task code for display
00001390  4E4F                     361                  TRAP    #15                 ; Display odd input message
00001392  4685                     362                  NOT.L   D5                  ; Change D5 to -1(FFFF) to return as bad address
00001394  2605                     363                  MOVE.L  D5,D3               ; Load -1 to returned data register
00001396  4E75                     364                  RTS                         ; Return to valid_(start/end)
00001398                           365  
00001398                           366  OP_CODE_TREE    ; Parses the Op-Code to find what it is
00001398                           367          
00001398  B8BC 00004E75            368          Cmp.L   #$4E75, D4         ; Check for RTS (non-variable op-codes)
0000139E  6700 04BE                369          Beq     OP_RTS
000013A2                           370  
000013A2  4EB9 0000218C            371          Jsr     GET12TO15
000013A8                           372          
000013A8  B03C 0000                373          Cmp.B     #%0000, D0       ; first 4 is 0000, not enough info Immediates
000013AC  6700 0066                374          Beq     IMMEDIATE_BTST
000013B0                           375          
000013B0  B03C 0001                376          Cmp.B     #%0001, D0       ; Move.B & MoveA.B
000013B4  6700 023E                377          Beq     OP_MOVE
000013B8                           378          
000013B8  B03C 0003                379          Cmp.B     #%0011, D0       ; Move.W & MoveA.W
000013BC  6700 0236                380          Beq     OP_MOVE
000013C0                           381  
000013C0  B03C 0002                382          Cmp.B     #%0010, D0       ; Move.L & MoveA.L
000013C4  6700 022E                383          Beq     OP_MOVE
000013C8                           384          
000013C8  B03C 0004                385          Cmp.B     #%0100, D0       ; not enough info, Single OPs
000013CC  6700 009A                386          Beq     SINGLE_OPERATOR_CODES
000013D0                           387      
000013D0  B03C 0006                388          Cmp.B     #%0110, D0       ; Beqnch conditionals
000013D4  6700 00E4                389          Beq     BRANCH_CONDITIONALS
000013D8                           390          
000013D8  B03C 000C                391          Cmp.B     #%1100, D0       ; not enough info, AND or MULS
000013DC  6700 015E                392          Beq     AND_MULS
000013E0                           393          
000013E0  B03C 000E                394          Cmp.B     #%1110, D0       ; not enough info, bit shifts
000013E4  6700 0196                395          Beq     BIT_SHIFT
000013E8                           396          
000013E8  B03C 0005                397          Cmp.B     #%0101, D0       ; Add Quick
000013EC  6700 0252                398          Beq     OP_ADDQ
000013F0                           399          
000013F0  B03C 0008                400          Cmp.B     #%1000, D0       ; Signed Divide
000013F4  6700 0286                401          Beq     OP_DIVS
000013F8                           402          
000013F8  B03C 0009                403          Cmp.B     #%1001, D0       ; Sub & SubA
000013FC  6700 02AE                404          Beq     OP_SUB
00001400                           405          
00001400  B03C 000B                406          Cmp.B     #%1011, D0       ; Cmp.B & Cmp.BA & Eor
00001404  6700 01CC                407          Beq     CMP_EOR
00001408                           408          
00001408  B03C 000D                409          Cmp.B     #%1101, D0       ; Add & AddA
0000140C  6700 02DC                410          Beq     OP_ADD
00001410                           411          
00001410  6000 0708                412          Bra     OP_SET_BAD_BUFFER         ; If the first 4 has not been covered, then the code is illegal
00001414                           413          
00001414                           414  IMMEDIATE_BTST  ; Continue through Op-code Tree, first 4 are 0000
00001414                           415          
00001414  4EB9 000021CE            416          Jsr     GET6TO8         ; Change out test bits
0000141A                           417          
0000141A  B03C 0004                418          Cmp.B     #%100, D0          ; Bit test
0000141E  6700 0308                419          Beq     OP_BTST
00001422                           420          
00001422  4EB9 000022B4            421          Jsr     GET6TO11
00001428                           422          
00001428  B03C 0020                423          Cmp.B   #%100000,D0     ;BTST
0000142C  6700 02FA                424          Beq     OP_BTST
00001430                           425          
00001430  4EB9 00002204            426          Jsr     GETBIT8
00001436  B03C 0001                427          Cmp.B   #%1,D0
0000143A  6700 06DE                428          Beq     OP_SET_BAD_BUFFER   ; All other Bit test functions are not required
0000143E                           429          
0000143E  4EB9 000021BC            430          Jsr     GET9TO11        ; Change out test bits
00001444                           431          
00001444  B03C 0000                432          Cmp.B     #%000, D0        ; Or I
00001448  6700 02F8                433          Beq     OP_ORI
0000144C                           434          
0000144C  B03C 0002                435          Cmp.B     #%010, D0        ; Subtract I
00001450  6700 030C                436          Beq     OP_SUBI
00001454                           437          
00001454  B03C 0005                438          Cmp.B     #%101, D0        ; Exclusive or, I
00001458  6700 0324                439          Beq     OP_EORI
0000145C                           440          
0000145C  B03C 0006                441          Cmp.B     #%110, D0        ; Compare I
00001460  6700 033C                442          Beq     OP_CMPI
00001464                           443          
00001464  6000 06B4                444          Bra     OP_SET_BAD_BUFFER         ; Everything else is uncovered
00001468                           445          
00001468                           446  SINGLE_OPERATOR_CODES   ; Continue through Op-code Tree, first 4 are 0100
00001468                           447  
00001468  4EB9 00002204            448          Jsr     GETBIT8        ; Change out test bits
0000146E                           449          
0000146E  B03C 0001                450          Cmp.B     #%1, D0      ; Load effetive address
00001472  6700 034A                451          Beq     OP_LEA
00001476                           452                  
00001476  4EB9 000021BC            453          Jsr     GET9TO11       ; Change out test bits        
0000147C                           454  
0000147C  B03C 0002                455          Cmp.B     #%010, D0    ; Negate
00001480  6700 0352                456          Beq     OP_NEG
00001484                           457         
00001484  B03C 0003                458          Cmp.B     #%011, D0    ; Not
00001488  6700 0366                459          Beq     OP_NOT
0000148C                           460          
0000148C  B03C 0004                461          Cmp.B     #%100, D0    ; Move multiple registers Registers -> Memory
00001490  6700 037A                462          Beq     OP_MOVEM
00001494                           463          
00001494  B03C 0006                464          Cmp.B     #%110, D0    ; Move multiple registers Memory -> Registers
00001498  6700 0372                465          Beq     OP_MOVEM
0000149C                           466          
0000149C  B03C 0007                467          Cmp.B     #%111, D0    ; JSR
000014A0  6700 0006                468          Beq     JSR_CHECK   ; A second check for JSR   
000014A4                           469          
000014A4  6000 0674                470          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
000014A8                           471  
000014A8                           472  JSR_CHECK     ; Continue through OP tree, first 4 are 0100, 8-11 are 1110
000014A8                           473  
000014A8  4EB9 000021CE            474          Jsr     GET6TO8        ; Change out test bits
000014AE                           475          
000014AE  B03C 0002                476          Cmp.B     #%010, D0    ; Jump to Subroutine
000014B2  6700 03BE                477          Beq     OP_JSR
000014B6                           478          
000014B6  6000 0662                479          Bra     OP_SET_BAD_BUFFER     ; Everything else is uncovered
000014BA                           480  
000014BA                           481  BRANCH_CONDITIONALS     ; All Branch conditionals, and BRA. first 4 are 0110
000014BA                           482  
000014BA  4EB9 000021AA            483          Jsr     GET8TO11    ; Change out test bits        
000014C0                           484  
000014C0  B03C 0000                485          Cmp.B     #%0000, D0   ; Branch
000014C4  6700 03C2                486          Beq     OP_BRANCH      
000014C8                           487          
000014C8  B03C 0002                488          Cmp.B     #%0010, D0   ; High
000014CC  6700 03D0                489          Beq     OP_BRA_HIGH
000014D0                           490          
000014D0  B03C 0003                491          Cmp.B     #%0011, D0   ; Low/same
000014D4  6700 03DE                492          Beq     OP_BRA_LOW
000014D8                           493          
000014D8  B03C 0004                494          Cmp.B     #%0100, D0   ; Carry Clear
000014DC  6700 03EC                495          Beq     OP_BRA_CC
000014E0                           496          
000014E0  B03C 0005                497          Cmp.B     #%0101, D0   ; Carry Set
000014E4  6700 03FA                498          Beq     OP_BRA_CS
000014E8                           499          
000014E8  B03C 0006                500          Cmp.B     #%0110, D0   ; Not Equal
000014EC  6700 0408                501          Beq     OP_BRA_NE
000014F0                           502          
000014F0  B03C 0007                503          Cmp.B     #%0111, D0   ; Equal
000014F4  6700 0416                504          Beq     OP_BRA_EQ
000014F8                           505          
000014F8  B03C 0008                506          Cmp.B     #%1000, D0   ; Overflow Clear
000014FC  6700 0424                507          Beq     OP_BRA_VC
00001500                           508          
00001500  B03C 0009                509          Cmp.B     #%1001, D0   ; Overflow Set
00001504  6700 0432                510          Beq     OP_BRA_VS
00001508                           511          
00001508  B03C 000A                512          Cmp.B     #%1010, D0   ; Plus
0000150C  6700 0440                513          Beq     OP_BRA_PL
00001510                           514          
00001510  B03C 000B                515          Cmp.B     #%1011, D0   ; Minus
00001514  6700 044E                516          Beq     OP_BRA_MI
00001518                           517          
00001518  B03C 000C                518          Cmp.B     #%1100, D0   ; Greater than or Equal
0000151C  6700 045C                519          Beq     OP_BRA_GE
00001520                           520          
00001520  B03C 000D                521          Cmp.B     #%1101, D0   ; Less Than
00001524  6700 046A                522          Beq     OP_BRA_LT
00001528                           523          
00001528  B03C 000E                524          Cmp.B     #%1110, D0   ; Greater Than
0000152C  6700 0478                525          Beq     OP_BRA_GT
00001530                           526          
00001530  B03C 000F                527          Cmp.B     #%1111, D0   ; Less than or Equal
00001534  6700 0486                528          Beq     OP_BRA_LE
00001538                           529          
00001538  6000 05E0                530          Bra     OP_SET_BAD_BUFFER     ; Not including False* because it makes no sense
0000153C                           531  
0000153C                           532  AND_MULS        ; Continue through the Op-code Tree, The first four bits are 1100
0000153C                           533  
0000153C  4EB9 000022A2            534          Jsr     Get3TO8
00001542                           535          
00001542  B03C 0021                536          Cmp.B     #%100001, D0   ; ABCD
00001546  6700 05D2                537          Beq     OP_SET_BAD_BUFFER        
0000154A  B03C 0020                538          Cmp.B     #%100000,D0    ; ABCD
0000154E  6700 05CA                539          Beq     OP_SET_BAD_BUFFER        
00001552  B03C 0028                540          Cmp.B     #%101000,D0    ; EXG
00001556  6700 05C2                541          Beq     OP_SET_BAD_BUFFER
0000155A  B03C 0029                542          Cmp.B     #%101001,D0    ; EXG
0000155E  6700 05BA                543          Beq     OP_SET_BAD_BUFFER
00001562  B03C 0031                544          Cmp.B     #%110001,D0    ; EXG
00001566  6700 FC2C                545          Beq     ILLEGAL        
0000156A                           546  
0000156A  4EB9 000021CE            547          Jsr     GET6TO8        ; Change out test bits        
00001570                           548  
00001570  B03C 0007                549          Cmp.B     #%111, D0    ; Multiply signed
00001574  6700 045C                550          Beq     OP_MULS
00001578                           551          
00001578  6000 047A                552          Bra     OP_AND      ; Probably AND, check more in OP_AND
0000157C                           553          
0000157C                           554  BIT_SHIFT        ; Continue through the Op-code Tree, The first four bits are 1110
0000157C                           555          
0000157C                           556          ; Determine if the shift is Register or Memory shifting
0000157C                           557          
0000157C  4EB9 00002228            558          Jsr     GET6AND7
00001582                           559          
00001582  B03C 0003                560          Cmp.B   #%11, D0        ; If the data size field is 11, its Memory
00001586  6700 0006                561          Beq     BIT_SHIFT_MEM
0000158A                           562  
0000158A  6000 0024                563          Bra     BIT_SHIFT_REG   ; In all other cases, its register shift
0000158E                           564  
0000158E                           565  BIT_SHIFT_MEM
0000158E                           566          
0000158E  4EB9 00002216            567          Jsr     GET9AND10         ; Change out test bits
00001594                           568          
00001594  B03C 0000                569          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
00001598  6700 0494                570          Beq     OP_AS_MEM
0000159C                           571          
0000159C  B03C 0001                572          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
000015A0  6700 04C2                573          Beq     OP_LS_MEM
000015A4                           574          
000015A4  B03C 0003                575          Cmp.B     #%11, D0        ; Rotate (Left or Right)
000015A8  6700 04F0                576          Beq     OP_RO_MEM
000015AC                           577          
000015AC  6000 056C                578          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
000015B0                           579  
000015B0                           580  BIT_SHIFT_REG
000015B0                           581          
000015B0  4EB9 0000224C            582          Jsr     GET3AND4        ; Change out test bits
000015B6                           583          
000015B6  B03C 0000                584          Cmp.B     #%00, D0        ; Arithmetic Shifts (Left or Right)
000015BA  6700 0454                585          Beq     OP_AS_REG
000015BE                           586          
000015BE  B03C 0001                587          Cmp.B     #%01, D0        ; Logical Shift (Left or Right)
000015C2  6700 0482                588          Beq     OP_LS_REG
000015C6                           589          
000015C6  B03C 0003                590          Cmp.B     #%11, D0        ; Rotate (Left or Right)
000015CA  6700 04B0                591          Beq     OP_RO_REG
000015CE                           592          
000015CE  6000 054A                593          Bra     OP_SET_BAD_BUFFER         ; Otherwise it is not an accepted command
000015D2                           594  CMP_EOR     ; Continue through the Op-code Tree, The first four bits are 1011     
000015D2                           595          
000015D2  4EB9 000021CE            596          Jsr     GET6TO8         ; Change out test bits
000015D8                           597          
000015D8  B03C 0004                598          Cmp.B     #%100, D0         ; If bit 8 is 1, It much be EOR
000015DC  6700 0512                599          Beq     OP_EOR
000015E0                           600          
000015E0  B03C 0005                601          Cmp.B     #%101,D0
000015E4  6700 050A                602          Beq     OP_EOR
000015E8                           603          
000015E8  B03C 0006                604          Cmp.B     #%110,D0
000015EC  6700 0502                605          Beq     OP_EOR
000015F0                           606          
000015F0                           607          
000015F0  6000 04C0                608          Bra     OP_CMP          ; Otherwise, it must be Cmp.B or Cmp.BA
000015F4                           609  
000015F4                           610  ;---------------------OP_CODE Functions---------------------;
000015F4                           611  ; These Functions have all determined what Op-code or group
000015F4                           612  ; of op-codes I have. The next goal is to Add to the string
000015F4                           613  ; and call the accompying EA function to get the rest of the
000015F4                           614  ; String
000015F4                           615  
000015F4                           616  ; REGISTERS USED: D0, D4 (const), A6
000015F4                           617  
000015F4                           618  ;-----------------------  MOVE  -----------------------------;
000015F4                           619  OP_MOVE
000015F4                           620      ; start string
000015F4                           621      
000015F4  1CFC 004D                622          Move.B  #'M', (A6)+
000015F8  1CFC 004F                623          Move.B  #'O', (A6)+
000015FC  1CFC 0056                624          Move.B  #'V', (A6)+
00001600  1CFC 0045                625          Move.B  #'E', (A6)+
00001604                           626      
00001604                           627      ; is it an address move?
00001604  4EB9 000021CE            628          Jsr     GET6TO8     ; Get the mode
0000160A  4EB9 00001B34            629          Jsr     OP_CHECK_ADDRESS_VERSION ; Check for A version
00001610                           630          
00001610                           631      ; Check data size, Normally i would call OP_CHECK_DATA_SIZE
00001610                           632      ; But move does not use the Op-mode bits, so i'll do it manually
00001610                           633      
00001610  4EB9 0000218C            634          Jsr     GET12TO15
00001616                           635  
00001616                           636          ; Jump to a sub routine to get the data, so it returns back correctly
00001616  4EB9 00001626            637          Jsr     OP_MOVE_DATA
0000161C                           638          
0000161C                           639          ; Put in tabs
0000161C  4EB9 00001B20            640          Jsr     OP_TAB
00001622                           641          
00001622                           642          ; Hand the function off to John
00001622  6000 058E                643          BRA     EA_MOVE        
00001626                           644  
00001626                           645  OP_MOVE_DATA
00001626                           646          
00001626  B07C 0001                647          Cmp     #%0001, D0
0000162A  6700 054A                648          Beq     OP_SET_DATA_BYTE
0000162E                           649          
0000162E  B07C 0002                650          Cmp     #%0010, D0
00001632  6700 0556                651          Beq     OP_SET_DATA_LONG
00001636                           652          
00001636  B07C 0003                653          Cmp     #%0011, D0
0000163A  6700 0544                654          Beq     OP_SET_DATA_WORD
0000163E                           655          
0000163E  4E75                     656          Rts
00001640                           657  
00001640                           658  ;-----------------------  ADDQ  -----------------------------;
00001640                           659          
00001640                           660  OP_ADDQ
00001640                           661      ; Check fringe cases
00001640  4EB9 00002204            662          Jsr     GETBIT8
00001646  B03C 0001                663          Cmp.B   #%1,D0
0000164A  6700 04CE                664          Beq     OP_SET_BAD_BUFFER        
0000164E  4EB9 00002228            665          Jsr     GET6AND7
00001654  B03C 0003                666          Cmp.B   #%11,D0
00001658  6700 04C0                667          Beq     OP_SET_BAD_BUFFER       
0000165C                           668  
0000165C                           669      ; start string
0000165C                           670      
0000165C  1CFC 0041                671          Move.B  #'A', (A6)+
00001660  1CFC 0044                672          Move.B  #'D', (A6)+
00001664  1CFC 0044                673          Move.B  #'D', (A6)+
00001668  1CFC 0051                674          Move.B  #'Q', (A6)+
0000166C                           675          
0000166C                           676      ; Check data type        
0000166C  4EB9 00001B44            677          Jsr     OP_CHECK_DATA_SIZE
00001672                           678          
00001672                           679      ; Put in tabs
00001672  4EB9 00001B20            680          Jsr     OP_TAB
00001678                           681          
00001678                           682      ; Hand the function off to John
00001678  6000 0838                683          BRA     EA_ADDQ
0000167C                           684  
0000167C                           685      
0000167C                           686  ;------------------  DIVIDE SINGED  -------------------------;
0000167C                           687      
0000167C                           688  OP_DIVS
0000167C                           689      ; One last check to make sure I have the right stuff
0000167C                           690      
0000167C  4EB9 000021CE            691          Jsr     GET6TO8
00001682  B07C 0007                692          Cmp     #%111,D0
00001686  6600 0492                693          Bne     OP_SET_BAD_BUFFER
0000168A                           694          
0000168A                           695      ; start string
0000168A                           696      
0000168A  1CFC 0044                697          Move.B  #'D', (A6)+
0000168E  1CFC 0049                698          Move.B  #'I', (A6)+
00001692  1CFC 0056                699          Move.B  #'V', (A6)+
00001696  1CFC 0053                700          Move.B  #'S', (A6)+
0000169A  1CFC 002E                701          Move.B  #'.', (A6)+
0000169E  1CFC 0057                702          Move.B  #'W', (A6)+
000016A2                           703          
000016A2                           704      ; Put in tabs
000016A2  4EB9 00001B20            705          Jsr     OP_TAB    
000016A8                           706      
000016A8                           707      ; Handoff to John
000016A8                           708          
000016A8  6000 0948                709          BRA     EA_DIVS
000016AC                           710  
000016AC                           711      
000016AC                           712  ;-----------------------  SUB  ------------------------------;    
000016AC                           713      
000016AC                           714  OP_SUB
000016AC                           715      ; start string
000016AC                           716      
000016AC  1CFC 0053                717          Move.B  #'S', (A6)+
000016B0  1CFC 0055                718          Move.B  #'U', (A6)+
000016B4  1CFC 0042                719          Move.B  #'B', (A6)+
000016B8                           720  
000016B8                           721  
000016B8                           722       ; Check for address version
000016B8                           723          
000016B8  4EB9 00002228            724          Jsr     GET6AND7
000016BE  B03C 0003                725          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
000016C2                           726          
000016C2  6700 0012                727          Beq     OP_SUB_ADDR
000016C6                           728  
000016C6                           729          ; Don't need to worry about ADDA in V1
000016C6                           730          ; Check data size
000016C6  4EB9 00001B44            731          Jsr     OP_CHECK_DATA_SIZE
000016CC                           732          
000016CC                           733          ; Put in tabs
000016CC  4EB9 00001B20            734          Jsr     OP_TAB
000016D2                           735          
000016D2  6000 081C                736          BRA     EA_SUB 
000016D6                           737          
000016D6                           738  OP_SUB_ADDR
000016D6                           739          
000016D6  1CFC 0041                740          Move.B  #'A',(A6)+ ; add to the string
000016DA                           741          
000016DA                           742          ; Find data size
000016DA                           743          
000016DA  4EB9 00001B64            744          Jsr     OP_CHECK_DATA_SIZE_ADDR
000016E0                           745          
000016E0                           746          ; Put in tabs
000016E0  4EB9 00001B20            747          Jsr     OP_TAB
000016E6                           748          
000016E6                           749          ; Handoff
000016E6  6000 0808                750          BRA     EA_SUB
000016EA                           751          
000016EA                           752  ;-----------------------  ADD  ------------------------------;
000016EA                           753  
000016EA                           754  OP_ADD
000016EA                           755      ; start string
000016EA                           756      
000016EA  1CFC 0041                757          Move.B  #'A', (A6)+
000016EE  1CFC 0044                758          Move.B  #'D', (A6)+
000016F2  1CFC 0044                759          Move.B  #'D', (A6)+
000016F6                           760  
000016F6                           761      ; Check for address version
000016F6                           762          
000016F6  4EB9 00002228            763          Jsr     GET6AND7
000016FC  B03C 0003                764          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001700                           765          
00001700  6700 0012                766          Beq     OP_ADD_ADDR
00001704                           767          
00001704                           768          ; Don't need to worry about ADDA in V1
00001704                           769          ; Check data size
00001704  4EB9 00001B44            770          Jsr     OP_CHECK_DATA_SIZE
0000170A                           771          
0000170A                           772          ; Put in tabs
0000170A  4EB9 00001B20            773          Jsr     OP_TAB
00001710                           774          
00001710  6000 06E4                775          BRA     EA_ADD
00001714                           776          
00001714                           777  OP_ADD_ADDR
00001714                           778          
00001714  1CFC 0041                779          Move.B  #'A',(A6)+ ; add to the string
00001718                           780          
00001718                           781          ; Find data size
00001718                           782          
00001718  4EB9 00001B64            783          Jsr     OP_CHECK_DATA_SIZE_ADDR
0000171E                           784          
0000171E                           785          ; Put in tabs
0000171E  4EB9 00001B20            786          Jsr     OP_TAB
00001724                           787          
00001724                           788          ; Handoff
00001724  6000 0704                789          BRA     EA_ADDA
00001728                           790  
00001728                           791  ;------------------------  BTST -----------------------------;
00001728                           792  
00001728                           793  OP_BTST
00001728                           794      ; start string
00001728                           795      
00001728  1CFC 0042                796          Move.B  #'B', (A6)+
0000172C  1CFC 0054                797          Move.B  #'T', (A6)+
00001730  1CFC 0053                798          Move.B  #'S', (A6)+
00001734  1CFC 0054                799          Move.B  #'T', (A6)+
00001738                           800          
00001738                           801      ; Btst has data sizes, but they are implicit based on mode
00001738                           802          
00001738                           803      ; Put in tabs
00001738  4EB9 00001B20            804          Jsr     OP_TAB
0000173E                           805          
0000173E                           806      ; Hand the function off to John
0000173E  6000 08B6                807          BRA     EA_BTST
00001742                           808  
00001742                           809  
00001742                           810  ;---------------  IMEMDIATE FUNCTIONS  ----------------------;
00001742                           811  
00001742                           812  ;------------------------  ORI  -----------------------------;
00001742                           813      
00001742                           814  OP_ORI
00001742                           815      ; start string
00001742                           816      
00001742  1CFC 004F                817          Move.B  #'O', (A6)+
00001746  1CFC 0052                818          Move.B  #'R', (A6)+
0000174A  1CFC 0049                819          Move.B  #'I', (A6)+
0000174E                           820          
0000174E                           821      ; Check data type        
0000174E  4EB9 00001B44            822          Jsr     OP_CHECK_DATA_SIZE
00001754                           823          
00001754                           824      ; Put in tabs
00001754  4EB9 00001B20            825          Jsr     OP_TAB
0000175A                           826          
0000175A                           827      ; Hand the function off to John
0000175A  6000 0836                828          BRA     EA_IMMEDIATE
0000175E                           829  
0000175E                           830  ;-----------------------  SUBI  -----------------------------;
0000175E                           831  
0000175E                           832  OP_SUBI
0000175E                           833      ; start string
0000175E                           834      
0000175E  1CFC 0053                835          Move.B  #'S', (A6)+
00001762  1CFC 0055                836          Move.B  #'U', (A6)+
00001766  1CFC 0042                837          Move.B  #'B', (A6)+
0000176A  1CFC 0049                838          Move.B  #'I', (A6)+
0000176E                           839          
0000176E                           840      ; Check data type        
0000176E  4EB9 00001B44            841          Jsr     OP_CHECK_DATA_SIZE
00001774                           842          
00001774                           843      ; Put in tabs
00001774  4EB9 00001B20            844          Jsr     OP_TAB
0000177A                           845          
0000177A                           846      ; Hand the function off to John
0000177A  6000 0816                847          BRA     EA_IMMEDIATE  
0000177E                           848          
0000177E                           849  ;-----------------------  EORI  -----------------------------;        
0000177E                           850          
0000177E                           851  OP_EORI
0000177E                           852      ; start string
0000177E                           853      
0000177E  1CFC 0045                854          Move.B  #'E', (A6)+
00001782  1CFC 004F                855          Move.B  #'O', (A6)+
00001786  1CFC 0052                856          Move.B  #'R', (A6)+
0000178A  1CFC 0049                857          Move.B  #'I', (A6)+
0000178E                           858          
0000178E                           859      ; Check data type        
0000178E  4EB9 00001B44            860          Jsr     OP_CHECK_DATA_SIZE
00001794                           861          
00001794                           862      ; Put in tabs
00001794  4EB9 00001B20            863          Jsr     OP_TAB
0000179A                           864          
0000179A                           865      ; Hand the function off to John
0000179A  6000 07F6                866          BRA     EA_IMMEDIATE  
0000179E                           867          
0000179E                           868  ;-----------------------  CMPI  -----------------------------;        
0000179E                           869          
0000179E                           870  OP_CMPI
0000179E                           871      ; start string
0000179E                           872      
0000179E  1CFC 0043                873          Move.B  #'C', (A6)+
000017A2  1CFC 004D                874          Move.B  #'M', (A6)+
000017A6  1CFC 0050                875          Move.B  #'P', (A6)+
000017AA  1CFC 0049                876          Move.B  #'I', (A6)+
000017AE                           877          
000017AE                           878      ; Check data type        
000017AE  4EB9 00001B44            879          Jsr     OP_CHECK_DATA_SIZE
000017B4                           880          
000017B4                           881      ; Put in tabs
000017B4  4EB9 00001B20            882          Jsr     OP_TAB
000017BA                           883          
000017BA                           884      ; Hand the function off to John
000017BA  6000 07D6                885          BRA     EA_IMMEDIATE  
000017BE                           886          
000017BE                           887  ;-----------------------  LEA  ------------------------------;
000017BE                           888  
000017BE                           889  OP_LEA
000017BE                           890      ; start string
000017BE                           891      
000017BE  1CFC 004C                892          Move.B  #'L', (A6)+
000017C2  1CFC 0045                893          Move.B  #'E', (A6)+
000017C6  1CFC 0041                894          Move.B  #'A', (A6)+
000017CA                           895          
000017CA                           896      ; No data size for LEA
000017CA                           897          
000017CA                           898      ; Put in tabs
000017CA  4EB9 00001B20            899          Jsr     OP_TAB
000017D0                           900          
000017D0                           901      ; Hand the function off to John
000017D0  6000 0726                902          BRA     EA_LEA  
000017D4                           903  
000017D4                           904  ;-----------------------  NEG  ------------------------------;
000017D4                           905  
000017D4                           906  OP_NEG
000017D4                           907      ; start string
000017D4                           908      
000017D4  1CFC 004E                909          Move.B  #'N', (A6)+
000017D8  1CFC 0045                910          Move.B  #'E', (A6)+
000017DC  1CFC 0047                911          Move.B  #'G', (A6)+
000017E0                           912          
000017E0                           913      ; Data size
000017E0  4EB9 00001B44            914          Jsr     OP_CHECK_DATA_SIZE
000017E6                           915          
000017E6                           916      ; Put in tabs
000017E6  4EB9 00001B20            917          Jsr     OP_TAB
000017EC                           918          
000017EC                           919      ; Hand the function off to John
000017EC  6000 0716                920          BRA     EA_NEG  
000017F0                           921  
000017F0                           922      
000017F0                           923  ;-----------------------  NOT  ------------------------------;    
000017F0                           924      
000017F0                           925  OP_NOT
000017F0                           926      ; start string
000017F0                           927      
000017F0  1CFC 004E                928          Move.B  #'N', (A6)+
000017F4  1CFC 004F                929          Move.B  #'O', (A6)+
000017F8  1CFC 0054                930          Move.B  #'T', (A6)+
000017FC                           931          
000017FC                           932      ; Data size
000017FC  4EB9 00001B44            933          Jsr     OP_CHECK_DATA_SIZE
00001802                           934          
00001802                           935      ; Put in tabs
00001802  4EB9 00001B20            936          Jsr     OP_TAB
00001808                           937          
00001808                           938      ; Hand the function off to John
00001808  6000 0702                939          BRA     EA_NOT
0000180C                           940  
0000180C                           941  ;-------------------  MOVE MULITPLE  ------------------------;
0000180C                           942          
0000180C                           943  OP_MOVEM
0000180C                           944      ; Exception checks
0000180C  4EB9 0000223A            945          Jsr     GET7AND8
00001812  B03C 0001                946          Cmp.B   #%01,D0
00001816  6600 0302                947          Bne     OP_SET_BAD_BUFFER
0000181A                           948          
0000181A  4EB9 000021E0            949          Jsr     GET3TO5
00001820  B03C 0000                950          Cmp.B   #%000,D0
00001824  6700 02F4                951          Beq     OP_SET_BAD_BUFFER
00001828                           952  
00001828                           953      ; start string
00001828                           954      
00001828  1CFC 004D                955          Move.B  #'M', (A6)+
0000182C  1CFC 004F                956          Move.B  #'O', (A6)+
00001830  1CFC 0056                957          Move.B  #'V', (A6)+
00001834  1CFC 0045                958          Move.B  #'E', (A6)+
00001838  1CFC 004D                959          Move.B  #'M', (A6)+        
0000183C                           960  
0000183C                           961      ; Data size has to be checked manually
0000183C  4EB9 0000184C            962          Jsr     OP_MOVEM_DATA
00001842                           963          
00001842                           964      ; Put in tabs
00001842  4EB9 00001B20            965          Jsr     OP_TAB
00001848                           966          
00001848                           967      ; Hand the function off to John
00001848  6000 03F2                968          BRA     EA_MOVEM
0000184C                           969          
0000184C                           970  OP_MOVEM_DATA
0000184C                           971      ; get the size bit
0000184C  4EB9 00002228            972          Jsr     GET6AND7
00001852                           973          
00001852  B03C 0002                974          Cmp.B   #%10,D0
00001856  6700 0328                975          Beq     OP_SET_DATA_WORD
0000185A                           976          
0000185A  6000 032E                977          Bra     OP_SET_DATA_LONG   
0000185E                           978  
0000185E                           979  OP_RTS
0000185E                           980      ; start string
0000185E                           981      
0000185E  1CFC 0052                982          Move.B  #'R', (A6)+
00001862  1CFC 0054                983          Move.B  #'T', (A6)+
00001866  1CFC 0053                984          Move.B  #'S', (A6)+
0000186A                           985  
0000186A                           986      ; Put in tabs
0000186A  4EB9 00001B20            987          Jsr     OP_TAB
00001870                           988  
00001870                           989      ; Handoff to Blong
00001870                           990      
00001870  4E75                     991          Rts
00001872                           992          
00001872                           993  ;-----------------------  JSR  ------------------------------;        
00001872                           994          
00001872                           995  OP_JSR
00001872                           996      ; start string
00001872                           997      
00001872  1CFC 004A                998          Move.B  #'J', (A6)+
00001876  1CFC 0053                999          Move.B  #'S', (A6)+
0000187A  1CFC 0052               1000          Move.B  #'R', (A6)+
0000187E                          1001          
0000187E                          1002      ; No data size
0000187E                          1003          
0000187E                          1004      ; Put in tabs
0000187E  4EB9 00001B20           1005          Jsr     OP_TAB
00001884                          1006          
00001884                          1007      ; Hand the function off to John
00001884  6000 068A               1008          BRA     EA_JSR
00001888                          1009  
00001888                          1010  ;------------------  BRANCH CONDITIONALS  ------------------------;
00001888                          1011  
00001888                          1012  OP_BRANCH
00001888                          1013      ; start string
00001888                          1014      
00001888  1CFC 0042               1015          Move.B  #'B', (A6)+
0000188C  1CFC 0052               1016          Move.B  #'R', (A6)+
00001890  1CFC 0041               1017          Move.B  #'A', (A6)+
00001894                          1018  
00001894                          1019      ; Put in tabs
00001894  4EB9 00001B20           1020          Jsr     OP_TAB
0000189A                          1021  
0000189A                          1022      ; Handoff to John
0000189A                          1023      
0000189A  6000 07A4               1024          BRA     EA_BRANCH
0000189E                          1025      
0000189E                          1026  OP_BRA_HIGH
0000189E                          1027      ; start string
0000189E                          1028      
0000189E  1CFC 0042               1029          Move.B  #'B', (A6)+
000018A2  1CFC 0048               1030          Move.B  #'H', (A6)+
000018A6  1CFC 0049               1031          Move.B  #'I', (A6)+
000018AA                          1032  
000018AA                          1033      ; Put in tabs
000018AA  4EB9 00001B20           1034          Jsr     OP_TAB
000018B0                          1035  
000018B0                          1036      ; Handoff to John
000018B0                          1037      
000018B0  6000 078E               1038          BRA     EA_BRANCH
000018B4                          1039      
000018B4                          1040  OP_BRA_LOW
000018B4                          1041      ; start string
000018B4                          1042      
000018B4  1CFC 0042               1043          Move.B  #'B', (A6)+
000018B8  1CFC 004C               1044          Move.B  #'L', (A6)+
000018BC  1CFC 0053               1045          Move.B  #'S', (A6)+
000018C0                          1046  
000018C0                          1047      ; Put in tabs
000018C0  4EB9 00001B20           1048          Jsr     OP_TAB
000018C6                          1049  
000018C6                          1050      ; Handoff to John
000018C6                          1051      
000018C6  6000 0778               1052          BRA     EA_BRANCH
000018CA                          1053      
000018CA                          1054  OP_BRA_CC
000018CA                          1055      ; start string
000018CA                          1056      
000018CA  1CFC 0042               1057          Move.B  #'B', (A6)+
000018CE  1CFC 0043               1058          Move.B  #'C', (A6)+
000018D2  1CFC 0043               1059          Move.B  #'C', (A6)+
000018D6                          1060  
000018D6                          1061      ; Put in tabs
000018D6  4EB9 00001B20           1062          Jsr     OP_TAB
000018DC                          1063  
000018DC                          1064      ; Handoff to John
000018DC                          1065      
000018DC  6000 0762               1066          BRA     EA_BRANCH
000018E0                          1067  
000018E0                          1068  OP_BRA_CS
000018E0                          1069      ; start string
000018E0                          1070      
000018E0  1CFC 0042               1071          Move.B  #'B', (A6)+
000018E4  1CFC 0043               1072          Move.B  #'C', (A6)+
000018E8  1CFC 0053               1073          Move.B  #'S', (A6)+
000018EC                          1074  
000018EC                          1075      ; Put in tabs
000018EC  4EB9 00001B20           1076          Jsr     OP_TAB
000018F2                          1077  
000018F2                          1078      ; Handoff to John
000018F2                          1079      
000018F2  6000 074C               1080          BRA     EA_BRANCH
000018F6                          1081  
000018F6                          1082  OP_BRA_NE
000018F6                          1083      ; start string
000018F6                          1084      
000018F6  1CFC 0042               1085          Move.B  #'B', (A6)+
000018FA  1CFC 004E               1086          Move.B  #'N', (A6)+
000018FE  1CFC 0045               1087          Move.B  #'E', (A6)+
00001902                          1088  
00001902                          1089      ; Put in tabs
00001902  4EB9 00001B20           1090          Jsr     OP_TAB
00001908                          1091  
00001908                          1092      ; Handoff to John
00001908                          1093      
00001908  6000 0736               1094          BRA     EA_BRANCH
0000190C                          1095  
0000190C                          1096  OP_BRA_EQ
0000190C                          1097      ; start string
0000190C                          1098      
0000190C  1CFC 0042               1099          Move.B  #'B', (A6)+
00001910  1CFC 0045               1100          Move.B  #'E', (A6)+
00001914  1CFC 0051               1101          Move.B  #'Q', (A6)+
00001918                          1102  
00001918                          1103      ; Put in tabs
00001918  4EB9 00001B20           1104          Jsr     OP_TAB
0000191E                          1105  
0000191E                          1106      ; Handoff to John
0000191E                          1107      
0000191E  6000 0720               1108          BRA     EA_BRANCH
00001922                          1109  
00001922                          1110  OP_BRA_VC
00001922                          1111      ; start string
00001922                          1112      
00001922  1CFC 0042               1113          Move.B  #'B', (A6)+
00001926  1CFC 0056               1114          Move.B  #'V', (A6)+
0000192A  1CFC 0043               1115          Move.B  #'C', (A6)+
0000192E                          1116  
0000192E                          1117      ; Put in tabs
0000192E  4EB9 00001B20           1118          Jsr     OP_TAB
00001934                          1119  
00001934                          1120      ; Handoff to John
00001934                          1121      
00001934  6000 070A               1122          BRA     EA_BRANCH
00001938                          1123  
00001938                          1124  OP_BRA_VS
00001938                          1125      ; start string
00001938                          1126      
00001938  1CFC 0042               1127          Move.B  #'B', (A6)+
0000193C  1CFC 0056               1128          Move.B  #'V', (A6)+
00001940  1CFC 0053               1129          Move.B  #'S', (A6)+
00001944                          1130  
00001944                          1131      ; Put in tabs
00001944  4EB9 00001B20           1132          Jsr     OP_TAB
0000194A                          1133  
0000194A                          1134      ; Handoff to John
0000194A                          1135      
0000194A  6000 06F4               1136          BRA     EA_BRANCH
0000194E                          1137  
0000194E                          1138  OP_BRA_PL
0000194E                          1139      ; start string
0000194E                          1140      
0000194E  1CFC 0042               1141          Move.B  #'B', (A6)+
00001952  1CFC 0050               1142          Move.B  #'P', (A6)+
00001956  1CFC 004C               1143          Move.B  #'L', (A6)+
0000195A                          1144  
0000195A                          1145      ; Put in tabs
0000195A  4EB9 00001B20           1146          Jsr     OP_TAB
00001960                          1147  
00001960                          1148      ; Handoff to John
00001960                          1149      
00001960  6000 06DE               1150          BRA     EA_BRANCH
00001964                          1151  
00001964                          1152  OP_BRA_MI
00001964                          1153      ; start string
00001964                          1154      
00001964  1CFC 0042               1155          Move.B  #'B', (A6)+
00001968  1CFC 004D               1156          Move.B  #'M', (A6)+
0000196C  1CFC 0049               1157          Move.B  #'I', (A6)+
00001970                          1158  
00001970                          1159      ; Put in tabs
00001970  4EB9 00001B20           1160          Jsr     OP_TAB
00001976                          1161  
00001976                          1162      ; Handoff to John
00001976                          1163      
00001976  6000 06C8               1164          BRA     EA_BRANCH
0000197A                          1165  
0000197A                          1166  OP_BRA_GE
0000197A                          1167      ; start string
0000197A                          1168      
0000197A  1CFC 0042               1169          Move.B  #'B', (A6)+
0000197E  1CFC 0047               1170          Move.B  #'G', (A6)+
00001982  1CFC 0045               1171          Move.B  #'E', (A6)+
00001986                          1172  
00001986                          1173      ; Put in tabs
00001986  4EB9 00001B20           1174          Jsr     OP_TAB
0000198C                          1175  
0000198C                          1176      ; Handoff to John
0000198C                          1177      
0000198C  6000 06B2               1178          BRA     EA_BRANCH
00001990                          1179  
00001990                          1180  OP_BRA_LT
00001990                          1181      ; start string
00001990                          1182      
00001990  1CFC 0042               1183          Move.B  #'B', (A6)+
00001994  1CFC 004C               1184          Move.B  #'L', (A6)+
00001998  1CFC 0054               1185          Move.B  #'T', (A6)+
0000199C                          1186  
0000199C                          1187      ; Put in tabs
0000199C  4EB9 00001B20           1188          Jsr     OP_TAB
000019A2                          1189  
000019A2                          1190      ; Handoff to John
000019A2                          1191      
000019A2  6000 069C               1192          BRA     EA_BRANCH
000019A6                          1193  
000019A6                          1194  OP_BRA_GT
000019A6                          1195      ; start string
000019A6                          1196      
000019A6  1CFC 0042               1197          Move.B  #'B', (A6)+
000019AA  1CFC 0047               1198          Move.B  #'G', (A6)+
000019AE  1CFC 0054               1199          Move.B  #'T', (A6)+
000019B2                          1200  
000019B2                          1201      ; Put in tabs
000019B2  4EB9 00001B20           1202          Jsr     OP_TAB
000019B8                          1203  
000019B8                          1204      ; Handoff to John
000019B8                          1205      
000019B8  6000 0686               1206          BRA     EA_BRANCH
000019BC                          1207  
000019BC                          1208  OP_BRA_LE
000019BC                          1209      ; start string
000019BC                          1210      
000019BC  1CFC 0042               1211          Move.B  #'B', (A6)+
000019C0  1CFC 004C               1212          Move.B  #'L', (A6)+
000019C4  1CFC 0045               1213          Move.B  #'E', (A6)+
000019C8                          1214  
000019C8                          1215      ; Put in tabs
000019C8  4EB9 00001B20           1216          Jsr     OP_TAB
000019CE                          1217  
000019CE                          1218      ; Handoff to John
000019CE                          1219      
000019CE  6000 0670               1220          BRA     EA_BRANCH
000019D2                          1221  
000019D2                          1222  ;------------------  Multiply Singed ----------------------;    
000019D2                          1223  
000019D2                          1224  OP_MULS
000019D2                          1225      ; MULS only has one format, and that data size of word, so I don't need
000019D2                          1226      ; a very intelligent system
000019D2                          1227      
000019D2  1CFC 004D               1228          Move.B  #'M', (A6)+
000019D6  1CFC 0055               1229          Move.B  #'U', (A6)+
000019DA  1CFC 004C               1230          Move.B  #'L', (A6)+
000019DE  1CFC 0053               1231          Move.B  #'S', (A6)+
000019E2  1CFC 002E               1232          Move.B  #'.', (A6)+
000019E6  1CFC 0057               1233          Move.B  #'W', (A6)+
000019EA                          1234  
000019EA                          1235      ; Put in tabs
000019EA  4EB9 00001B20           1236          Jsr     OP_TAB       
000019F0                          1237      
000019F0                          1238      ; Give to john
000019F0                          1239      
000019F0  6000 05D8               1240          BRA     EA_MULS
000019F4                          1241  
000019F4                          1242      
000019F4                          1243  ;-----------------------  AND  ------------------------------;    
000019F4                          1244      
000019F4                          1245  OP_AND
000019F4                          1246      ; start string
000019F4                          1247      
000019F4  1CFC 0041               1248          Move.B  #'A', (A6)+
000019F8  1CFC 004E               1249          Move.B  #'N', (A6)+
000019FC  1CFC 0044               1250          Move.B  #'D', (A6)+
00001A00                          1251  
00001A00                          1252      ; No Address Version
00001A00                          1253          
00001A00                          1254      ; Check data size
00001A00  4EB9 00001B44           1255          Jsr     OP_CHECK_DATA_SIZE
00001A06                          1256          
00001A06                          1257      ; Put in tabs
00001A06  4EB9 00001B20           1258          Jsr     OP_TAB
00001A0C                          1259          
00001A0C  6000 04EE               1260      BRA     EA_AND
00001A10                          1261  
00001A10                          1262      
00001A10                          1263  ;-----------------  ARITHMETIC SHIFTS  ----------------------;
00001A10                          1264          
00001A10                          1265  OP_AS_REG
00001A10                          1266      ; start string
00001A10                          1267      
00001A10  1CFC 0041               1268          Move.B  #'A', (A6)+
00001A14  1CFC 0053               1269          Move.B  #'S', (A6)+
00001A18                          1270          
00001A18                          1271      ; Determine Left or right shift
00001A18                          1272      
00001A18  4EB9 00001B94           1273          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A1E                          1274          
00001A1E                          1275      ; Determine data size
00001A1E                          1276      
00001A1E  4EB9 00001B44           1277          Jsr     OP_CHECK_DATA_SIZE
00001A24                          1278         
00001A24                          1279      ; Tab out function
00001A24                          1280      
00001A24  4EB9 00001B20           1281          Jsr     OP_TAB
00001A2A                          1282         
00001A2A                          1283      ; Handoff function
00001A2A  6000 04E8               1284          BRA     EA_BIT_SHIFT
00001A2E                          1285          
00001A2E                          1286  OP_AS_MEM
00001A2E                          1287      
00001A2E                          1288      ; start string
00001A2E                          1289      
00001A2E  1CFC 0041               1290          Move.B  #'A', (A6)+
00001A32  1CFC 0053               1291          Move.B  #'S', (A6)+
00001A36                          1292          
00001A36                          1293      ; Determine Left or right shift
00001A36                          1294      
00001A36  4EB9 00001B94           1295          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A3C                          1296         
00001A3C                          1297      ; Tab out function
00001A3C                          1298      
00001A3C  4EB9 00001B20           1299          Jsr     OP_TAB
00001A42                          1300         
00001A42                          1301      ; Handoff function
00001A42  6000 04D0               1302          BRA     EA_BIT_SHIFT
00001A46                          1303  
00001A46                          1304  
00001A46                          1305  ;-------------------  LOGICAL SHIFT  ------------------------;
00001A46                          1306  
00001A46                          1307  OP_LS_REG
00001A46                          1308      ; start string
00001A46                          1309      
00001A46  1CFC 004C               1310          Move.B  #'L', (A6)+
00001A4A  1CFC 0053               1311          Move.B  #'S', (A6)+
00001A4E                          1312          
00001A4E                          1313      ; Determine Left or right shift
00001A4E                          1314      
00001A4E  4EB9 00001B94           1315          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A54                          1316          
00001A54                          1317      ; Determine data size
00001A54                          1318      
00001A54  4EB9 00001B44           1319          Jsr     OP_CHECK_DATA_SIZE
00001A5A                          1320         
00001A5A                          1321      ; Tab out function
00001A5A                          1322      
00001A5A  4EB9 00001B20           1323          Jsr     OP_TAB
00001A60                          1324         
00001A60                          1325      ; Handoff function
00001A60  6000 04B2               1326          BRA     EA_BIT_SHIFT
00001A64                          1327  
00001A64                          1328      
00001A64                          1329  OP_LS_MEM    
00001A64                          1330  
00001A64                          1331      ; start string
00001A64                          1332      
00001A64  1CFC 004C               1333          Move.B  #'L', (A6)+
00001A68  1CFC 0053               1334          Move.B  #'S', (A6)+
00001A6C                          1335          
00001A6C                          1336      ; Determine Left or right shift
00001A6C                          1337      
00001A6C  4EB9 00001B94           1338          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A72                          1339         
00001A72                          1340      ; Tab out function
00001A72                          1341      
00001A72  4EB9 00001B20           1342          Jsr     OP_TAB
00001A78                          1343         
00001A78                          1344      ; Handoff function
00001A78  6000 049A               1345          BRA     EA_BIT_SHIFT
00001A7C                          1346  
00001A7C                          1347  
00001A7C                          1348  ;----------------------  ROTATE  ----------------------------;
00001A7C                          1349  
00001A7C                          1350  OP_RO_REG
00001A7C                          1351      ; start string
00001A7C                          1352      
00001A7C  1CFC 0052               1353          Move.B  #'R', (A6)+
00001A80  1CFC 004F               1354          Move.B  #'O', (A6)+
00001A84                          1355          
00001A84                          1356      ; Determine Left or right shift
00001A84                          1357      
00001A84  4EB9 00001B94           1358          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001A8A                          1359          
00001A8A                          1360      ; Determine data size
00001A8A                          1361      
00001A8A  4EB9 00001B44           1362          Jsr     OP_CHECK_DATA_SIZE
00001A90                          1363         
00001A90                          1364      ; Tab out function
00001A90                          1365      
00001A90  4EB9 00001B20           1366          Jsr     OP_TAB
00001A96                          1367         
00001A96                          1368      ; Handoff function
00001A96  6000 047C               1369          BRA     EA_BIT_SHIFT
00001A9A                          1370  
00001A9A                          1371      
00001A9A                          1372  OP_RO_MEM
00001A9A                          1373  
00001A9A                          1374      ; start string
00001A9A                          1375      
00001A9A  1CFC 0052               1376          Move.B  #'R', (A6)+
00001A9E  1CFC 004F               1377          Move.B  #'O', (A6)+
00001AA2                          1378          
00001AA2                          1379      ; Determine Left or right shift
00001AA2                          1380      
00001AA2  4EB9 00001B94           1381          Jsr     OP_SHIFT_DIRECTION  ;Check the shift direction
00001AA8                          1382         
00001AA8                          1383      ; Tab out function
00001AA8                          1384      
00001AA8  4EB9 00001B20           1385          Jsr     OP_TAB
00001AAE                          1386         
00001AAE                          1387      ; Handoff function
00001AAE  6000 0464               1388          BRA     EA_BIT_SHIFT
00001AB2                          1389  
00001AB2                          1390  
00001AB2                          1391  ;-----------------------  CMP  ------------------------------;
00001AB2                          1392  
00001AB2                          1393  OP_Cmp
00001AB2                          1394      ; start string
00001AB2                          1395      
00001AB2  1CFC 0043               1396          Move.B  #'C', (A6)+
00001AB6  1CFC 004D               1397          Move.B  #'M', (A6)+
00001ABA  1CFC 0050               1398          Move.B  #'P', (A6)+
00001ABE                          1399  
00001ABE                          1400      ; Check for address version
00001ABE                          1401          
00001ABE  4EB9 00002228           1402          Jsr     GET6AND7
00001AC4  B03C 0003               1403          Cmp.B   #%11, D0    ; if both bits are 1 it is an address version
00001AC8                          1404          
00001AC8  6700 0012               1405          Beq     OP_CMP_ADDR
00001ACC                          1406          
00001ACC                          1407      ; Check which of the two versions is it?
00001ACC                          1408  
00001ACC  4EB9 00001B44           1409          Jsr     OP_CHECK_DATA_SIZE
00001AD2                          1410          
00001AD2                          1411      ; Put in tabs
00001AD2  4EB9 00001B20           1412          Jsr     OP_TAB
00001AD8                          1413  
00001AD8                          1414      ; Handoff
00001AD8  6000 041A               1415          BRA     EA_CMP
00001ADC                          1416          
00001ADC                          1417  OP_CMP_ADDR
00001ADC                          1418          
00001ADC  1CFC 0041               1419          Move.B  #'A',(A6)+ ; add to the string
00001AE0                          1420      
00001AE0                          1421      ; Find data size
00001AE0                          1422          
00001AE0  4EB9 00001B64           1423          Jsr     OP_CHECK_DATA_SIZE_ADDR
00001AE6                          1424          
00001AE6                          1425      ; Put in tabs
00001AE6  4EB9 00001B20           1426          Jsr     OP_TAB
00001AEC                          1427  
00001AEC                          1428      ; Handoff
00001AEC  6000 0406               1429          BRA     EA_CMP
00001AF0                          1430      
00001AF0                          1431  ;-----------------------  EOR  ------------------------------;
00001AF0                          1432  
00001AF0                          1433  OP_EOR
00001AF0                          1434      ; Compare to make sure it is not CmpM
00001AF0  4EB9 000021E0           1435          Jsr     GET3TO5
00001AF6  B03C 0001               1436          Cmp.B   #%001,D0
00001AFA  6700 001E               1437          Beq     OP_SET_BAD_BUFFER
00001AFE                          1438  
00001AFE                          1439      ; start string
00001AFE                          1440      
00001AFE  1CFC 0045               1441          Move.B  #'E', (A6)+
00001B02  1CFC 004F               1442          Move.B  #'O', (A6)+
00001B06  1CFC 0052               1443          Move.B  #'R', (A6)+
00001B0A                          1444  
00001B0A                          1445      ; No Address Version
00001B0A                          1446          
00001B0A                          1447      ; Check data size
00001B0A  4EB9 00001B44           1448          Jsr     OP_CHECK_DATA_SIZE
00001B10                          1449          
00001B10                          1450      ; Put in tabs
00001B10  4EB9 00001B20           1451          Jsr     OP_TAB
00001B16                          1452          
00001B16  6000 03E8               1453      BRA     EA_EOR
00001B1A                          1454  
00001B1A                          1455  ;---------------- Misc Op-Code Sub Routines ----------------;
00001B1A                          1456  ; Set Bad Buffer
00001B1A                          1457  ; Sub Routine that sets the Bad buffer bit and returns
00001B1A                          1458  ;
00001B1A                          1459  ; REGISTERS USED: D7
00001B1A                          1460  
00001B1A                          1461  OP_SET_BAD_BUFFER
00001B1A  1E3C 0001               1462      Move.B  #%1, D7
00001B1E  4E75                    1463      Rts
00001B20                          1464  
00001B20                          1465  ;-------------------------- Tab ----------------------------;
00001B20                          1466  ; Sets the total size of the string to be 12 spaces (3 tabs)
00001B20                          1467  ; taking into account the current size of the string
00001B20                          1468  
00001B20                          1469  ; REGISTERS USED: A6, A5(const), D0
00001B20                          1470  
00001B20                          1471  OP_TAB
00001B20  220D                    1472      Move.L      A5,D1   ; Move the start of string to a Dn
00001B22  928E                    1473      Sub.L       A6,D1   ; Find the compliment of how long the String is
00001B24  0681 00000014           1474      AddI.L      #20,D1  ; Get the number of spaces before 3 tabs
00001B2A                          1475      
00001B2A                          1476      ; Loop till you have enough spaces
00001B2A                          1477  LOOP_TAB
00001B2A  1CFC 0020               1478      Move.B      #' ',(A6)+  ; Add a space to the string
00001B2E  5301                    1479      SubI.B      #1,D1       ; Decrement the loop counter (D0)
00001B30  66F8                    1480      BNE         LOOP_TAB    ; Continue looping if the loop counter hasn't hit 0
00001B32                          1481      
00001B32  4E75                    1482      Rts
00001B34                          1483  
00001B34                          1484  ;--------------------- Address Version ---------------------;
00001B34                          1485  ; This Sub Routine Checks if the Src address is an An and
00001B34                          1486  ; Adds an A to the sring if it is, to represent that it is
00001B34                          1487  ; Is the Address version of the Op-code. This function assumes
00001B34                          1488  ; That D0 will have the mode for the Destination in it.
00001B34                          1489  
00001B34                          1490  ; REGISTERS USED: D0, D4 (const), D1 (calls Bit Getters)
00001B34                          1491  ;                 A6 (Add string input)
00001B34                          1492  
00001B34                          1493  OP_CHECK_ADDRESS_VERSION
00001B34                          1494  
00001B34  B03C 0001               1495      Cmp.B    #%001, D0 ; Check to see if the src mode is An
00001B38  6700 0004               1496      Beq     OP_ADD_ADDRESS_VERSION ; If true add the 'A'
00001B3C                          1497      
00001B3C  4E75                    1498      Rts     ; Otherwise go back without changing anything
00001B3E                          1499  
00001B3E                          1500  OP_ADD_ADDRESS_VERSION
00001B3E  1CFC 0041               1501      Move.B  #'A',(A6)+     ; Add the letter A to the string
00001B42                          1502      
00001B42  4E75                    1503      Rts     ; Finish up and go back
00001B44                          1504      
00001B44                          1505  ;--------------------- Data Size Check ---------------------;
00001B44                          1506  ; A set of sub routines to check the size of the data and add it
00001B44                          1507  ; To the string.
00001B44                          1508  
00001B44                          1509  ; REGISTERS USED: D0, D1(Bit Shifts), D4(const), D7(checks illegal ops)
00001B44                          1510  ;                 A6(adds letters)    
00001B44                          1511  OP_CHECK_DATA_SIZE
00001B44  4EB9 00002228           1512      Jsr     GET6AND7
00001B4A                          1513      
00001B4A  B03C 0000               1514      Cmp.B    #%00, D0    ; Byte Size
00001B4E  6700 0026               1515      Beq     OP_SET_DATA_BYTE
00001B52                          1516      
00001B52  B03C 0001               1517      Cmp.B    #%01, D0    ; Word Size
00001B56  6700 0028               1518      Beq     OP_SET_DATA_WORD
00001B5A                          1519      
00001B5A  B03C 0002               1520      Cmp.B    #%10, D0    ; Long Size
00001B5E  6700 002A               1521      Beq     OP_SET_DATA_LONG
00001B62                          1522      
00001B62                          1523      ; If it was not one of those three types, it is not a legal operation
00001B62  60B6                    1524      Bra     OP_SET_BAD_BUFFER     ; Set the Bad buffer bit
00001B64                          1525  
00001B64                          1526  OP_CHECK_DATA_SIZE_ADDR
00001B64  4EB9 00002204           1527      Jsr     GETBIT8
00001B6A                          1528      
00001B6A  B03C 0000               1529      Cmp.B   #%0, D0     ; Word Size
00001B6E  6700 0010               1530      Beq     OP_SET_DATA_WORD
00001B72                          1531                          ; Otherwise its Long Size
00001B72  6000 0016               1532      Bra     OP_SET_DATA_LONG
00001B76                          1533  
00001B76                          1534  OP_SET_DATA_BYTE
00001B76                          1535  
00001B76  1CFC 002E               1536      Move.B  #'.',(A6)+  ; Add Letters
00001B7A  1CFC 0042               1537      Move.B  #'B',(A6)+
00001B7E                          1538      
00001B7E  4E75                    1539      Rts
00001B80                          1540  
00001B80                          1541  OP_SET_DATA_WORD
00001B80                          1542  
00001B80  1CFC 002E               1543      Move.B  #'.',(A6)+  ; Add Letters
00001B84  1CFC 0057               1544      Move.B  #'W',(A6)+
00001B88                          1545  
00001B88  4E75                    1546      Rts
00001B8A                          1547  
00001B8A                          1548  OP_SET_DATA_LONG
00001B8A                          1549  
00001B8A  1CFC 002E               1550      Move.B  #'.',(A6)+  ; Add Letters
00001B8E  1CFC 004C               1551      Move.B  #'L',(A6)+
00001B92                          1552  
00001B92  4E75                    1553      Rts
00001B94                          1554  
00001B94                          1555  ;------------------- Bit Shift Direction -------------------;
00001B94                          1556  ; This checks bit 8 to see what direction the shift is going
00001B94                          1557  
00001B94                          1558  ; REGISTERS USED: D0, D1, D4 (const), A6
00001B94                          1559  
00001B94                          1560  OP_SHIFT_DIRECTION
00001B94  4EB9 00002204           1561      Jsr     GETBIT8 ; Get the shift direction bit
00001B9A                          1562      
00001B9A  B03C 0000               1563      Cmp.B   #%0,D0  ; 0 is Right
00001B9E  6700 0006               1564      Beq     OP_SHIFT_RIGHT
00001BA2                          1565  
00001BA2  6000 0008               1566      Bra     OP_SHIFT_LEFT   ; Otherwise it's a left shift
00001BA6                          1567  
00001BA6                          1568  OP_SHIFT_RIGHT
00001BA6                          1569      ; Add the character and return
00001BA6  1CFC 0052               1570      Move.B  #'R',(A6)+
00001BAA                          1571  
00001BAA  4E75                    1572      Rts    
00001BAC                          1573  
00001BAC                          1574  OP_SHIFT_LEFT
00001BAC                          1575      ; Add the character and return
00001BAC  1CFC 004C               1576      Move.B  #'L',(A6)+
00001BB0                          1577  
00001BB0  4E75                    1578      Rts
00001BB2                          1579      
00001BB2                          1580  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];  
00001BB2                          1581  ;-------------------- Effective Address Sub Routines --------------------;
00001BB2                          1582  ; These subroutines look for the correct effective address
00001BB2                          1583  ; in each OP code.
00001BB2                          1584  ;]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]];
00001BB2                          1585  
00001BB2                          1586  ;=============================================;
00001BB2                          1587  ;--------------- EA Move/MoveA ---------------;
00001BB2                          1588  ;=============================================;
00001BB2                          1589  EA_MOVE
00001BB2  4EB9 00001BC4           1590          Jsr     EA_MOVE_SOURCE          ; Add the EA for source
00001BB8  1CFC 002C               1591          Move.B  #',', (A6)+             ; Add a comma
00001BBC  4EB9 00001BD4           1592          Jsr     EA_MOVE_DEST            ; Add the EA for destination
00001BC2                          1593          
00001BC2  4E75                    1594          RTS
00001BC4                          1595                  
00001BC4                          1596  EA_MOVE_SOURCE  ; Find out Move's source
00001BC4  4EB9 00002146           1597          Jsr     EA_0TO5                 ; Get the EA
00001BCA                          1598          
00001BCA  B03C 0004               1599          Cmp.B   #Imm_Reg, D0            ; #<data>
00001BCE  6700 004C               1600          Beq     EA_MOVE_SIZE
00001BD2                          1601          
00001BD2  4E75                    1602          Rts
00001BD4                          1603          
00001BD4                          1604  EA_MOVE_DEST    ; Find out Move's destination
00001BD4  4EB9 000021CE           1605          Jsr     GET6TO8                 ; Get destination mode
00001BDA  1A00                    1606          Move.B  D0, D5                  ; Move destination mode to D5
00001BDC  4EB9 000021BC           1607          Jsr     GET9TO11                ; Get destination register
00001BE2                          1608          
00001BE2                          1609          ; List of valid effective addresses
00001BE2  BA3C 0000               1610          Cmp.B   #Dn_Mode, D5            ; Dn
00001BE6  6700 0482               1611          Beq     EA_DN
00001BEA                          1612          
00001BEA  BA3C 0001               1613          Cmp.B   #An_Mode, D5            ; An
00001BEE  6700 0486               1614          Beq     EA_AN
00001BF2                          1615          
00001BF2  BA3C 0002               1616          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00001BF6  6700 048A               1617          Beq     EA_AN_PNTR
00001BFA                          1618          
00001BFA  BA3C 0003               1619          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00001BFE  6700 0496               1620          Beq     EA_AN_INC
00001C02                          1621          
00001C02  BA3C 0004               1622          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00001C06  6700 04A6               1623          Beq     EA_AN_DEC
00001C0A                          1624          
00001C0A                          1625          ; Comparing registers at this point because modes are the same
00001C0A  B03C 0000               1626          Cmp.B   #Word_Reg, D0           ; (xxx).W
00001C0E  6700 04B6               1627          Beq     EA_WORD_ADDR
00001C12                          1628          
00001C12  B03C 0001               1629          Cmp.B   #Long_Reg, D0           ; (xxx).L
00001C16  6700 04F2               1630          Beq     EA_LONG_ADDR
00001C1A                          1631          
00001C1A  4E75                    1632          Rts
00001C1C                          1633          
00001C1C                          1634  EA_MOVE_SIZE    ; Find the size of immediate data being moved
00001C1C  4EB9 00002198           1635          Jsr     GET12TO13               ; Get Move size
00001C22                          1636  
00001C22  B03C 0001               1637          Cmp.B   #%01, D0                ; Byte
00001C26  6700 04EE               1638          Beq     EA_IMM_BYTE
00001C2A                          1639  
00001C2A  B03C 0003               1640          Cmp.B   #%11, D0                ; Word
00001C2E  6700 04F6               1641          Beq     EA_IMM_WORD
00001C32                          1642          
00001C32  B03C 0002               1643          Cmp.B   #%10, D0                ; Long
00001C36  6700 04FE               1644          Beq     EA_IMM_LONG
00001C3A                          1645          
00001C3A  4E75                    1646          Rts
00001C3C                          1647          
00001C3C                          1648  ;=================================================================;
00001C3C                          1649  ;---------------------------- EA MoveM ---------------------------;
00001C3C                          1650  ; D2 stores the counter for the number of consecutive ones in the
00001C3C                          1651  ; register list mask
00001C3C                          1652  ;
00001C3C                          1653  ; D3 stores a 1 if the register being added is the first register, 
00001C3C                          1654  ; or 0 if the register is not the first register being added
00001C3C                          1655  ;
00001C3C                          1656  ; D5 stores the register list mask
00001C3C                          1657  ;
00001C3C                          1658  ; D6 stores any expansion words
00001C3C                          1659  ;
00001C3C                          1660  ; D7 stores the loop counter
00001C3C                          1661  ;=================================================================;
00001C3C                          1662  EA_MOVEM    ; Determines the EA for MoveM
00001C3C  48E7 3F00               1663          MoveM.L D2-D7, -(SP)            ; Save D2-D7 at address A4 so we can use them for MoveM 
00001C40                          1664          
00001C40  4282                    1665          Clr.L   D2                      ; Clear out the data registers
00001C42  4283                    1666          Clr.L   D3
00001C44  4285                    1667          Clr.L   D5
00001C46  4286                    1668          Clr.L   D6
00001C48  4287                    1669          Clr.L   D7
00001C4A                          1670          
00001C4A  5203                    1671          Add.B   #1, D3                  ; Set D3 to 1 to specify the first register
00001C4C  3A1B                    1672          Move.W  (A3)+, D5               ; Store the register list mask
00001C4E                          1673          
00001C4E  4EB9 0000227E           1674          Jsr     GETBIT10                ; Get the direction bit
00001C54                          1675          
00001C54  B03C 0000               1676          Cmp.B   #%0, D0                 ; If direction bit is 0, register to memory
00001C58  6700 0008               1677          Beq     EA_MOVEM_REG_TO_MEM
00001C5C                          1678          
00001C5C  4EF9 00001C78           1679          Jmp     EA_MOVEM_MEM_TO_REG     ; Else, memory to register
00001C62                          1680          
00001C62                          1681  EA_MOVEM_REG_TO_MEM ; Determines EA for register to memory transfer direction
00001C62  4EB9 00001C94           1682          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C68  1CFC 002C               1683          Move.B  #',', (A6)+             ; Add a comma
00001C6C  4EB9 00002146           1684          Jsr     EA_0TO5                 ; Get the EA
00001C72                          1685          
00001C72  4CDF 00FC               1686          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C76                          1687                  
00001C76  4E75                    1688          RTS
00001C78                          1689          
00001C78                          1690  EA_MOVEM_MEM_TO_REG ; Determines EA for memory to register transfer direction 
00001C78  3E05                    1691          Move.W  D5, D7                  ; Store the register list mask in D7 temporarily
00001C7A  4EB9 00002146           1692          Jsr     EA_0TO5                 ; Get the EA
00001C80  1CFC 002C               1693          Move.B  #',', (A6)+             ; Add a comma
00001C84  3A07                    1694          Move.W  D7, D5                  ; Move the register list mask back to D5
00001C86  4287                    1695          Clr.L   D7                      ; Clear D7
00001C88  4EB9 00001C94           1696          Jsr     EA_MOVEM_LIST_LOOP      ; Get the list of registers
00001C8E                          1697          
00001C8E  4CDF 00FC               1698          MoveM.L (SP)+, D2-D7            ; Restore the saved data registers
00001C92                          1699                  
00001C92  4E75                    1700          RTS
00001C94                          1701                  
00001C94                          1702  EA_MOVEM_LIST_LOOP ; Determines if the list is in predecrement order or post increment order
00001C94  BE3C 0010               1703          Cmp.B   #16, D7                 ; If the loop counter is greater than or equal to 16, end
00001C98  6C00 0016               1704          Bge     EA_MOVEM_LIST_END
00001C9C                          1705  
00001C9C  4EB9 000021E0           1706          Jsr     GET3TO5                 ; Get the EA mode
00001CA2                          1707          
00001CA2  B03C 0004               1708          Cmp.B   #%100, D0               ; Predecrement mode
00001CA6  6700 000A               1709          Beq     EA_MOVEM_PRE_DEC
00001CAA                          1710          
00001CAA  4EF9 00001CBC           1711          Jmp     EA_MOVEM_POST_INC       ; Post increment and control modes
00001CB0                          1712          
00001CB0                          1713  EA_MOVEM_LIST_END   ; Ends the list loop
00001CB0  4E75                    1714          Rts
00001CB2                          1715          
00001CB2                          1716  EA_MOVEM_PRE_DEC    ; Predecrement mode
00001CB2  E35D                    1717          Rol.W   #1, D5                  ; Rotate the register list mask to the left by 1
00001CB4                          1718          
00001CB4  6500 0010               1719          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001CB8                          1720          
00001CB8  6400 002C               1721          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001CBC                          1722          
00001CBC                          1723  EA_MOVEM_POST_INC   ; Post increment mode
00001CBC  E25D                    1724          Ror.W   #1, D5                  ; Rotate the register list mask to the right by 1
00001CBE                          1725          
00001CBE  6500 0006               1726          Bcs     EA_MOVEM_CARRY_SET      ; Branch if the bit rotated out was 1
00001CC2                          1727          
00001CC2  6400 0022               1728          Bcc     EA_MOVEM_CARRY_CLEAR    ; Branch if the bit rotated out was 0
00001CC6                          1729          
00001CC6                          1730  EA_MOVEM_CARRY_SET  ; The bit rotated out was 1
00001CC6  B63C 0001               1731          Cmp.B   #1, D3                  ; Check to see if this is the first register being added to the list
00001CCA  6700 002A               1732          Beq     EA_MOVEM_FIRST_REG      ; Add the first register to the list
00001CCE                          1733          
00001CCE  B43C 0000               1734          Cmp.B   #0, D2                  ; If this bit is not in the middle of a list of consecutive ones, add a '/' and register
00001CD2  6700 0032               1735          Beq     EA_MOVEM_ADD_SINGLE_REG
00001CD6                          1736          
00001CD6  5207                    1737          Add.B   #1, D7                  ; Increment the loop counter
00001CD8  5202                    1738          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001CDA                          1739          
00001CDA  BE3C 0010               1740          Cmp.B   #16, D7                 ; If this bit is the last bit, check to see if it is the last bit of a consecutive list
00001CDE  6700 0038               1741          Beq     EA_MOVEM_LAST_REG
00001CE2                          1742          
00001CE2  4EF8 1C94               1743          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CE6                          1744          
00001CE6                          1745  EA_MOVEM_CARRY_CLEAR    ; The bit rotated out was a 0
00001CE6  B43C 0001               1746          Cmp.B   #1, D2                  ; If the bit was at the end of a consecutive list of ones, add a '-' and register
00001CEA  6E00 003A               1747          Bgt     EA_MOVEM_ADD_LAST_REG
00001CEE                          1748          
00001CEE  5207                    1749          Add.B   #1, D7                  ; Increment the loop counter
00001CF0                          1750          
00001CF0  4282                    1751          Clr.L   D2                      ; Clear the counter for consecutive ones
00001CF2                          1752          
00001CF2  4EF8 1C94               1753          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001CF6                          1754  
00001CF6                          1755  EA_MOVEM_FIRST_REG  ; The very first register being added to the list
00001CF6  4EB9 00001D3A           1756          Jsr     EA_MOVEM_REG            ; Add a register without the '/' in front
00001CFC                          1757          
00001CFC  4283                    1758          Clr.L   D3                      ; Clear D3 because the very first register has been placed
00001CFE                          1759          
00001CFE  5207                    1760          Add.B   #1, D7                  ; Increment the loop counter
00001D00  5202                    1761          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001D02                          1762          
00001D02  4EF8 1C94               1763          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D06                          1764          
00001D06                          1765  EA_MOVEM_ADD_SINGLE_REG ; Adds a '/' and a register
00001D06  1CFC 002F               1766          Move.B  #'/', (A6)+
00001D0A                          1767          
00001D0A  4EB9 00001D3A           1768          Jsr     EA_MOVEM_REG            ; Add a register
00001D10                          1769          
00001D10  5207                    1770          Add.B   #1, D7                  ; Increment the loop counter 
00001D12  5202                    1771          Add.B   #1, D2                  ; Increment the consecutive ones counter
00001D14                          1772          
00001D14  4EF8 1C94               1773          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D18                          1774          
00001D18                          1775  EA_MOVEM_LAST_REG   ; Adds the last register if it was the last bit being rotated out and it was part of a consecutive list
00001D18  B43C 0001               1776          Cmp.B   #1, D2                  ; Check to see if the bit was part of a consecutive list of ones
00001D1C  6E00 0008               1777          Bgt     EA_MOVEM_ADD_LAST_REG
00001D20                          1778          
00001D20  5207                    1779          Add.B   #1, D7                  ; Increment the loop counter
00001D22                          1780          
00001D22  4EF8 1C94               1781          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D26                          1782          
00001D26                          1783  EA_MOVEM_ADD_LAST_REG   ; Adds a '-' and the register, adds the last register in a consecutive list of ones
00001D26  1CFC 002D               1784          Move.B  #'-', (A6)+
00001D2A                          1785          
00001D2A  5307                    1786          Sub.B   #1, D7                  ; Move back to the previous register
00001D2C                          1787          
00001D2C  4EB9 00001D3A           1788          Jsr     EA_MOVEM_REG            ; Add the previous register as the last register in a consecutive list of ones
00001D32                          1789          
00001D32  5407                    1790          Add.B   #2, D7                  ; Add 2 to the loop counter to make up for the 1 subtracted earlier and to move forward
00001D34                          1791          
00001D34  4282                    1792          Clr.L   D2                      ; Clear the consecutive ones counter
00001D36                          1793          
00001D36  4EF8 1C94               1794          Jmp     EA_MOVEM_LIST_LOOP      ; Loop again
00001D3A                          1795          
00001D3A                          1796  EA_MOVEM_REG    ; Determines the correct register to add based on the value of the loop counter
00001D3A  4280                    1797          Clr.L   D0                      ; Clear D0
00001D3C  BE3C 0000               1798          Cmp.B   #0, D7                  ; If the loop counter is 0, add D0
00001D40  6700 0328               1799          Beq     EA_DN
00001D44                          1800          
00001D44  103C 0001               1801          Move.B  #1, D0                  ; Move a 1 into D0
00001D48  BE3C 0001               1802          Cmp.B   #1, D7                  ; If the loop counter is 1, add D1
00001D4C  6700 031C               1803          Beq     EA_DN
00001D50                          1804          
00001D50  103C 0002               1805          Move.B  #2, D0
00001D54  BE3C 0002               1806          Cmp.B   #2, D7
00001D58  6700 0310               1807          Beq     EA_DN
00001D5C                          1808  
00001D5C  103C 0003               1809          Move.B  #3, D0
00001D60  BE3C 0003               1810          Cmp.B   #3, D7
00001D64  6700 0304               1811          Beq     EA_DN
00001D68                          1812  
00001D68  103C 0004               1813          Move.B  #4, D0
00001D6C  BE3C 0004               1814          Cmp.B   #4, D7
00001D70  6700 02F8               1815          Beq     EA_DN
00001D74                          1816  
00001D74  103C 0005               1817          Move.B  #5, D0
00001D78  BE3C 0005               1818          Cmp.B   #5, D7
00001D7C  6700 02EC               1819          Beq     EA_DN
00001D80                          1820  
00001D80  103C 0006               1821          Move.B  #6, D0
00001D84  BE3C 0006               1822          Cmp.B   #6, D7
00001D88  6700 02E0               1823          Beq     EA_DN
00001D8C                          1824          
00001D8C  103C 0007               1825          Move.B  #7, D0
00001D90  BE3C 0007               1826          Cmp.B   #7, D7
00001D94  6700 02D4               1827          Beq     EA_DN
00001D98                          1828          
00001D98  4280                    1829          Clr.L   D0
00001D9A  BE3C 0008               1830          Cmp.B   #8, D7
00001D9E  6700 02D6               1831          Beq     EA_AN
00001DA2                          1832  
00001DA2  103C 0001               1833          Move.B  #1, D0
00001DA6  BE3C 0009               1834          Cmp.B   #9, D7
00001DAA  6700 02CA               1835          Beq     EA_AN
00001DAE                          1836  
00001DAE  103C 0002               1837          Move.B  #2, D0
00001DB2  BE3C 000A               1838          Cmp.B   #10, D7
00001DB6  6700 02BE               1839          Beq     EA_AN
00001DBA                          1840          
00001DBA  103C 0003               1841          Move.B  #3, D0
00001DBE  BE3C 000B               1842          Cmp.B   #11, D7
00001DC2  6700 02B2               1843          Beq     EA_AN
00001DC6                          1844          
00001DC6  103C 0004               1845          Move.B  #4, D0
00001DCA  BE3C 000C               1846          Cmp.B   #12, D7
00001DCE  6700 02A6               1847          Beq     EA_AN
00001DD2                          1848          
00001DD2  103C 0005               1849          Move.B  #5, D0
00001DD6  BE3C 000D               1850          Cmp.B   #13, D7
00001DDA  6700 029A               1851          Beq     EA_AN
00001DDE                          1852          
00001DDE  103C 0006               1853          Move.B  #6, D0
00001DE2  BE3C 000E               1854          Cmp.B   #14, D7
00001DE6  6700 028E               1855          Beq     EA_AN
00001DEA                          1856          
00001DEA  103C 0007               1857          Move.B  #7, D0
00001DEE  BE3C 000F               1858          Cmp.B   #15, D7
00001DF2  6700 0282               1859          Beq     EA_AN
00001DF6                          1860  
00001DF6                          1861  ;===========================================;        
00001DF6                          1862  ;--------------- EA Add/AddA ---------------;
00001DF6                          1863  ;===========================================;       
00001DF6                          1864  EA_ADD  ; Figures out the EA for Add        
00001DF6  4EB9 000021CE           1865          Jsr     GET6TO8                 ; Isolate the Op mode
00001DFC                          1866          
00001DFC  B03C 0003               1867          Cmp.B   #%011, D0               ; Compare to AddA word
00001E00  6700 0028               1868          Beq     EA_ADDA
00001E04                          1869          
00001E04  B03C 0007               1870          Cmp.B   #%111, D0               ; Compare to AddA long
00001E08  6700 0020               1871          Beq     EA_ADDA
00001E0C                          1872  
00001E0C  B03C 0000               1873          Cmp.B   #%000, D0               ; Compare to Add source byte
00001E10  6700 0030               1874          Beq     EA_ADD_OPMODE_SOURCE
00001E14                          1875          
00001E14  B03C 0001               1876          Cmp.B   #%001, D0               ; Compare to Add source word
00001E18  6700 0028               1877          Beq     EA_ADD_OPMODE_SOURCE
00001E1C                          1878          
00001E1C  B03C 0002               1879          Cmp.B   #%010, D0               ; Compare to Add source Long
00001E20  6700 0020               1880          Beq     EA_ADD_OPMODE_SOURCE
00001E24                          1881          
00001E24  4EF9 00001E5A           1882          Jmp     EA_ADD_OPMODE_DEST      ; Must be an Add destination if none of the above
00001E2A                          1883          
00001E2A                          1884  EA_ADDA ; Figures out the EA for AddA
00001E2A  4EB9 00001E72           1885          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001E30  1CFC 002C               1886          Move.B  #',', (A6)+             ; Add a comma
00001E34  4EB9 000021BC           1887          Jsr     GET9TO11                ; Get the register
00001E3A  4EB9 00002076           1888          Jsr     EA_AN                   ; Add An
00001E40                          1889          
00001E40  4E75                    1890          RTS
00001E42                          1891          
00001E42                          1892  EA_ADD_OPMODE_SOURCE    ; Finds the EA for Add if it is for the source
00001E42  4EB9 00001E72           1893          Jsr     EA_ADD_ADDRESS          ; Get the source EA
00001E48  1CFC 002C               1894          Move.B  #',', (A6)+             ; Add a comma
00001E4C  4EB9 000021BC           1895          Jsr     GET9TO11                ; Get the register
00001E52  4EB9 0000206A           1896          Jsr     EA_DN                   ; Add Dn
00001E58                          1897          
00001E58  4E75                    1898          RTS
00001E5A                          1899          
00001E5A                          1900  EA_ADD_OPMODE_DEST      ; Finds the EA for Add if it is for the destination
00001E5A  4EB9 000021BC           1901          Jsr     GET9TO11                ; Get the register
00001E60  4EB9 0000206A           1902          Jsr     EA_DN                   ; Add Dn
00001E66  1CFC 002C               1903          Move.B  #',', (A6)+             ; Add a comma
00001E6A  4EB9 00001E72           1904          Jsr     EA_ADD_ADDRESS          ; Get the destination EA 
00001E70                          1905          
00001E70  4E75                    1906          RTS
00001E72                          1907          
00001E72                          1908  EA_ADD_ADDRESS
00001E72  4EB9 00002146           1909          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001E78                          1910          
00001E78  B03C 0004               1911          Cmp.B   #Imm_Reg, D0            ; #<data>
00001E7C  6700 0004               1912          Beq     EA_ADD_SIZE
00001E80                          1913  
00001E80  4E75                    1914          Rts
00001E82                          1915          
00001E82                          1916  EA_ADD_SIZE ; Find the size of immediate data being moved
00001E82  4EB9 000021CE           1917          Jsr     GET6TO8                 ; Get Move size
00001E88                          1918  
00001E88  B03C 0000               1919          Cmp.B   #%000, D0               ; Byte
00001E8C  6700 0288               1920          Beq     EA_IMM_BYTE
00001E90                          1921  
00001E90  B03C 0001               1922          Cmp.B   #%001, D0               ; Word
00001E94  6700 0290               1923          Beq     EA_IMM_WORD
00001E98                          1924          
00001E98  B03C 0002               1925          Cmp.B   #%010, D0               ; Long
00001E9C  6700 0298               1926          Beq     EA_IMM_LONG
00001EA0                          1927          
00001EA0  B03C 0003               1928          Cmp.B   #%011, D0               ; AddA Word
00001EA4  6700 0280               1929          Beq     EA_IMM_WORD
00001EA8                          1930     
00001EA8  B03C 0007               1931          Cmp.B   #%111, D0               ; AddA Long
00001EAC  6700 0288               1932          Beq     EA_IMM_LONG
00001EB0                          1933          
00001EB0  4E75                    1934          Rts
00001EB2                          1935          
00001EB2                          1936  ;=================================================;        
00001EB2                          1937  ;-------------------- EA AddQ --------------------;
00001EB2                          1938  ;=================================================;
00001EB2                          1939  EA_ADDQ ; Figures out the EA for AddQ
00001EB2  4EB9 00001EC4           1940          Jsr     EA_ADDQ_CHECK_8         ; Get the immediate value
00001EB8  1CFC 002C               1941          Move.B  #',', (A6)+             ; Add a comma
00001EBC  4EB9 00001EE8           1942          Jsr     EA_ADDQ_DEST            ; Add the destination
00001EC2                          1943          
00001EC2  4E75                    1944          Rts
00001EC4                          1945  
00001EC4                          1946  EA_ADDQ_CHECK_8 ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001EC4  4EB9 000021BC           1947          Jsr     GET9TO11                ; Isolate the count/register bits
00001ECA                          1948          
00001ECA  B03C 0000               1949          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001ECE  6E00 000C               1950          Bgt     EA_ADDQ_IMMEDIATE
00001ED2                          1951          
00001ED2  103C 0008               1952          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001ED6                          1953          
00001ED6  4EF9 00001EDC           1954          Jmp     EA_ADDQ_IMMEDIATE
00001EDC                          1955          
00001EDC                          1956  EA_ADDQ_IMMEDIATE   ; Adds an immediate value before the comma
00001EDC  1CFC 0023               1957          Move.B  #'#', (A6)+
00001EE0  0600 0030               1958          Add.B   #$30, D0
00001EE4  1CC0                    1959          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001EE6                          1960          
00001EE6  4E75                    1961          Rts
00001EE8                          1962          
00001EE8                          1963  EA_ADDQ_DEST    ; Determines the destination       
00001EE8  4EB9 00002146           1964          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001EEE                          1965          
00001EEE  4E75                    1966          Rts     
00001EF0                          1967          
00001EF0                          1968  ;=========================================================;        
00001EF0                          1969  ;---------------------- EA Sub/SubA ----------------------;
00001EF0                          1970  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001EF0                          1971  ; Sub/SubA are exactly the same.
00001EF0                          1972  ;=========================================================;
00001EF0                          1973  EA_SUB
00001EF0  4EF8 1DF6               1974          Jmp     EA_ADD
00001EF4                          1975  
00001EF4                          1976  ;=========================================================;        
00001EF4                          1977  ;---------------------- EA Cmp/CmpA ----------------------;
00001EF4                          1978  ; Jumps straight to EA_ADD because the EA for Add/AddA and
00001EF4                          1979  ; Cmp/CmpA are exactly the same.
00001EF4                          1980  ;=========================================================;
00001EF4                          1981  EA_CMP       
00001EF4  4EF8 1DF6               1982          Jmp     EA_ADD
00001EF8                          1983          
00001EF8                          1984  ;=========================================================;        
00001EF8                          1985  ;------------------------ EA Lea -------------------------;
00001EF8                          1986  ; Jumps straight to EA_ADD because the EA for AddA and Lea
00001EF8                          1987  ; are exactly the same.
00001EF8                          1988  ;=========================================================;
00001EF8                          1989  EA_LEA
00001EF8  4EF8 1DF6               1990          Jmp     EA_ADD
00001EFC                          1991          
00001EFC                          1992  ;=========================================================;        
00001EFC                          1993  ;------------------------ EA And -------------------------;
00001EFC                          1994  ; Jumps straight to EA_ADD because the EA for Add and And
00001EFC                          1995  ; are exactly the same.
00001EFC                          1996  ;=========================================================;
00001EFC                          1997  EA_AND
00001EFC  4EF8 1DF6               1998          Jmp     EA_ADD
00001F00                          1999          
00001F00                          2000  ;=========================================================;        
00001F00                          2001  ;------------------------ EA Eor -------------------------;
00001F00                          2002  ; Jumps straight to EA_ADD because the EA for Add and Eor
00001F00                          2003  ; are exactly the same.
00001F00                          2004  ;=========================================================;
00001F00                          2005  EA_EOR
00001F00  4EF8 1DF6               2006          Jmp     EA_ADD
00001F04                          2007          
00001F04                          2008  ;=========================================================;        
00001F04                          2009  ;------------------------ EA Neg -------------------------;
00001F04                          2010  ;=========================================================;
00001F04                          2011  EA_NEG
00001F04  4EB9 00002146           2012          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F0A                          2013          
00001F0A  4E75                    2014          RTS
00001F0C                          2015          
00001F0C                          2016  ;=========================================================;        
00001F0C                          2017  ;------------------------ EA Not -------------------------;
00001F0C                          2018  ; Jumps straight to EA_NEG because Neg and Not have the
00001F0C                          2019  ; exact same EAs. 
00001F0C                          2020  ;=========================================================;
00001F0C                          2021  EA_NOT
00001F0C  4EF8 1F04               2022          Jmp     EA_NEG 
00001F10                          2023          
00001F10                          2024  ;=========================================================;        
00001F10                          2025  ;------------------------ EA Jsr -------------------------;
00001F10                          2026  ; Jumps straight to EA_NEG because Neg and Jsr have the
00001F10                          2027  ; exact same EAs. 
00001F10                          2028  ;=========================================================;
00001F10                          2029  EA_Jsr
00001F10  4EF8 1F04               2030          Jmp     EA_NEG 
00001F14                          2031  
00001F14                          2032  ;=========================================================;
00001F14                          2033  ;--------------------- EA Bit Shift ----------------------;
00001F14                          2034  ; Finds the EA for ASd, LSd, ROd. All of these OP codes
00001F14                          2035  ; are combined because the EA for each code is exactly the
00001F14                          2036  ; same.
00001F14                          2037  ;=========================================================;
00001F14                          2038  EA_BIT_SHIFT    ; Figures out the EA for bit shift functions
00001F14  4EB9 00002290           2039          Jsr     GET6TO7
00001F1A                          2040          
00001F1A  B03C 0003               2041          Cmp.B   #%11, D0                ; If bits 6 and 7 are not %11, then we are shifting a register
00001F1E  6600 0012               2042          Bne     EA_SHIFT_REGISTER
00001F22                          2043          
00001F22  4EB9 00001F2A           2044          Jsr     EA_SHIFT_MEMORY         ; If bits 6 and 7 are %11, then we are shifting memory
00001F28                          2045          
00001F28  4E75                    2046          RTS
00001F2A                          2047                  
00001F2A                          2048  EA_SHIFT_MEMORY ; Adds the correct EA for a memory shift
00001F2A  4EB9 00002146           2049          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001F30                          2050          
00001F30  4E75                    2051          Rts
00001F32                          2052          
00001F32                          2053  EA_SHIFT_REGISTER   ; Figure out if we are shifting by #<data> or by the value in a data register
00001F32  4EB9 0000225E           2054          Jsr     GETBIT5
00001F38                          2055          
00001F38  B03C 0000               2056          Cmp.B   #0, D0                  ; Check if bit 5 is %0
00001F3C  6700 0008               2057          Beq     EA_SHIFT_CHECK_8
00001F40                          2058          
00001F40  4EF9 00001F6E           2059          Jmp     EA_SHIFT_DN             ; If it's not, we are shifting from a data register
00001F46                          2060          
00001F46                          2061  EA_SHIFT_CHECK_8    ; A bit value of 1-7 corresponds to 1-7, but 0 corresponds to 8
00001F46  4EB9 000021BC           2062          Jsr     GET9TO11                ; Isolate the count/register bits
00001F4C                          2063          
00001F4C  B03C 0000               2064          Cmp.B   #0, D0                  ; If the bits are greater than 0, proceed normally
00001F50  6E00 000C               2065          Bgt     EA_SHIFT_IMMEDIATE
00001F54                          2066          
00001F54  103C 0008               2067          Move.B  #8, D0                  ; Else, use 8 as the immediate value
00001F58                          2068                  
00001F58  4EF9 00001F5E           2069          Jmp     EA_SHIFT_IMMEDIATE
00001F5E                          2070          
00001F5E                          2071  EA_SHIFT_IMMEDIATE  ; Adds an immediate value before the comma
00001F5E  1CFC 0023               2072          Move.B  #'#', (A6)+
00001F62  0600 0030               2073          Add.B   #$30, D0
00001F66  1CC0                    2074          Move.B  D0, (A6)+               ; Add the immediate value to the string
00001F68                          2075  
00001F68  4EF9 00001F80           2076          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it
00001F6E                          2077          
00001F6E                          2078  EA_SHIFT_DN ; Adds a data register before the comma
00001F6E  4EB9 000021BC           2079          Jsr     GET9TO11                ; Isolate the data register bits
00001F74                          2080          
00001F74  4EB9 0000206A           2081          Jsr     EA_DN                   ; Add the data register to the string
00001F7A                          2082          
00001F7A  4EF9 00001F80           2083          Jmp     EA_SHIFT_COMMA          ; Add the comma and everything after it 
00001F80                          2084          
00001F80                          2085  EA_SHIFT_COMMA  ; Adds the comma and everything after it to the string
00001F80  1CFC 002C               2086          Move.B  #',', (A6)+
00001F84                          2087          
00001F84  4EB9 000021F2           2088          Jsr     GET0TO2                 ; Get the register number
00001F8A                          2089          
00001F8A  4EB9 0000206A           2090          Jsr     EA_DN                   ; Add the register
00001F90                          2091          
00001F90  4E75                    2092          RTS
00001F92                          2093  
00001F92                          2094  ;============================================;        
00001F92                          2095  ;--------------- EA Immediate ---------------;
00001F92                          2096  ; Provides EA for SubI, OrI, EorI, and CmpI.
00001F92                          2097  ;============================================;
00001F92                          2098  EA_IMMEDIATE    ; Figures out the EA for immediate data OP codes
00001F92  4EB9 00001FA4           2099          Jsr     EA_IMMEDIATE_SIZE       ; Get the size of the immediate data and add to string
00001F98  1CFC 002C               2100          Move.B  #',', (A6)+             ; Add a comma
00001F9C  4EB9 00001FC2           2101          Jsr     EA_IMMEDIATE_DEST       ; Add the destination EA
00001FA2                          2102          
00001FA2  4E75                    2103          RTS
00001FA4                          2104          
00001FA4                          2105  EA_IMMEDIATE_SIZE   ; Determines the size of the immediate data and adds it
00001FA4  4EB9 00002290           2106          Jsr     GET6TO7                 ; Isolate the size bits
00001FAA                          2107                  
00001FAA  B03C 0001               2108          Cmp.B   #%01, D0                ; Immediate word
00001FAE  6700 0176               2109          Beq     EA_IMM_WORD
00001FB2                          2110          
00001FB2  B03C 0002               2111          Cmp.B   #%10, D0                ; Immediate long
00001FB6  6700 017E               2112          Beq     EA_IMM_LONG
00001FBA                          2113        
00001FBA  4EF9 00002116           2114          Jmp     EA_IMM_BYTE
00001FC0                          2115  
00001FC0  4E75                    2116          Rts
00001FC2                          2117          
00001FC2                          2118  EA_IMMEDIATE_DEST   ; Determines the destination EA
00001FC2  4EB9 00002146           2119          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001FC8                          2120          
00001FC8  4E75                    2121          Rts
00001FCA                          2122        
00001FCA                          2123  ;=================================================;  
00001FCA                          2124  ;-------------------- EA Muls --------------------;
00001FCA                          2125  ;=================================================;
00001FCA                          2126  EA_MULS ; Determines the EA for Muls
00001FCA  4EB9 00001FE2           2127          Jsr     EA_MULS_ADDRESS         ; Get the EA
00001FD0  1CFC 002C               2128          Move.B  #',', (A6)+             ; Add a comma
00001FD4  4EB9 000021BC           2129          Jsr     GET9TO11                ; Get the register
00001FDA  4EB9 0000206A           2130          Jsr     EA_DN                   ; Add Dn
00001FE0                          2131          
00001FE0  4E75                    2132          RTS
00001FE2                          2133          
00001FE2                          2134  EA_MULS_ADDRESS ; Determines the EA
00001FE2  4EB9 00002146           2135          Jsr     EA_0TO5                 ; Check for all EA except #<data>
00001FE8                          2136          
00001FE8  B03C 0004               2137          Cmp.B   #Imm_Reg, D0            ; Check for #<data>
00001FEC  6700 0138               2138          Beq     EA_IMM_WORD
00001FF0                          2139          
00001FF0  4E75                    2140          Rts
00001FF2                          2141          
00001FF2                          2142  ;=================================================;  
00001FF2                          2143  ;-------------------- EA DIVS --------------------;
00001FF2                          2144  ; Jumps straight to EA_DIVS because the EA for
00001FF2                          2145  ; both OP codes is exactly the same.
00001FF2                          2146  ;=================================================;
00001FF2                          2147  EA_DIVS
00001FF2  4EF8 1FCA               2148          Jmp     EA_MULS
00001FF6                          2149          
00001FF6                          2150  ;=================================================;        
00001FF6                          2151  ;-------------------- EA BTST --------------------;
00001FF6                          2152  ;=================================================;
00001FF6                          2153  EA_BTST ; Determines the EA for Btst
00001FF6  4EB9 00002204           2154          Jsr     GETBIT8                 ; Use bit 8 to determine if the bit number is immediate or a data register
00001FFC                          2155          
00001FFC  B03C 0001               2156          Cmp.B   #%1, D0                 ; 1 is a data register
00002000  6700 0008               2157          Beq     EA_BTST_DN
00002004                          2158          
00002004  4EF9 0000201E           2159          Jmp     EA_BTST_IMM             ; Else (0), the bit number is immediate data
0000200A                          2160          
0000200A                          2161  EA_BTST_DN  ; Gets the register for the bit number
0000200A  4EB9 000021BC           2162          Jsr     GET9TO11                ; Get the register
00002010  4EB9 0000206A           2163          Jsr     EA_DN                   ; Add the register to the string
00002016                          2164          
00002016  4EB9 0000202C           2165          Jsr     EA_BTST_ADDRESS         ; Add the EA
0000201C                          2166          
0000201C  4E75                    2167          RTS
0000201E                          2168  
0000201E                          2169  EA_BTST_IMM ; Gets the immediate data for the bit number
0000201E  4EB9 00002116           2170          Jsr     EA_IMM_BYTE             ; Add the bit number as an immediate hex byte
00002024                          2171          
00002024  4EB9 0000202C           2172          Jsr     EA_BTST_ADDRESS         ; Add the register to the string
0000202A                          2173          
0000202A  4E75                    2174          RTS
0000202C                          2175  
0000202C                          2176  EA_BTST_ADDRESS ; Get the EA
0000202C  1CFC 002C               2177          Move.B  #',', (A6)+
00002030                          2178  
00002030  4EB9 00002146           2179          Jsr     EA_0TO5                 ; Check the EA for everything but #<data>
00002036                          2180          
00002036  B03C 0004               2181          Cmp.B   #Imm_Reg, D0            ; Check if the EA is #<data>
0000203A  6700 00DA               2182          Beq     EA_IMM_BYTE             ; Add immediate byte for EA
0000203E                          2183          
0000203E  4E75                    2184          Rts
00002040                          2185          
00002040                          2186  ;==================================================;        
00002040                          2187  ;------------------- EA Branch --------------------;
00002040                          2188  ; Determines the EA for Bra, Beq, Bne, Blt, and Bhi.
00002040                          2189  ;==================================================;
00002040                          2190  EA_BRANCH  ; Determines the EA for Branch codes
00002040  4EB9 00002270           2191          Jsr     GET0TO7                 ; Get the 8 displacement bits
00002046                          2192          
00002046  2C0B                    2193          Move.L  A3, D6                  ; Move address after the Bra word to D6
00002048                          2194          
00002048  B03C 0000               2195          Cmp.B   #0, D0                  ; If the displacement bits are 0 then get the next word
0000204C  6700 0008               2196          Beq     EA_BRANCH_16_BIT
00002050                          2197          
00002050  4EF9 0000205E           2198          Jmp     EA_BRANCH_ADD_DIS       ; Else, add the displacement to D6
00002056                          2199  
00002056                          2200  EA_BRANCH_16_BIT   ; Gets the next word
00002056  301B                    2201          Move.W  (A3)+, D0               ; Stores the word in D0
00002058                          2202  
00002058  4EF9 0000205E           2203          Jmp     EA_BRANCH_ADD_DIS       ; Add the word to D6
0000205E                          2204          
0000205E                          2205  EA_BRANCH_ADD_DIS   ; Adds the displacement to the long word address in D6
0000205E  DC40                    2206          Add.W   D0, D6                  ; Add the displacement to D6
00002060                          2207      
00002060  1CFC 0024               2208          Move.B  #'$', (A6)+             ; Add '$' to the string
00002064                          2209          
00002064  4EB8 12CC               2210          Jsr     hex_to_ASCII_L       ; Add the long word sum to the string
00002068                          2211  
00002068  4E75                    2212          RTS
0000206A                          2213                         
0000206A                          2214  ;==========================================;        
0000206A                          2215  ;---------- General EA functions ----------;
0000206A                          2216  ;==========================================;
0000206A                          2217  EA_DN   ; Adds Dn EA to string
0000206A  1CFC 0044               2218          Move.B  #'D', (A6)+             
0000206E  0600 0030               2219          Add.B   #$30, D0        
00002072  1CC0                    2220          Move.B  D0, (A6)+               
00002074                          2221                  
00002074  4E75                    2222          Rts
00002076                          2223  
00002076                          2224  EA_AN   ; Adds An EA to string
00002076  1CFC 0041               2225          Move.B  #'A', (A6)+
0000207A  0600 0030               2226          Add.B   #$30, D0    
0000207E  1CC0                    2227          Move.B  D0, (A6)+               
00002080                          2228                  
00002080  4E75                    2229          Rts
00002082                          2230  
00002082                          2231  EA_AN_PNTR  ; Adds (An) EA to string
00002082  1CFC 0028               2232          Move.B  #'(', (A6)+
00002086  1CFC 0041               2233          Move.B  #'A', (A6)+
0000208A  0600 0030               2234          Add.B   #$30, D0
0000208E  1CC0                    2235          Move.B  D0, (A6)+
00002090  1CFC 0029               2236          Move.B  #')', (A6)+
00002094                          2237                  
00002094  4E75                    2238          Rts
00002096                          2239          
00002096                          2240  EA_AN_INC   ; Adds (An)+ EA to string
00002096  1CFC 0028               2241          Move.B  #'(', (A6)+
0000209A  1CFC 0041               2242          Move.B  #'A', (A6)+
0000209E  0600 0030               2243          Add.B   #$30, D0
000020A2  1CC0                    2244          Move.B  D0, (A6)+
000020A4  1CFC 0029               2245          Move.B  #')', (A6)+
000020A8  1CFC 002B               2246          Move.B  #'+', (A6)+
000020AC                          2247                  
000020AC  4E75                    2248          Rts 
000020AE                          2249          
000020AE                          2250  EA_AN_DEC   ; Adds -(An) EA to string
000020AE  1CFC 002D               2251          Move.B  #'-', (A6)+
000020B2  1CFC 0028               2252          Move.B  #'(', (A6)+
000020B6  1CFC 0041               2253          Move.B  #'A', (A6)+
000020BA  0600 0030               2254          Add.B   #$30, D0
000020BE  1CC0                    2255          Move.B  D0, (A6)+
000020C0  1CFC 0029               2256          Move.B  #')', (A6)+
000020C4                          2257                  
000020C4  4E75                    2258          Rts 
000020C6                          2259  
000020C6                          2260  EA_WORD_ADDR    ; Adds $Word to string
000020C6  3C1B                    2261          Move.W  (A3)+, D6           ; Move the word address into D6 and move forward in memory
000020C8                          2262          
000020C8  1CFC 0024               2263          Move.B  #'$', (A6)+
000020CC                          2264          
000020CC  BC7C 8000               2265          Cmp.W   #$8000, D6          ; Word address is less than 8000
000020D0  6500 000C               2266          Bcs     EA_SIGN_EXT_16
000020D4                          2267          
000020D4  BC7C 8000               2268          Cmp.W   #$8000, D6          ; Word address is greater than 8000
000020D8  6400 001A               2269          Bcc     EA_SIGN_EXT_32
000020DC                          2270          
000020DC  4E75                    2271          Rts
000020DE                          2272                  
000020DE                          2273  EA_SIGN_EXT_16  ; Adds 0 if the word address is 16 bit
000020DE  1CFC 0030               2274          Move.B  #'0', (A6)+
000020E2  1CFC 0030               2275          Move.B  #'0', (A6)+
000020E6  1CFC 0030               2276          Move.B  #'0', (A6)+
000020EA  1CFC 0030               2277          Move.B  #'0', (A6)+
000020EE                          2278          
000020EE  4EB8 12EC               2279          Jsr     hex_to_ASCII_W       
000020F2                          2280          
000020F2  4E75                    2281          Rts
000020F4                          2282  
000020F4                          2283  EA_SIGN_EXT_32 ; Adds F is the word address is 32 bit
000020F4  1CFC 0046               2284          Move.B  #'F', (A6)+
000020F8  1CFC 0046               2285          Move.B  #'F', (A6)+
000020FC  1CFC 0046               2286          Move.B  #'F', (A6)+
00002100  1CFC 0046               2287          Move.B  #'F', (A6)+
00002104                          2288          
00002104  4EB8 12EC               2289          Jsr     hex_to_ASCII_W   
00002108                          2290          
00002108  4E75                    2291          Rts
0000210A                          2292                  
0000210A                          2293  EA_LONG_ADDR    ; Adds $Long to string
0000210A  2C1B                    2294          Move.L  (A3)+, D6           ; Move the long address into D6 and move forward in memory
0000210C                          2295          
0000210C  1CFC 0024               2296          Move.B  #'$', (A6)+
00002110                          2297          
00002110  4EB8 12CC               2298          Jsr     hex_to_ASCII_L
00002114                          2299  
00002114  4E75                    2300          Rts
00002116                          2301                  
00002116                          2302  
00002116                          2303  EA_IMM_BYTE ; Finds the immediate byte data
00002116  3C1B                    2304          Move.W  (A3)+, D6            ; Move the immediate byte data into D6 and move forward in memory
00002118                          2305          
00002118  1CFC 0023               2306          Move.B  #'#', (A6)+         
0000211C  1CFC 0024               2307          Move.B  #'$', (A6)+         
00002120                          2308          
00002120  4EB8 130C               2309          Jsr     hex_to_ASCII_B    ; Add the byte to the string
00002124                          2310          
00002124  4E75                    2311          Rts
00002126                          2312                  
00002126                          2313  EA_IMM_WORD ; Finds the immediate word data
00002126  3C1B                    2314          Move.W  (A3)+, D6            ; Move the immediate word data into D6 and move forward in memory
00002128                          2315          
00002128  1CFC 0023               2316          Move.B  #'#', (A6)+         
0000212C  1CFC 0024               2317          Move.B  #'$', (A6)+         
00002130                          2318          
00002130  4EB8 12EC               2319          Jsr     hex_to_ASCII_W    ; Add the word to the string
00002134                          2320          
00002134  4E75                    2321          Rts
00002136                          2322          
00002136                          2323  EA_IMM_LONG ; Finds the immediate long data
00002136  2C1B                    2324          Move.L  (A3)+, D6            ; Move the immediate long data into D6 and move forward in memory
00002138                          2325          
00002138  1CFC 0023               2326          Move.B  #'#', (A6)+
0000213C  1CFC 0024               2327          Move.B  #'$', (A6)+
00002140                          2328          
00002140  4EB8 12CC               2329          Jsr     hex_to_ASCII_L    ; Add the long to the string
00002144                          2330          
00002144  4E75                    2331          Rts
00002146                          2332          
00002146                          2333  EA_0TO5 ; Determines the EA for an EA in bits 0-5. DOES NOT HANDLE IMMEDIATE VALUES.
00002146  4EB9 000021E0           2334          Jsr     GET3TO5                 ; Get source mode
0000214C  1A00                    2335          Move.B  D0, D5                  ; Move source mode to D5
0000214E  4EB9 000021F2           2336          Jsr     Get0TO2                 ; Get source register
00002154                          2337          
00002154                          2338          ; List of valid effective addresses
00002154  BA3C 0000               2339          Cmp.B   #Dn_Mode, D5            ; Dn
00002158  6700 FF10               2340          Beq     EA_DN
0000215C                          2341          
0000215C  BA3C 0001               2342          Cmp.B   #An_Mode, D5            ; An
00002160  6700 FF14               2343          Beq     EA_AN
00002164                          2344          
00002164  BA3C 0002               2345          Cmp.B   #An_Pntr_Mode, D5       ; (An)
00002168  6700 FF18               2346          Beq     EA_AN_PNTR
0000216C                          2347          
0000216C  BA3C 0003               2348          Cmp.B   #An_Inc_Mode, D5        ; (An)+
00002170  6700 FF24               2349          Beq     EA_AN_INC
00002174                          2350          
00002174  BA3C 0004               2351          Cmp.B   #An_Dec_Mode, D5        ; -(An)
00002178  6700 FF34               2352          Beq     EA_AN_DEC
0000217C                          2353          
0000217C                          2354          ; Comparing registers at this point because modes are the same
0000217C  B03C 0000               2355          Cmp.B   #Word_Reg, D0           ; (xxx).W
00002180  6700 FF44               2356          Beq     EA_WORD_ADDR
00002184                          2357          
00002184  B03C 0001               2358          Cmp.B   #Long_Reg, D0           ; (xxx).L
00002188  6780                    2359          Beq     EA_LONG_ADDR
0000218A                          2360          
0000218A  4E75                    2361          Rts
0000218C                          2362      
0000218C                          2363  
0000218C                          2364  ;---------------- Bit Chopping Sub Routines ----------------;
0000218C                          2365  ; These Sub Routines Chop a WORD size piece of data from
0000218C                          2366  ; Data register 4 into a smaller piece, leaving just the
0000218C                          2367  ; Piece in register 0 while leaving the original piece
0000218C                          2368  ; of data intact.
0000218C                          2369  
0000218C                          2370  ; REGISTERS USED: D0, D1, D4 (const input)
0000218C                          2371  
0000218C                          2372  GET12TO15   ;1001 0000 0000 0000 -> 1001
0000218C  4280                    2373                  CLR.L   D0      
0000218E  3004                    2374                  Move.W  D4, D0      
00002190                          2375                  
00002190  123C 000C               2376                  Move.B  #12, D1     
00002194  E268                    2377                  LSR.W       D1, D0      
00002196                          2378                  
00002196  4E75                    2379                  RTS
00002198                          2380                  
00002198                          2381  GET12TO13
00002198  4280                    2382          CLR.L   D0
0000219A  3004                    2383          Move.W  D4, D0
0000219C                          2384          
0000219C  123C 0002               2385          Move.B  #2, D1
000021A0  E368                    2386          LSL     D1, D0
000021A2                          2387          
000021A2  123C 000E               2388          Move.B  #14, D1
000021A6  E268                    2389          LSR     D1, D0
000021A8                          2390          
000021A8  4E75                    2391          RTS             
000021AA                          2392  
000021AA                          2393  GET8TO11    ; 0000 1010 0000 0000 -> 1010   
000021AA  4280                    2394                  CLR.L   D0      ; Clear out D0
000021AC  3004                    2395                  Move.W  D4, D0      ; Move a copy of the bit string to D0
000021AE                          2396                  
000021AE  123C 0004               2397                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
000021B2  E368                    2398                  LSL.W   D1, D0      ; Move the string all the way to the left
000021B4                          2399                  
000021B4  123C 000C               2400                  Move.B  #12, D1     ; Change the amount of bits shifted
000021B8  E268                    2401                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
000021BA                          2402                  
000021BA  4E75                    2403                  RTS         ; Return from the subroutine
000021BC                          2404                      
000021BC                          2405  GET9TO11    ; 0000 1010 0000 0000 -> 101    
000021BC  4280                    2406                  CLR.L   D0      ; Clear out D0
000021BE  3004                    2407                  Move.W  D4, D0      ; Move a copy of the bit string to D0
000021C0                          2408                  
000021C0  123C 0004               2409                  Move.B  #4, D1      ; This is nessassary to move by > 8 bits
000021C4  E368                    2410                  LSL.W   D1, D0      ; Move the string all the way to the left
000021C6                          2411                  
000021C6  123C 000D               2412                  Move.B  #13, D1     ; Change the amount of bits shifted
000021CA  E268                    2413                  LSR.W       D1, D0      ; Move the bits all the way back to the right, isolating the bits
000021CC                          2414                  
000021CC  4E75                    2415                  RTS         ; Return from the subroutine
000021CE                          2416                  
000021CE                          2417  GET6TO8     ; 0000 0001 1000 0000 -> 110
000021CE  4280                    2418                  CLR.L   D0
000021D0  3004                    2419                  Move.W  D4, D0
000021D2                          2420                  
000021D2  123C 0007               2421                  Move.B  #7, D1
000021D6  E368                    2422                  LSL.W   D1, D0
000021D8                          2423                  
000021D8  123C 000D               2424                  Move.B  #13, D1
000021DC  E268                    2425                  LSR.W       D1, D0
000021DE                          2426                  
000021DE  4E75                    2427                  RTS
000021E0                          2428                  
000021E0                          2429  GET3TO5     ; 0000 0000 0011 1000 -> 111
000021E0  4280                    2430                  CLR.L   D0
000021E2  3004                    2431                  Move.W  D4, D0
000021E4                          2432                  
000021E4  123C 000A               2433                  Move.B  #10, D1
000021E8  E368                    2434                  LSL.W   D1, D0
000021EA                          2435                  
000021EA  123C 000D               2436                  Move.B  #13, D1
000021EE  E268                    2437                  LSR.W       D1, D0
000021F0                          2438                  
000021F0  4E75                    2439                  RTS
000021F2                          2440  GET0TO2     ; 0000 0000 0000 0011 -> 011
000021F2  4280                    2441                  CLR.L   D0
000021F4  3004                    2442                  Move.W  D4, D0
000021F6                          2443                  
000021F6  123C 000D               2444                  Move.B  #13, D1
000021FA  E368                    2445                  LSL.W   D1, D0
000021FC                          2446                  
000021FC  123C 000D               2447                  Move.B  #13, D1
00002200  E268                    2448                  LSR.W       D1, D0
00002202                          2449                  
00002202  4E75                    2450                  RTS
00002204                          2451  GETBIT8     ; 0000 0001 0000 0000 -> 1
00002204  4280                    2452                  CLR.L   D0
00002206  3004                    2453                  Move.W  D4, D0
00002208                          2454                  
00002208  123C 0007               2455                  Move.B  #7, D1
0000220C  E368                    2456                  LSL.W   D1, D0
0000220E                          2457                  
0000220E  123C 000F               2458                  Move.B  #15, D1
00002212  E268                    2459                  LSR.W       D1, D0
00002214                          2460                  
00002214  4E75                    2461                  RTS
00002216                          2462                  
00002216                          2463  GET9AND10    ; 0000 0110 0000 0000 -> 11
00002216  4280                    2464                  CLR.L   D0
00002218  3004                    2465                  Move.W  D4, D0
0000221A                          2466                  
0000221A  123C 0005               2467                  Move.B  #5, D1
0000221E  E368                    2468                  LSL.W   D1, D0
00002220                          2469                  
00002220  123C 000E               2470                  Move.B  #14, D1
00002224  E268                    2471                  LSR.W   D1, D0
00002226                          2472                  
00002226  4E75                    2473                  RTS             
00002228                          2474                  
00002228                          2475  GET6AND7    
00002228  4280                    2476                  CLR.L   D0
0000222A  3004                    2477                  Move.W  D4, D0
0000222C                          2478                  
0000222C  123C 0008               2479                  Move.B  #8, D1
00002230  E368                    2480                  LSL.W   D1, D0
00002232                          2481                  
00002232  123C 000E               2482                  Move.B  #14, D1
00002236  E268                    2483                  LSR.W   D1, D0
00002238                          2484                  
00002238  4E75                    2485                  RTS
0000223A                          2486                  
0000223A                          2487  GET7AND8    
0000223A  4280                    2488                  CLR.L   D0
0000223C  3004                    2489                  Move.W  D4, D0
0000223E                          2490                  
0000223E  123C 0007               2491                  Move.B  #7, D1
00002242  E368                    2492                  LSL.W   D1, D0
00002244                          2493                  
00002244  123C 000E               2494                  Move.B  #14, D1
00002248  E268                    2495                  LSR.W   D1, D0
0000224A                          2496                  
0000224A  4E75                    2497                  RTS             
0000224C                          2498                  
0000224C                          2499  GET3AND4    
0000224C  4280                    2500                  CLR.L   D0
0000224E  3004                    2501                  Move.W  D4, D0
00002250                          2502                  
00002250  123C 000B               2503                  Move.B  #11, D1
00002254  E368                    2504                  LSL.W   D1, D0
00002256                          2505                  
00002256  123C 000E               2506                  Move.B  #14, D1
0000225A  E268                    2507                  LSR.W   D1, D0
0000225C                          2508                  
0000225C  4E75                    2509                  RTS
0000225E                          2510                  
0000225E                          2511  GETBIT5
0000225E  4280                    2512          Clr.L   D0
00002260  3004                    2513          Move.W  D4, D0
00002262                          2514          
00002262  123C 000A               2515          Move.B  #10, D1
00002266  E368                    2516          Lsl     D1, D0
00002268                          2517          
00002268  123C 000F               2518          Move.B  #15, D1
0000226C  E268                    2519          Lsr     D1, D0
0000226E                          2520          
0000226E  4E75                    2521          Rts
00002270                          2522  
00002270                          2523  GET0TO7
00002270  4280                    2524          Clr.L   D0
00002272  3004                    2525          Move.W  D4, D0
00002274                          2526          
00002274  123C 0008               2527          Move.B  #8, D1
00002278  E368                    2528          Lsl     D1, D0
0000227A                          2529          
0000227A  E268                    2530          Lsr     D1, D0
0000227C                          2531          
0000227C  4E75                    2532          Rts
0000227E                          2533          
0000227E                          2534  GETBIT10
0000227E  4280                    2535          Clr.L   D0
00002280  3004                    2536          Move.W  D4, D0
00002282                          2537          
00002282  123C 0005               2538          Move.B  #5, D1
00002286  E368                    2539          Lsl     D1, D0
00002288                          2540          
00002288  123C 000F               2541          Move.B  #15, D1
0000228C  E268                    2542          Lsr     D1, D0
0000228E                          2543          
0000228E  4E75                    2544          Rts
00002290                          2545          
00002290                          2546  GET6TO7
00002290  4280                    2547          Clr.L   D0
00002292  3004                    2548          Move.W  D4, D0
00002294                          2549          
00002294  123C 0008               2550          Move.B  #8, D1
00002298  E368                    2551          Lsl     D1, D0
0000229A                          2552          
0000229A  123C 000E               2553          Move.B  #14, D1
0000229E  E268                    2554          Lsr     D1, D0
000022A0                          2555          
000022A0  4E75                    2556          Rts
000022A2                          2557  
000022A2                          2558  GET3TO8    ; 0000 0000 1100 0000 -> 11
000022A2  4280                    2559                  CLR.L   D0
000022A4  3004                    2560                  Move.W  D4, D0
000022A6                          2561                  
000022A6  123C 0007               2562                  Move.B  #7, D1
000022AA  E368                    2563                  LSL.W   D1, D0
000022AC                          2564                  
000022AC  123C 000A               2565                  Move.B  #10, D1
000022B0  E268                    2566                  LSR.W   D1, D0
000022B2                          2567                  
000022B2  4E75                    2568                  RTS
000022B4                          2569  
000022B4                          2570  GET6TO11    ; 0000 0000 1100 0000 -> 11
000022B4  4280                    2571                  CLR.L   D0
000022B6  3004                    2572                  Move.W  D4, D0
000022B8                          2573                  
000022B8  123C 0004               2574                  Move.B  #4, D1
000022BC  E368                    2575                  LSL.W   D1, D0
000022BE                          2576                  
000022BE  123C 000A               2577                  Move.B  #10, D1
000022C2  E268                    2578                  LSR.W   D1, D0
000022C4                          2579                  
000022C4  4E75                    2580                  RTS        
000022C6                          2581                  
000022C6                          2582             
000022C6                          2583  ;-----------Constants/Messages-------------------------------------------------
000022C6= 20 5F 5F 5F 5F 5F ...   2584  psychobots1     DC.B    ' _____  ____   _  _   ____   __  __   _____    _____   _____    _____    ___',CR,LF,0
00002315= 2F 5C 20 3D 3D 20 ...   2585  psychobots2     DC.B    '/\ == \/\  _\ /\\_\\ /\  _\ /\ \_\ \ /\  __ \ /\ == \ /\  __ \ /\_   _\ /\  _\',CR,LF,0
00002366= 5C 20 5C 20 20 2D ...   2586  psychobots3     DC.B    '\ \  -/\ \__ \\ \__ \\ \ \__\ \  __ \\ \ \/\ \\ \  _< \ \ \/\ \\/_/\ \/ \ \__ \',CR,LF,0
000023B8= 20 5C 20 5C 5F 5C ...   2587  psychobots4     DC.B    ' \ \_\  \/\___\\/\___\\ \___\\ \_\ \_\\ \_____\\ \____\\ \_____\  \ \_\  \/\___\',CR,LF,0
0000240B= 20 20 5C 2F 5F 2F ...   2588  psychobots5     DC.B    '  \/_/   \/___/ \/___/ \/___/ \/_/\/_/ \/_____/ \/_____/\/_____/   \/_/   \/___/',CR,LF,0
0000245E= 09 09 2D 2D 2D 2D ...   2589  intro_stuff     DC.B    HT,HT,'------------------------------------------------------',CR,LF,0
00002499                          2590  
00002499= 09 09 20 57 65 6C ...   2591  intro_msg       DC.B    HT,HT,' Welcome to the Motorola 68K Instruction Disassembler',CR,LF
000024D2= 09 09 20 43 72 65 ...   2592                  DC.B    HT,HT,' Created By: Blong Thao, Curtis Andersson, John Louie',CR,LF,0
0000250C                          2593         
0000250C= 50 6C 65 61 73 65 ...   2594  start_address   DC.B    'Please enter the starting address from $0 to $00FFFFFE: ',0
00002545= 50 6C 65 61 73 65 ...   2595  end_address1    DC.B    'Please enter the ending address from $',0
0000256C= 20 74 6F 20 24 30 ...   2596  end_address2    DC.B    ' to $00FFFFFE: ',0
0000257C= 54 68 61 6E 6B 20 ...   2597  ending          DC.B    'Thank you for using our 68K Disassembler Program!',0
000025AE= 57 6F 75 6C 64 20 ...   2598  ask_user        DC.B    'Would you like to run the program again? (Y/N) ',0
000025DE= 48 69 74 20 65 6E ...   2599  hit_enter_msg   DC.B    'Hit enter if you would like to see more data.',0
0000260C                          2600  
0000260C= 09 41 64 64 72 65 ...   2601  badAddr_input   DC.B    HT,'Address entered is not within the specified range!',CR,LF,0
00002642= 09 59 6F 75 20 6E ...   2602  odd_input       DC.B    HT,'You need to enter an even ending address',CR,LF,0
0000266E= 09 50 6C 65 61 73 ...   2603  ask_error       DC.B    HT,'Please try again, on next line please input a Y or N', CR,LF,0
000026A6                          2604  
000026A6                          2605  start_input     DS.L    2               ; Allocates space for start address
000026AE                          2606  end_input       DS.L    2               ; Allocates space for end address
000026B6                          2607  ask_input       DS.L    2               ; User input for Y and N, pre-end of program
000026BE                          2608  hit_enter       DS.L    2               ; User input to hit enter
000026C6                          2609  line_count      DS.L    1               ; Holds the display line count  
000026CA                          2610  illegal_data    DS.L    80              ; Data/Instructions that we do not convert
0000280A                          2611  valid_data      DS.L    80              ; Instructions that we converted
0000294A                          2612                  
0000294A                          2613                  END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AND_MULS            153C
AN_DEC_MODE         4
AN_INC_MODE         3
AN_MODE             1
AN_PNTR_MODE        2
ASK_ERROR           266E
ASK_INPUT           26B6
ASK_USER            25AE
BADADDR_INPUT       260C
BAD_BUFF            1170
BEGIN               0
BIT_SHIFT           157C
BIT_SHIFT_MEM       158E
BIT_SHIFT_REG       15B0
BRANCH_CONDITIONALS  14BA
CHECK_10_LINES      11C6
CHECK_INPUT         1280
CHK_BOUND           1372
CMP_EOR             15D2
CONVERT_HEX         132C
CR                  D
DISASSEMBLE         111A
DISPLAY_DATA        118A
DN_MODE             0
DONE                125E
DONE_CONVERTING     134E
EA_0TO5             2146
EA_ADD              1DF6
EA_ADDA             1E2A
EA_ADDQ             1EB2
EA_ADDQ_CHECK_8     1EC4
EA_ADDQ_DEST        1EE8
EA_ADDQ_IMMEDIATE   1EDC
EA_ADD_ADDRESS      1E72
EA_ADD_OPMODE_DEST  1E5A
EA_ADD_OPMODE_SOURCE  1E42
EA_ADD_SIZE         1E82
EA_AN               2076
EA_AND              1EFC
EA_AN_DEC           20AE
EA_AN_INC           2096
EA_AN_PNTR          2082
EA_BIT_SHIFT        1F14
EA_BRANCH           2040
EA_BRANCH_16_BIT    2056
EA_BRANCH_ADD_DIS   205E
EA_BTST             1FF6
EA_BTST_ADDRESS     202C
EA_BTST_DN          200A
EA_BTST_IMM         201E
EA_CMP              1EF4
EA_DIVS             1FF2
EA_DN               206A
EA_EOR              1F00
EA_IMMEDIATE        1F92
EA_IMMEDIATE_DEST   1FC2
EA_IMMEDIATE_SIZE   1FA4
EA_IMM_BYTE         2116
EA_IMM_LONG         2136
EA_IMM_WORD         2126
EA_JSR              1F10
EA_LEA              1EF8
EA_LONG_ADDR        210A
EA_MOVE             1BB2
EA_MOVEM            1C3C
EA_MOVEM_ADD_LAST_REG  1D26
EA_MOVEM_ADD_SINGLE_REG  1D06
EA_MOVEM_CARRY_CLEAR  1CE6
EA_MOVEM_CARRY_SET  1CC6
EA_MOVEM_FIRST_REG  1CF6
EA_MOVEM_LAST_REG   1D18
EA_MOVEM_LIST_END   1CB0
EA_MOVEM_LIST_LOOP  1C94
EA_MOVEM_MEM_TO_REG  1C78
EA_MOVEM_POST_INC   1CBC
EA_MOVEM_PRE_DEC    1CB2
EA_MOVEM_REG        1D3A
EA_MOVEM_REG_TO_MEM  1C62
EA_MOVE_DEST        1BD4
EA_MOVE_SIZE        1C1C
EA_MOVE_SOURCE      1BC4
EA_MULS             1FCA
EA_MULS_ADDRESS     1FE2
EA_NEG              1F04
EA_NOT              1F0C
EA_SHIFT_CHECK_8    1F46
EA_SHIFT_COMMA      1F80
EA_SHIFT_DN         1F6E
EA_SHIFT_IMMEDIATE  1F5E
EA_SHIFT_MEMORY     1F2A
EA_SHIFT_REGISTER   1F32
EA_SIGN_EXT_16      20DE
EA_SIGN_EXT_32      20F4
EA_SUB              1EF0
EA_WORD_ADDR        20C6
END                 FFFFFE
ENDING              257C
END_ADDRESS1        2545
END_ADDRESS2        256C
END_ERROR           135A
END_INPUT           26AE
GET0TO2             21F2
GET0TO7             2270
GET12TO13           2198
GET12TO15           218C
GET3AND4            224C
GET3TO5             21E0
GET3TO8             22A2
GET6AND7            2228
GET6TO11            22B4
GET6TO7             2290
GET6TO8             21CE
GET7AND8            223A
GET8TO11            21AA
GET9AND10           2216
GET9TO11            21BC
GETBIT10            227E
GETBIT5             225E
GETBIT8             2204
GOOD_BUFF           1180
HEX_ASCII_LOOPB     1316
HEX_ASCII_LOOPL     12D6
HEX_ASCII_LOOPW     12F6
HEX_TO_ASCII_B      130C
HEX_TO_ASCII_L      12CC
HEX_TO_ASCII_W      12EC
HIT_ENTER           26BE
HIT_ENTER_MSG       25DE
HT                  9
ILLEGAL             1194
ILLEGAL_DATA        26CA
IMMEDIATE_BTST      1414
IMM_MODE            7
IMM_REG             4
INTRO_MSG           2499
INTRO_STUFF         245E
INVALID             12C4
IS_LETTER           12B6
IS_NUMBER           12AE
JSR_CHECK           14A8
LF                  A
LINE_COUNT          26C6
LOAD_BAD_INPUT      1364
LONG_MODE           7
LONG_REG            1
LOOP_TAB            1B2A
MAIN_LOOP           1160
MAKE_LETTER         1344
MAKE_NUMBER         1338
ODD_ERR             1386
ODD_INPUT           2642
OP_ADD              16EA
OP_ADDQ             1640
OP_ADD_ADDR         1714
OP_ADD_ADDRESS_VERSION  1B3E
OP_AND              19F4
OP_AS_MEM           1A2E
OP_AS_REG           1A10
OP_BRANCH           1888
OP_BRA_CC           18CA
OP_BRA_CS           18E0
OP_BRA_EQ           190C
OP_BRA_GE           197A
OP_BRA_GT           19A6
OP_BRA_HIGH         189E
OP_BRA_LE           19BC
OP_BRA_LOW          18B4
OP_BRA_LT           1990
OP_BRA_MI           1964
OP_BRA_NE           18F6
OP_BRA_PL           194E
OP_BRA_VC           1922
OP_BRA_VS           1938
OP_BTST             1728
OP_CHECK_ADDRESS_VERSION  1B34
OP_CHECK_DATA_SIZE  1B44
OP_CHECK_DATA_SIZE_ADDR  1B64
OP_CMP              1AB2
OP_CMPI             179E
OP_CMP_ADDR         1ADC
OP_CODE_TREE        1398
OP_DIVS             167C
OP_EOR              1AF0
OP_EORI             177E
OP_JSR              1872
OP_LEA              17BE
OP_LS_MEM           1A64
OP_LS_REG           1A46
OP_MOVE             15F4
OP_MOVEM            180C
OP_MOVEM_DATA       184C
OP_MOVE_DATA        1626
OP_MULS             19D2
OP_NEG              17D4
OP_NOT              17F0
OP_ORI              1742
OP_RO_MEM           1A9A
OP_RO_REG           1A7C
OP_RTS              185E
OP_SET_BAD_BUFFER   1B1A
OP_SET_DATA_BYTE    1B76
OP_SET_DATA_LONG    1B8A
OP_SET_DATA_WORD    1B80
OP_SHIFT_DIRECTION  1B94
OP_SHIFT_LEFT       1BAC
OP_SHIFT_RIGHT      1BA6
OP_SUB              16AC
OP_SUBI             175E
OP_SUB_ADDR         16D6
OP_TAB              1B20
PROMPT_END          10B6
PROMPT_FOR_DATA     11D8
PROMPT_START        1060
PROMPT_TO_RERUN     11F6
PSYCHOBOTS1         22C6
PSYCHOBOTS2         2315
PSYCHOBOTS3         2366
PSYCHOBOTS4         23B8
PSYCHOBOTS5         240B
RERUN_ERR_MSG       1250
RETURN              12C8
SINGLE_OPERATOR_CODES  1468
START               1000
START_ADDRESS       250C
START_ERROR         1350
START_INPUT         26A6
VALID_DATA          280A
VALID_END           10FA
VALID_START         1094
VERIFIED            12BE
VERIFY_INPUT        126E
WORD_MODE           7
WORD_REG            0
